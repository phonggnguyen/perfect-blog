{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["export type Node = DocumentNode | ElementNode | TextNode | CommentNode | DoctypeNode;\nexport type NodeType = typeof DOCUMENT_NODE | typeof ELEMENT_NODE | typeof TEXT_NODE | typeof COMMENT_NODE | typeof DOCTYPE_NODE;\nexport interface Location {\n  start: number;\n  end: number;\n}\ninterface BaseNode {\n  type: NodeType;\n  loc: [Location, Location];\n  parent: Node;\n  [key: string]: any;\n}\n\ninterface LiteralNode extends BaseNode {\n  value: string;\n}\n\ninterface ParentNode extends BaseNode {\n  children: Node[]\n}\n\nexport interface DocumentNode extends Omit<ParentNode, 'parent'> {\n  type: typeof DOCUMENT_NODE;\n  attributes: Record<string, string>;\n  parent: undefined;\n}\n\nexport interface ElementNode extends ParentNode {\n  type: typeof ELEMENT_NODE;\n  name: string;\n  attributes: Record<string, string>;\n}\n\nexport interface TextNode extends LiteralNode {\n  type: typeof TEXT_NODE;\n}\n\nexport interface CommentNode extends LiteralNode {\n  type: typeof COMMENT_NODE;\n}\n\nexport interface DoctypeNode extends LiteralNode {\n  type: typeof DOCTYPE_NODE;\n}\n\nexport const DOCUMENT_NODE = 0;\nexport const ELEMENT_NODE = 1;\nexport const TEXT_NODE = 2;\nexport const COMMENT_NODE = 3;\nexport const DOCTYPE_NODE = 4;\n\nconst VOID_TAGS = { img: 1, br: 1, hr: 1, meta: 1, link: 1, base: 1, input: 1 };\nconst SPLIT_ATTRS_RE = /([\\@\\.a-z0-9_\\:\\-]*)\\s*?=?\\s*?(['\"]?)(.*?)\\2\\s+/gim;\nconst DOM_PARSER_RE =\n  /(?:<(\\/?)([a-zA-Z][a-zA-Z0-9\\:-]*)(?:\\s([^>]*?))?((?:\\s*\\/)?)>|(<\\!\\-\\-)([\\s\\S]*?)(\\-\\->)|(<\\!)([\\s\\S]*?)(>))/gm;\n\nfunction splitAttrs(str?: string) {\n  let obj: Record<string, string> = {};\n  let token: any;\n  if (str) {\n    SPLIT_ATTRS_RE.lastIndex = 0;\n    str = \" \" + (str || \"\") + \" \";\n    while ((token = SPLIT_ATTRS_RE.exec(str))) {\n      if (token[0] === \" \") continue;\n      obj[token[1]] = token[3];\n    }\n  }\n  return obj;\n}\n\nexport function parse(input: string | ReturnType<typeof html>): any {\n  let str = typeof input === \"string\" ? input : input.value;\n  let doc: Node,\n    parent: Node,\n    token: any,\n    text,\n    i,\n    bStart,\n    bText,\n    bEnd,\n    tag: Node;\n  const tags: Node[] = [];\n  DOM_PARSER_RE.lastIndex = 0;\n  parent = doc = {\n    type: DOCUMENT_NODE,\n    children: [] as Node[],\n  } as any;\n\n  let lastIndex = 0;\n  function commitTextNode() {\n    text = str.substring(lastIndex, DOM_PARSER_RE.lastIndex - token[0].length);\n    if (text) {\n      (parent as ParentNode).children.push({\n        type: TEXT_NODE,\n        value: text,\n        parent\n      } as any)\n    }\n  }\n\n  while ((token = DOM_PARSER_RE.exec(str))) {\n    bStart = token[5] || token[8];\n    bText = token[6] || token[9];\n    bEnd = token[7] || token[10];\n    if (bStart === \"<!--\") {\n      i = DOM_PARSER_RE.lastIndex - token[0].length;\n      tag = {\n        type: COMMENT_NODE,\n        value: bText,\n        parent: parent,\n        loc: [\n          {\n            start: i,\n            end: i + bStart.length,\n          },\n          {\n            start: DOM_PARSER_RE.lastIndex - bEnd.length,\n            end: DOM_PARSER_RE.lastIndex,\n          },\n        ],\n      } as any;\n      tags.push(tag);\n      (tag.parent as any).children.push(tag);\n    } else if (bStart === \"<!\") {\n      i = DOM_PARSER_RE.lastIndex - token[0].length;\n      tag = {\n        type: DOCTYPE_NODE,\n        value: bText,\n        parent: parent,\n        loc: [\n          {\n            start: i,\n            end: i + bStart.length,\n          },\n          {\n            start: DOM_PARSER_RE.lastIndex - bEnd.length,\n            end: DOM_PARSER_RE.lastIndex,\n          },\n        ],\n      };\n      // commitTextNode();\n      tags.push(tag);\n      tag.parent.children.push(tag);\n    } else if (token[1] !== \"/\") {\n      commitTextNode();\n      tag = {\n        type: ELEMENT_NODE,\n        name: token[2] + \"\",\n        attributes: splitAttrs(token[3]),\n        parent,\n        children: [],\n        loc: [\n          {\n            start: DOM_PARSER_RE.lastIndex - token[0].length,\n            end: DOM_PARSER_RE.lastIndex,\n          },\n        ] as any,\n      };\n      tags.push(tag);\n      tag.parent.children.push(tag);\n      if (\n        (token[4] && token[4].indexOf(\"/\") > -1) ||\n        VOID_TAGS.hasOwnProperty(tag.name)\n      ) {\n        tag.loc[1] = tag.loc[0];\n        tag.isSelfClosingTag = true;\n      } else {\n        parent = tag;\n      }\n    } else {\n      commitTextNode();\n      // Close parent node if end-tag matches\n      if (token[2] + \"\" === parent.name) {\n        tag = parent;\n        parent = tag.parent!;\n        tag.loc.push({\n          start: DOM_PARSER_RE.lastIndex - token[0].length,\n          end: DOM_PARSER_RE.lastIndex,\n        });\n        text = str.substring(tag.loc[0].end, tag.loc[1].start);\n        if (tag.children.length === 0) {\n          tag.children.push({\n            type: TEXT_NODE,\n            value: text,\n            parent,\n          });\n        }\n      }\n      // account for abuse of self-closing tags when an end-tag is also provided:\n      else if (\n        token[2] + \"\" === tags[tags.length - 1].name &&\n        tags[tags.length - 1].isSelfClosingTag === true\n      ) {\n        tag = tags[tags.length - 1];\n        tag.loc.push({\n          start: DOM_PARSER_RE.lastIndex - token[0].length,\n          end: DOM_PARSER_RE.lastIndex,\n        });\n      }\n    }\n    lastIndex = DOM_PARSER_RE.lastIndex\n  }\n  text = str.slice(lastIndex);\n  parent.children.push({\n    type: TEXT_NODE,\n    value: text,\n    parent,\n  });\n  return doc;\n}\n\nexport interface Visitor {\n  (node: Node, parent?: Node, index?: number): void | Promise<void>;\n}\n\nexport interface VisitorSync {\n  (node: Node, parent?: Node, index?: number): void;\n}\n\nclass Walker {\n  constructor(private callback: Visitor) {}\n  async visit(node: Node, parent?: Node, index?: number): Promise<void> {\n    await this.callback(node, parent, index);\n    if (Array.isArray(node.children)) {\n      let promises = [];\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        promises.push(this.visit(child, node, i));\n      }\n      await Promise.all(promises);\n    }\n  }\n}\n\nclass WalkerSync {\n  constructor(private callback: VisitorSync) {}\n  visit(node: Node, parent?: Node, index?: number): void {\n    this.callback(node, parent, index);\n    if (Array.isArray(node.children)) {\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i];\n        this.visit(child, node, i);\n      }\n    }\n  }\n}\n\nconst HTMLString = Symbol(\"HTMLString\");\nconst AttrString = Symbol(\"AttrString\");\nfunction mark(str: string, tags: symbol[] = [HTMLString]): { value: string } {\n  const v = { value: str };\n  for (const tag of tags) {\n    Object.defineProperty(v, tag, {\n      value: true,\n      enumerable: false,\n      writable: false,\n    });\n  }\n  return v;\n}\n\nexport function __unsafeHTML(str: string) {\n  return mark(str);\n}\n\nconst ESCAPE_CHARS: Record<string, string> = {\n  \"&\": \"&amp;\",\n  \"<\": \"&lt;\",\n  \">\": \"&gt;\",\n};\nfunction escapeHTML(str: string): string {\n  return str.replace(/[&<>]/g, (c) => ESCAPE_CHARS[c] || c);\n}\nexport function attrs(attributes: Record<string, string>) {\n  let attrStr = \"\";\n  for (const [key, value] of Object.entries(attributes)) {\n    attrStr += ` ${key}=\"${value}\"`;\n  }\n  return mark(attrStr, [HTMLString, AttrString]);\n}\nexport function html(tmpl: TemplateStringsArray, ...vals: any[]) {\n  let buf = \"\";\n  for (let i = 0; i < tmpl.length; i++) {\n    buf += tmpl[i];\n    const expr = vals[i];\n    if (buf.endsWith(\"...\") && expr && typeof expr === \"object\") {\n      buf = buf.slice(0, -3).trimEnd();\n      buf += attrs(expr).value;\n    } else if (expr && expr[AttrString]) {\n      buf = buf.trimEnd();\n      buf += expr.value;\n    } else if (expr && expr[HTMLString]) {\n      buf += expr.value;\n    } else if (typeof expr === \"string\") {\n      buf += escapeHTML(expr);\n    } else if (expr || expr === 0) {\n      buf += String(expr);\n    }\n  }\n  return mark(buf);\n}\n\nexport function walk(node: Node, callback: Visitor): Promise<void> {\n  const walker = new Walker(callback);\n  return walker.visit(node);\n}\n\nexport function walkSync(node: Node, callback: VisitorSync): void {\n  const walker = new WalkerSync(callback);\n  return walker.visit(node);\n}\n\nexport interface SanitizeOptions {\n  /** An Array of strings indicating elements that the sanitizer should not remove. All elements not in the array will be dropped. */\n  allowElements?: string[];\n  /** An Array of strings indicating elements that the sanitizer should remove, but keeping their child elements. */\n  blockElements?: string[];\n  /** An Array of strings indicating elements (including nested elements) that the sanitizer should remove. */\n  dropElements?: string[];\n  /** An Object where each key is the attribute name and the value is an Array of allowed tag names. Matching attributes will not be removed. All attributes that are not in the array will be dropped. */\n  allowAttributes?: Record<string, string[]>;\n  /** An Object where each key is the attribute name and the value is an Array of dropped tag names. Matching attributes will be removed. */\n  dropAttributes?: Record<string, string[]>;\n  /** A Boolean value set to false (default) to remove components and their children. If set to true, components will be subject to built-in and custom configuration checks (and will be retained or dropped based on those checks). */\n  allowComponents?: boolean;\n  /** A Boolean value set to false (default) to remove custom elements and their children. If set to true, custom elements will be subject to built-in and custom configuration checks (and will be retained or dropped based on those checks). */\n  allowCustomElements?: boolean;\n  /** A Boolean value set to false (default) to remove HTML comments. Set to true in order to keep comments. */\n  allowComments?: boolean;\n}\nexport interface RenderOptions {\n  sanitize?: SanitizeOptions | boolean;\n  components?: {\n    [tag: string]:\n      | string\n      | ((\n          attrs: Record<string, any>,\n          children: ReturnType<typeof html>\n        ) => ReturnType<typeof html>);\n  };\n}\n\nfunction resolveSantizeOptions({\n  components = {},\n  sanitize = true,\n}: RenderOptions): SanitizeOptions {\n  if (sanitize === true) {\n    return {\n      allowElements: Object.keys(components),\n      dropElements: [\"script\"],\n      allowComponents: false,\n      allowCustomElements: false,\n      allowComments: false,\n    };\n  } else if (sanitize === false) {\n    return {\n      dropElements: [],\n      allowComponents: true,\n      allowCustomElements: true,\n      allowComments: true,\n    };\n  } else {\n    const dropElements = new Set<string>([]);\n    if (!sanitize.allowElements?.includes(\"script\")) {\n      dropElements.add(\"script\");\n    }\n    for (const dropElement of sanitize.dropElements ?? []) {\n      dropElements.add(dropElement);\n    }\n    return {\n      allowComponents: false,\n      allowCustomElements: false,\n      allowComments: false,\n      ...sanitize,\n      allowElements: [\n        ...Object.keys(components),\n        ...(sanitize.allowElements ?? []),\n      ],\n      dropElements: Array.from(dropElements),\n    };\n  }\n}\n\ntype NodeKind = \"element\" | \"component\" | \"custom-element\";\nfunction getNodeKind(node: Node): NodeKind {\n  if (node.name.includes(\"-\")) return \"custom-element\";\n  if (/[\\_\\$A-Z]/.test(node.name[0]) || node.name.includes(\".\"))\n    return \"component\";\n  return \"element\";\n}\n\ntype ActionType = \"allow\" | \"drop\" | \"block\";\nfunction getAction(\n  name: string,\n  kind: NodeKind,\n  sanitize: Required<SanitizeOptions>\n): ActionType {\n  if (sanitize.allowElements?.length > 0) {\n    if (sanitize.allowElements.includes(name)) return \"allow\";\n  }\n  if (sanitize.blockElements?.length > 0) {\n    if (sanitize.blockElements.includes(name)) return \"block\";\n  }\n  if (sanitize.dropElements?.length > 0) {\n    if (sanitize.dropElements.find((n) => n === name)) return \"drop\";\n  }\n  if (kind === \"component\" && !sanitize.allowComponents) return \"drop\";\n  if (kind === \"custom-element\" && !sanitize.allowCustomElements) return \"drop\";\n  return \"allow\";\n}\n\nfunction sanitizeAttributes(\n  node: Node,\n  sanitize: Required<SanitizeOptions>\n): Record<string, string> {\n  const attrs: Record<string, string> = node.attributes;\n  for (const key of Object.keys(node.attributes)) {\n    if (\n      (sanitize.allowAttributes?.[key] &&\n        sanitize.allowAttributes?.[key].includes(node.name)) ||\n      sanitize.allowAttributes?.[key].includes(\"*\")\n    ) {\n      continue;\n    }\n    if (\n      (sanitize.dropAttributes?.[key] &&\n        sanitize.dropAttributes?.[key].includes(node.name)) ||\n      sanitize.dropAttributes?.[key].includes(\"*\")\n    ) {\n      delete attrs[key];\n    }\n  }\n  return attrs;\n}\n\nasync function renderElement(\n  node: Node,\n  opts: Required<RenderOptions>\n): Promise<string> {\n  const kind = getNodeKind(node);\n  const { name } = node;\n  const action = getAction(\n    name,\n    kind,\n    opts.sanitize as Required<SanitizeOptions>\n  );\n  if (action === \"drop\") return \"\";\n  if (action === \"block\")\n    return await Promise.all(\n      node.children.map((child: Node) => render(child, opts))\n    ).then((res) => res.join(\"\"));\n\n  const component = opts.components[node.name];\n  if (typeof component === \"string\")\n    return renderElement({ ...node, name: component }, opts);\n  const attributes = sanitizeAttributes(\n    node,\n    opts.sanitize as Required<SanitizeOptions>\n  );\n  if (typeof component === \"function\") {\n    const value = await component(\n      attributes,\n      mark(\n        await Promise.all(\n          node.children.map((child: Node) => render(child, opts))\n        ).then((res) => res.join(\"\"))\n      )\n    );\n    if (value && (value as any)[HTMLString]) return value.value;\n    return escapeHTML(String(value));\n  }\n  if (VOID_TAGS.hasOwnProperty(name)) {\n    return `<${node.name}${attrs(attributes).value}>`;\n  }\n  return `<${node.name}${attrs(attributes).value}>${await Promise.all(\n    node.children.map((child: Node) => render(child, opts))\n  ).then((res) => res.join(\"\"))}</${node.name}>`;\n}\n\nexport async function render(\n  node: Node,\n  opts: RenderOptions = {}\n): Promise<string> {\n  const sanitize = resolveSantizeOptions(opts);\n  switch (node.type) {\n    case DOCUMENT_NODE: {\n      return Promise.all(\n        node.children.map((child: Node) => render(child, opts))\n      ).then((res) => res.join(\"\"));\n    }\n    case ELEMENT_NODE:\n      return renderElement(node, {\n        components: opts.components ?? {},\n        sanitize,\n      });\n    case TEXT_NODE: {\n      return `${node.value}`;\n    }\n    case COMMENT_NODE: {\n      if (sanitize.allowComments) {\n        return `<!--${node.value}-->`;\n      } else {\n        return \"\";\n      }\n    }\n    case DOCTYPE_NODE: {\n      return `<!${node.value}>`;\n    }\n  }\n}\n\nexport async function transform(\n  input: string | ReturnType<typeof html>,\n  opts: RenderOptions = {}\n) {\n  return render(parse(input), opts);\n}\n"],
  "mappings": "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",
  "names": ["DOCUMENT_NODE", "ELEMENT_NODE", "TEXT_NODE", "COMMENT_NODE", "DOCTYPE_NODE", "VOID_TAGS", "SPLIT_ATTRS_RE", "DOM_PARSER_RE", "splitAttrs", "str", "obj", "token", "parse", "input", "doc", "parent", "text", "i", "bStart", "bText", "bEnd", "tag", "tags", "lastIndex", "commitTextNode", "Walker", "callback", "node", "index", "promises", "child", "WalkerSync", "HTMLString", "AttrString", "mark", "v", "__unsafeHTML", "ESCAPE_CHARS", "escapeHTML", "c", "attrs", "attributes", "attrStr", "key", "value", "html", "tmpl", "vals", "buf", "expr", "walk", "walkSync", "resolveSantizeOptions", "components", "sanitize", "_a", "dropElements", "dropElement", "getNodeKind", "getAction", "name", "kind", "_b", "_c", "n", "sanitizeAttributes", "_d", "_e", "_f", "renderElement", "opts", "action", "render", "res", "component", "transform"]
}
