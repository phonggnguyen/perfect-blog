import * as vue from 'vue';
import { Plugin, App } from 'vue';
import { MergeHead, Head as Head$1 } from '@zhead/schema';
import { ReactiveHead } from '@zhead/schema-vue';
import { MaybeComputedRef } from '@vueuse/shared';
export { MaybeComputedRef } from '@vueuse/shared';

interface HandlesDuplicates {
    /**
     * By default, tags which share the same unique key `name, `property` are de-duped. To allow duplicates
     * to be made you can provide a unique key for each entry.
     */
    key?: string;
    /**
     * @deprecated Use `key` instead
     */
    hid?: string;
    /**
     * @deprecated Use `key` instead
     */
    vmid?: string;
}
interface RendersToBody {
    /**
     * Render tag at the end of the <body>.
     */
    body?: boolean;
}
interface HasTextContent {
    /**
     * Text content of the tag.
     *
     * Alias for children
     */
    innerHTML?: string;
    /**
     * Sets the textContent of an element.
     */
    children?: string;
    /**
     * Sets the textContent of an element. This will be HTML encoded.
     *
     * Alias for children
     */
    textContent?: string;
}
interface HasRenderPriority {
    /**
     * The priority for rendering the tag, without this all tags are rendered as they are registered
     * (besides some special tags).
     *
     * The following special tags have default priorities:
     * * -2 <meta charset ...>
     * * -1 <base>
     * * 0 <meta http-equiv="content-security-policy" ...>
     *
     * All other tags have a default priority of 10: <meta>, <script>, <link>, <style>, etc
     */
    renderPriority?: number;
}
declare type Never<T> = {
    [P in keyof T]?: never;
};
interface VueUseHeadSchema extends MergeHead {
    base: Never<HandlesDuplicates & HasTextContent & HasRenderPriority & RendersToBody>;
    link: HasRenderPriority & RendersToBody & Never<HasTextContent & HandlesDuplicates>;
    meta: HasRenderPriority & HandlesDuplicates & Never<HasTextContent & RendersToBody>;
    style: HasRenderPriority & RendersToBody & HasTextContent & Never<HandlesDuplicates>;
    script: HasRenderPriority & RendersToBody & HasTextContent & HandlesDuplicates;
    noscript: HasRenderPriority & RendersToBody & HasTextContent & Never<HandlesDuplicates>;
    htmlAttrs: Never<HandlesDuplicates & HasTextContent & HasRenderPriority & RendersToBody>;
    bodyAttrs: Never<HandlesDuplicates & HasTextContent & HasRenderPriority & RendersToBody>;
}
declare type HeadObjectPlain<T extends MergeHead = {}> = Head$1<T & VueUseHeadSchema>;
declare type HeadObject<T extends MergeHead = {}> = ReactiveHead<T & VueUseHeadSchema>;
declare type UseHeadInput<T extends MergeHead = {}> = MaybeComputedRef<HeadObject<T>>;
declare type ResolvedUseHeadInput<T extends MergeHead = {}> = Head$1<T & VueUseHeadSchema>;

interface HeadAttrs {
    [k: string]: any;
}
declare type HookBeforeDomUpdate = (() => Promise<void | boolean> | void | boolean);
declare type HookTagsResolved = ((tags: HeadTag[]) => Promise<void> | void);
declare type HookEntriesResolved = ((entries: HeadEntry[]) => Promise<void> | void);
declare type HeadTagOptions = HeadEntryOptions & HandlesDuplicates & HasRenderPriority & RendersToBody & HasTextContent;
interface HeadEntryOptions {
    safe?: boolean;
    resolved?: boolean;
    beforeTagRender?: (tag: HeadTag) => void;
}
interface HeadEntry<T extends MergeHead = {}> {
    options: HeadEntryOptions;
    tags: HeadTag[];
    input: ResolvedUseHeadInput<T>;
    resolved: boolean;
    id: number;
}
declare type TagKeys = keyof HeadObjectPlain;
interface HeadTag {
    tag: TagKeys;
    props: Record<string, any>;
    children?: string;
    runtime?: {
        position?: number;
        entryId?: number;
        beforeTagRender?: (tag: HeadTag) => void;
    };
    options?: HeadTagOptions;
}
interface HeadObjectApi<T extends MergeHead = {}> {
    update: (resolvedInput: ResolvedUseHeadInput<T>) => void;
    remove: () => void;
}
interface HTMLResult {
    readonly headTags: string;
    readonly htmlAttrs: string;
    readonly bodyAttrs: string;
    readonly bodyTags: string;
}

declare const HeadVuePlugin: Plugin;

declare const Head: vue.DefineComponent<{}, () => null, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, {}, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{}>>, {}>;

declare const createElement: (tag: HeadTag, document: Document) => HTMLElement;

declare const updateElements: (document: Document | undefined, type: string, tags: HeadTag[]) => void;

declare function isEqualNode(oldTag: Element, newTag: Element): boolean;
declare const setAttrs: (el: Element, attrs: HeadAttrs) => void;

declare const propsToString: (props: HeadTag['props']) => string;
declare const tagToString: (tag: HeadTag) => string;
declare const resolveHeadEntries: (entries: HeadEntry[], force?: boolean) => HeadEntry<{}>[];
declare const renderHeadToString: <T extends MergeHead = {}>(head: HeadClient<T>) => Promise<HTMLResult>;

declare const sortTags: (aTag: HeadTag, bTag: HeadTag) => number;
declare const tagDedupeKey: <T extends HeadTag>(tag: T) => string | number;
declare function resolveUnrefHeadInput<T extends MergeHead = {}>(ref: UseHeadInput<T>): ResolvedUseHeadInput<T>;
declare const headInputToTags: (e: HeadEntry) => HeadTag[];
declare const resolveHeadEntriesToTags: (entries: HeadEntry[]) => HeadTag[];

interface HeadClient<T extends MergeHead = {}> {
    install: (app: App) => void;
    headEntries: HeadEntry<T>[];
    addEntry: (entry: UseHeadInput<T>, options?: HeadEntryOptions) => HeadObjectApi<T>;
    addReactiveEntry: (objs: UseHeadInput<T>, options?: HeadEntryOptions) => () => void;
    updateDOM: (document?: Document, force?: boolean) => void;
    hooks: 
    /**
     * Array of user provided functions to hook into before the DOM is updated.
     *
     * When returning false from this function, it will block DOM updates, this can be useful when stopping dom updates
     * between page transitions.
     *
     * You are able to modify the payload of hook using this.
     */
    Record<'before:dom', HookBeforeDomUpdate[]> & Record<'resolved:entries', HookEntriesResolved[]> & 
    /**
       * Array of user provided functions to hook into after the tags have been resolved (deduped and sorted).
       */
    Record<'resolved:tags', HookTagsResolved[]>;
    /**
     * Backwards compatibility function to fetch the headTags.
     *
     * This function forces reactivity resolving and is not performant.
     *
     * @deprecated Use hooks.
     */
    headTags: HeadTag[];
    /**
     * Backwards compatibility function to add a head obj.
     *
     * Note: This will not support reactivity. Use `addReactiveEntry` instead.
     *
     * @deprecated Use addEntry
     */
    addHeadObjs: (entry: UseHeadInput<T>, options?: HeadEntryOptions) => HeadObjectApi<T>;
}
declare const IS_BROWSER: boolean;
/**
 * Inject the head manager instance
 * Exported for advanced usage or library integration, you probably don't need this
 */
declare const injectHead: <T extends MergeHead = {}>() => HeadClient<T>;
declare const createHead: <T extends MergeHead = {}>(initHeadObject?: ResolvedUseHeadInput<T> | undefined) => HeadClient<T>;
declare const useHead: <T extends MergeHead = {}>(headObj: UseHeadInput<T>) => void;
declare const useHeadSafe: <T extends MergeHead = {}>(headObj: UseHeadInput<T>) => void;

export { HTMLResult, HandlesDuplicates, HasRenderPriority, HasTextContent, Head, HeadAttrs, HeadClient, HeadEntry, HeadEntryOptions, HeadObject, HeadObjectApi, HeadObjectPlain, HeadTag, HeadTagOptions, HeadVuePlugin, HookBeforeDomUpdate, HookEntriesResolved, HookTagsResolved, IS_BROWSER, Never, RendersToBody, ResolvedUseHeadInput, TagKeys, UseHeadInput, VueUseHeadSchema, createElement, createHead, headInputToTags, injectHead, isEqualNode, propsToString, renderHeadToString, resolveHeadEntries, resolveHeadEntriesToTags, resolveUnrefHeadInput, setAttrs, sortTags, tagDedupeKey, tagToString, updateElements, useHead, useHeadSafe };
