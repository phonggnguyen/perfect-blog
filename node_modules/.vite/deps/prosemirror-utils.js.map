{
  "version": 3,
  "sources": ["../../orderedmap/dist/index.cjs", "../../prosemirror-model/dist/index.cjs", "../../prosemirror-transform/dist/index.cjs", "../../prosemirror-state/dist/index.cjs", "../../w3c-keyname/index.cjs", "../../prosemirror-keymap/dist/index.cjs", "../../prosemirror-view/dist/index.cjs", "../../prosemirror-tables/src/tablemap.js", "../../prosemirror-tables/src/schema.js", "../../prosemirror-tables/src/util.js", "../../prosemirror-tables/src/cellselection.js", "../../prosemirror-tables/src/copypaste.js", "../../prosemirror-tables/src/input.js", "../../prosemirror-tables/src/fixtables.js", "../../prosemirror-tables/src/commands.js", "../../prosemirror-tables/src/tableview.js", "../../prosemirror-tables/src/columnresizing.js", "../../prosemirror-tables/src/index.js", "../../prosemirror-utils/src/transforms.js", "../../prosemirror-utils/src/helpers.js", "../../prosemirror-utils/src/selection.js", "../../prosemirror-utils/src/node.js", "../../prosemirror-utils/src/table.js", "dep:prosemirror-utils"],
  "sourcesContent": ["'use strict';\n\n// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) \u2192 ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) \u2192 OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) \u2192 OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) \u2192 OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) \u2192 OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) \u2192 OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) \u2192 OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) \u2192 OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) \u2192 OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: () \u2192 Object\n  // Turn ordered map into a plain object.\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) { result[key] = value; });\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) \u2192 OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nmodule.exports = OrderedMap;\n", "'use strict';\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar OrderedMap = require('orderedmap');\n\nfunction _interopDefaultLegacy(e) {\n  return e && _typeof(e) === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar OrderedMap__default = _interopDefaultLegacy(OrderedMap);\n\nfunction _findDiffStart(a, b, pos) {\n  for (var i = 0;; i++) {\n    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;\n    var childA = a.child(i),\n        childB = b.child(i);\n\n    if (childA == childB) {\n      pos += childA.nodeSize;\n      continue;\n    }\n\n    if (!childA.sameMarkup(childB)) return pos;\n\n    if (childA.isText && childA.text != childB.text) {\n      for (var j = 0; childA.text[j] == childB.text[j]; j++) {\n        pos++;\n      }\n\n      return pos;\n    }\n\n    if (childA.content.size || childB.content.size) {\n      var inner = _findDiffStart(childA.content, childB.content, pos + 1);\n\n      if (inner != null) return inner;\n    }\n\n    pos += childA.nodeSize;\n  }\n}\n\nfunction _findDiffEnd(a, b, posA, posB) {\n  for (var iA = a.childCount, iB = b.childCount;;) {\n    if (iA == 0 || iB == 0) return iA == iB ? null : {\n      a: posA,\n      b: posB\n    };\n    var childA = a.child(--iA),\n        childB = b.child(--iB),\n        size = childA.nodeSize;\n\n    if (childA == childB) {\n      posA -= size;\n      posB -= size;\n      continue;\n    }\n\n    if (!childA.sameMarkup(childB)) return {\n      a: posA,\n      b: posB\n    };\n\n    if (childA.isText && childA.text != childB.text) {\n      var same = 0,\n          minSize = Math.min(childA.text.length, childB.text.length);\n\n      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n        same++;\n        posA--;\n        posB--;\n      }\n\n      return {\n        a: posA,\n        b: posB\n      };\n    }\n\n    if (childA.content.size || childB.content.size) {\n      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n\n      if (inner) return inner;\n    }\n\n    posA -= size;\n    posB -= size;\n  }\n}\n\nvar Fragment = function () {\n  function Fragment(content, size) {\n    _classCallCheck(this, Fragment);\n\n    this.content = content;\n    this.size = size || 0;\n    if (size == null) for (var i = 0; i < content.length; i++) {\n      this.size += content[i].nodeSize;\n    }\n  }\n\n  _createClass(Fragment, [{\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var parent = arguments.length > 4 ? arguments[4] : undefined;\n\n      for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n            end = pos + child.nodeSize;\n\n        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n          var start = pos + 1;\n          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n        }\n\n        pos = end;\n      }\n    }\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.size, f);\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to, blockSeparator, leafText) {\n      var text = \"\",\n          separated = true;\n      this.nodesBetween(from, to, function (node, pos) {\n        if (node.isText) {\n          text += node.text.slice(Math.max(from, pos) - pos, to - pos);\n          separated = !blockSeparator;\n        } else if (node.isLeaf) {\n          if (leafText) {\n            text += typeof leafText === \"function\" ? leafText(node) : leafText;\n          } else if (node.type.spec.leafText) {\n            text += node.type.spec.leafText(node);\n          }\n\n          separated = !blockSeparator;\n        } else if (!separated && node.isBlock) {\n          text += blockSeparator;\n          separated = true;\n        }\n      }, 0);\n      return text;\n    }\n  }, {\n    key: \"append\",\n    value: function append(other) {\n      if (!other.size) return this;\n      if (!this.size) return other;\n      var last = this.lastChild,\n          first = other.firstChild,\n          content = this.content.slice(),\n          i = 0;\n\n      if (last.isText && last.sameMarkup(first)) {\n        content[content.length - 1] = last.withText(last.text + first.text);\n        i = 1;\n      }\n\n      for (; i < other.content.length; i++) {\n        content.push(other.content[i]);\n      }\n\n      return new Fragment(content, this.size + other.size);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      if (from == 0 && to == this.size) return this;\n      var result = [],\n          size = 0;\n      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {\n        var child = this.content[i],\n            end = pos + child.nodeSize;\n\n        if (end > from) {\n          if (pos < from || end > to) {\n            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n          }\n\n          result.push(child);\n          size += child.nodeSize;\n        }\n\n        pos = end;\n      }\n      return new Fragment(result, size);\n    }\n  }, {\n    key: \"cutByIndex\",\n    value: function cutByIndex(from, to) {\n      if (from == to) return Fragment.empty;\n      if (from == 0 && to == this.content.length) return this;\n      return new Fragment(this.content.slice(from, to));\n    }\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(index, node) {\n      var current = this.content[index];\n      if (current == node) return this;\n      var copy = this.content.slice();\n      var size = this.size + node.nodeSize - current.nodeSize;\n      copy[index] = node;\n      return new Fragment(copy, size);\n    }\n  }, {\n    key: \"addToStart\",\n    value: function addToStart(node) {\n      return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n  }, {\n    key: \"addToEnd\",\n    value: function addToEnd(node) {\n      return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (this.content.length != other.content.length) return false;\n\n      for (var i = 0; i < this.content.length; i++) {\n        if (!this.content[i].eq(other.content[i])) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.length ? this.content[0] : null;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.length;\n    }\n  }, {\n    key: \"child\",\n    value: function child(index) {\n      var found = this.content[index];\n      if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n      return found;\n    }\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content[index] || null;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      for (var i = 0, p = 0; i < this.content.length; i++) {\n        var child = this.content[i];\n        f(child, p, i);\n        p += child.nodeSize;\n      }\n    }\n  }, {\n    key: \"findDiffStart\",\n    value: function findDiffStart(other) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return _findDiffStart(this, other, pos);\n    }\n  }, {\n    key: \"findDiffEnd\",\n    value: function findDiffEnd(other) {\n      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;\n      return _findDiffEnd(this, other, pos, otherPos);\n    }\n  }, {\n    key: \"findIndex\",\n    value: function findIndex(pos) {\n      var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      if (pos == 0) return retIndex(0, pos);\n      if (pos == this.size) return retIndex(this.content.length, pos);\n      if (pos > this.size || pos < 0) throw new RangeError(\"Position \".concat(pos, \" outside of fragment (\").concat(this, \")\"));\n\n      for (var i = 0, curPos = 0;; i++) {\n        var cur = this.child(i),\n            end = curPos + cur.nodeSize;\n\n        if (end >= pos) {\n          if (end == pos || round > 0) return retIndex(i + 1, end);\n          return retIndex(i, curPos);\n        }\n\n        curPos = end;\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"<\" + this.toStringInner() + \">\";\n    }\n  }, {\n    key: \"toStringInner\",\n    value: function toStringInner() {\n      return this.content.join(\", \");\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.content.length ? this.content.map(function (n) {\n        return n.toJSON();\n      }) : null;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, value) {\n      if (!value) return Fragment.empty;\n      if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n      return new Fragment(value.map(schema.nodeFromJSON));\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      if (!array.length) return Fragment.empty;\n      var joined,\n          size = 0;\n\n      for (var i = 0; i < array.length; i++) {\n        var node = array[i];\n        size += node.nodeSize;\n\n        if (i && node.isText && array[i - 1].sameMarkup(node)) {\n          if (!joined) joined = array.slice(0, i);\n          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n        } else if (joined) {\n          joined.push(node);\n        }\n      }\n\n      return new Fragment(joined || array, size);\n    }\n  }, {\n    key: \"from\",\n    value: function from(nodes) {\n      if (!nodes) return Fragment.empty;\n      if (nodes instanceof Fragment) return nodes;\n      if (Array.isArray(nodes)) return this.fromArray(nodes);\n      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);\n      throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n  }]);\n\n  return Fragment;\n}();\n\nFragment.empty = new Fragment([], 0);\nvar found = {\n  index: 0,\n  offset: 0\n};\n\nfunction retIndex(index, offset) {\n  found.index = index;\n  found.offset = offset;\n  return found;\n}\n\nfunction compareDeep(a, b) {\n  if (a === b) return true;\n  if (!(a && _typeof(a) == \"object\") || !(b && _typeof(b) == \"object\")) return false;\n  var array = Array.isArray(a);\n  if (Array.isArray(b) != array) return false;\n\n  if (array) {\n    if (a.length != b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (!compareDeep(a[i], b[i])) return false;\n    }\n  } else {\n    for (var p in a) {\n      if (!(p in b) || !compareDeep(a[p], b[p])) return false;\n    }\n\n    for (var _p in b) {\n      if (!(_p in a)) return false;\n    }\n  }\n\n  return true;\n}\n\nvar Mark = function () {\n  function Mark(type, attrs) {\n    _classCallCheck(this, Mark);\n\n    this.type = type;\n    this.attrs = attrs;\n  }\n\n  _createClass(Mark, [{\n    key: \"addToSet\",\n    value: function addToSet(set) {\n      var copy,\n          placed = false;\n\n      for (var i = 0; i < set.length; i++) {\n        var other = set[i];\n        if (this.eq(other)) return set;\n\n        if (this.type.excludes(other.type)) {\n          if (!copy) copy = set.slice(0, i);\n        } else if (other.type.excludes(this.type)) {\n          return set;\n        } else {\n          if (!placed && other.type.rank > this.type.rank) {\n            if (!copy) copy = set.slice(0, i);\n            copy.push(this);\n            placed = true;\n          }\n\n          if (copy) copy.push(other);\n        }\n      }\n\n      if (!copy) copy = set.slice();\n      if (!placed) copy.push(this);\n      return copy;\n    }\n  }, {\n    key: \"removeFromSet\",\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));\n      }\n\n      return set;\n    }\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        if (this.eq(set[i])) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = {\n        type: this.type.name\n      };\n\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n\n      return obj;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\");\n      var type = schema.marks[json.type];\n      if (!type) throw new RangeError(\"There is no mark type \".concat(json.type, \" in this schema\"));\n      return type.create(json.attrs);\n    }\n  }, {\n    key: \"sameSet\",\n    value: function sameSet(a, b) {\n      if (a == b) return true;\n      if (a.length != b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        if (!a[i].eq(b[i])) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"setFrom\",\n    value: function setFrom(marks) {\n      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;\n      if (marks instanceof Mark) return [marks];\n      var copy = marks.slice();\n      copy.sort(function (a, b) {\n        return a.type.rank - b.type.rank;\n      });\n      return copy;\n    }\n  }]);\n\n  return Mark;\n}();\n\nMark.none = [];\n\nvar ReplaceError = function (_Error) {\n  _inherits(ReplaceError, _Error);\n\n  var _super = _createSuper(ReplaceError);\n\n  function ReplaceError() {\n    _classCallCheck(this, ReplaceError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return _createClass(ReplaceError);\n}(_wrapNativeSuper(Error));\n\nvar Slice = function () {\n  function Slice(content, openStart, openEnd) {\n    _classCallCheck(this, Slice);\n\n    this.content = content;\n    this.openStart = openStart;\n    this.openEnd = openEnd;\n  }\n\n  _createClass(Slice, [{\n    key: \"size\",\n    get: function get() {\n      return this.content.size - this.openStart - this.openEnd;\n    }\n  }, {\n    key: \"insertAt\",\n    value: function insertAt(pos, fragment) {\n      var content = insertInto(this.content, pos + this.openStart, fragment);\n      return content && new Slice(content, this.openStart, this.openEnd);\n    }\n  }, {\n    key: \"removeBetween\",\n    value: function removeBetween(from, to) {\n      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      if (!this.content.size) return null;\n      var json = {\n        content: this.content.toJSON()\n      };\n      if (this.openStart > 0) json.openStart = this.openStart;\n      if (this.openEnd > 0) json.openEnd = this.openEnd;\n      return json;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) return Slice.empty;\n      var openStart = json.openStart || 0,\n          openEnd = json.openEnd || 0;\n      if (typeof openStart != \"number\" || typeof openEnd != \"number\") throw new RangeError(\"Invalid input for Slice.fromJSON\");\n      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n  }, {\n    key: \"maxOpen\",\n    value: function maxOpen(fragment) {\n      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var openStart = 0,\n          openEnd = 0;\n\n      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {\n        openStart++;\n      }\n\n      for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) {\n        openEnd++;\n      }\n\n      return new Slice(fragment, openStart, openEnd);\n    }\n  }]);\n\n  return Slice;\n}();\n\nSlice.empty = new Slice(Fragment.empty, 0, 0);\n\nfunction removeRange(content, from, to) {\n  var _content$findIndex = content.findIndex(from),\n      index = _content$findIndex.index,\n      offset = _content$findIndex.offset,\n      child = content.maybeChild(index);\n\n  var _content$findIndex2 = content.findIndex(to),\n      indexTo = _content$findIndex2.index,\n      offsetTo = _content$findIndex2.offset;\n\n  if (offset == from || child.isText) {\n    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\");\n    return content.cut(0, from).append(content.cut(to));\n  }\n\n  if (index != indexTo) throw new RangeError(\"Removing non-flat range\");\n  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\n\nfunction insertInto(content, dist, insert, parent) {\n  var _content$findIndex3 = content.findIndex(dist),\n      index = _content$findIndex3.index,\n      offset = _content$findIndex3.offset,\n      child = content.maybeChild(index);\n\n  if (offset == dist || child.isText) {\n    if (parent && !parent.canReplace(index, index, insert)) return null;\n    return content.cut(0, dist).append(insert).append(content.cut(dist));\n  }\n\n  var inner = insertInto(child.content, dist - offset - 1, insert);\n  return inner && content.replaceChild(index, child.copy(inner));\n}\n\nfunction _replace($from, $to, slice) {\n  if (slice.openStart > $from.depth) throw new ReplaceError(\"Inserted content deeper than insertion position\");\n  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError(\"Inconsistent open depths\");\n  return replaceOuter($from, $to, slice, 0);\n}\n\nfunction replaceOuter($from, $to, slice, depth) {\n  var index = $from.index(depth),\n      node = $from.node(depth);\n\n  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n    var inner = replaceOuter($from, $to, slice, depth + 1);\n    return node.copy(node.content.replaceChild(index, inner));\n  } else if (!slice.content.size) {\n    return close(node, replaceTwoWay($from, $to, depth));\n  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n    var parent = $from.parent,\n        content = parent.content;\n    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n  } else {\n    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from),\n        start = _prepareSliceForRepla.start,\n        end = _prepareSliceForRepla.end;\n\n    return close(node, replaceThreeWay($from, start, end, $to, depth));\n  }\n}\n\nfunction checkJoin(main, sub) {\n  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\n\nfunction joinable($before, $after, depth) {\n  var node = $before.node(depth);\n  checkJoin(node, $after.node(depth));\n  return node;\n}\n\nfunction addNode(child, target) {\n  var last = target.length - 1;\n  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);\n}\n\nfunction addRange($start, $end, depth, target) {\n  var node = ($end || $start).node(depth);\n  var startIndex = 0,\n      endIndex = $end ? $end.index(depth) : node.childCount;\n\n  if ($start) {\n    startIndex = $start.index(depth);\n\n    if ($start.depth > depth) {\n      startIndex++;\n    } else if ($start.textOffset) {\n      addNode($start.nodeAfter, target);\n      startIndex++;\n    }\n  }\n\n  for (var i = startIndex; i < endIndex; i++) {\n    addNode(node.child(i), target);\n  }\n\n  if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);\n}\n\nfunction close(node, content) {\n  if (!node.type.validContent(content)) throw new ReplaceError(\"Invalid content for node \" + node.type.name);\n  return node.copy(content);\n}\n\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n  var content = [];\n  addRange(null, $from, depth, content);\n\n  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n    checkJoin(openStart, openEnd);\n    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n  } else {\n    if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n    addRange($start, $end, depth, content);\n    if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n  }\n\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\n\nfunction replaceTwoWay($from, $to, depth) {\n  var content = [];\n  addRange(null, $from, depth, content);\n\n  if ($from.depth > depth) {\n    var type = joinable($from, $to, depth + 1);\n    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n  }\n\n  addRange($to, null, depth, content);\n  return new Fragment(content);\n}\n\nfunction prepareSliceForReplace(slice, $along) {\n  var extra = $along.depth - slice.openStart,\n      parent = $along.node(extra);\n  var node = parent.copy(slice.content);\n\n  for (var i = extra - 1; i >= 0; i--) {\n    node = $along.node(i).copy(Fragment.from(node));\n  }\n\n  return {\n    start: node.resolveNoCache(slice.openStart + extra),\n    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n  };\n}\n\nvar ResolvedPos = function () {\n  function ResolvedPos(pos, path, parentOffset) {\n    _classCallCheck(this, ResolvedPos);\n\n    this.pos = pos;\n    this.path = path;\n    this.parentOffset = parentOffset;\n    this.depth = path.length / 3 - 1;\n  }\n\n  _createClass(ResolvedPos, [{\n    key: \"resolveDepth\",\n    value: function resolveDepth(val) {\n      if (val == null) return this.depth;\n      if (val < 0) return this.depth + val;\n      return val;\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.node(this.depth);\n    }\n  }, {\n    key: \"doc\",\n    get: function get() {\n      return this.node(0);\n    }\n  }, {\n    key: \"node\",\n    value: function node(depth) {\n      return this.path[this.resolveDepth(depth) * 3];\n    }\n  }, {\n    key: \"index\",\n    value: function index(depth) {\n      return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n  }, {\n    key: \"indexAfter\",\n    value: function indexAfter(depth) {\n      depth = this.resolveDepth(depth);\n      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n  }, {\n    key: \"start\",\n    value: function start(depth) {\n      depth = this.resolveDepth(depth);\n      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n  }, {\n    key: \"end\",\n    value: function end(depth) {\n      depth = this.resolveDepth(depth);\n      return this.start(depth) + this.node(depth).content.size;\n    }\n  }, {\n    key: \"before\",\n    value: function before(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position before the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n  }, {\n    key: \"after\",\n    value: function after(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth) throw new RangeError(\"There is no position after the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n  }, {\n    key: \"textOffset\",\n    get: function get() {\n      return this.pos - this.path[this.path.length - 1];\n    }\n  }, {\n    key: \"nodeAfter\",\n    get: function get() {\n      var parent = this.parent,\n          index = this.index(this.depth);\n      if (index == parent.childCount) return null;\n      var dOff = this.pos - this.path[this.path.length - 1],\n          child = parent.child(index);\n      return dOff ? parent.child(index).cut(dOff) : child;\n    }\n  }, {\n    key: \"nodeBefore\",\n    get: function get() {\n      var index = this.index(this.depth);\n      var dOff = this.pos - this.path[this.path.length - 1];\n      if (dOff) return this.parent.child(index).cut(0, dOff);\n      return index == 0 ? null : this.parent.child(index - 1);\n    }\n  }, {\n    key: \"posAtIndex\",\n    value: function posAtIndex(index, depth) {\n      depth = this.resolveDepth(depth);\n      var node = this.path[depth * 3],\n          pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n\n      for (var i = 0; i < index; i++) {\n        pos += node.child(i).nodeSize;\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"marks\",\n    value: function marks() {\n      var parent = this.parent,\n          index = this.index();\n      if (parent.content.size == 0) return Mark.none;\n      if (this.textOffset) return parent.child(index).marks;\n      var main = parent.maybeChild(index - 1),\n          other = parent.maybeChild(index);\n\n      if (!main) {\n        var tmp = main;\n        main = other;\n        other = tmp;\n      }\n\n      var marks = main.marks;\n\n      for (var i = 0; i < marks.length; i++) {\n        if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);\n      }\n\n      return marks;\n    }\n  }, {\n    key: \"marksAcross\",\n    value: function marksAcross($end) {\n      var after = this.parent.maybeChild(this.index());\n      if (!after || !after.isInline) return null;\n      var marks = after.marks,\n          next = $end.parent.maybeChild($end.index());\n\n      for (var i = 0; i < marks.length; i++) {\n        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);\n      }\n\n      return marks;\n    }\n  }, {\n    key: \"sharedDepth\",\n    value: function sharedDepth(pos) {\n      for (var depth = this.depth; depth > 0; depth--) {\n        if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"blockRange\",\n    value: function blockRange() {\n      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n      var pred = arguments.length > 1 ? arguments[1] : undefined;\n      if (other.pos < this.pos) return other.blockRange(this);\n\n      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {\n        if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"sameParent\",\n    value: function sameParent(other) {\n      return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n  }, {\n    key: \"max\",\n    value: function max(other) {\n      return other.pos > this.pos ? other : this;\n    }\n  }, {\n    key: \"min\",\n    value: function min(other) {\n      return other.pos < this.pos ? other : this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var str = \"\";\n\n      for (var i = 1; i <= this.depth; i++) {\n        str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n      }\n\n      return str + \":\" + this.parentOffset;\n    }\n  }], [{\n    key: \"resolve\",\n    value: function resolve(doc, pos) {\n      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\");\n      var path = [];\n      var start = 0,\n          parentOffset = pos;\n\n      for (var node = doc;;) {\n        var _node$content$findInd = node.content.findIndex(parentOffset),\n            index = _node$content$findInd.index,\n            offset = _node$content$findInd.offset;\n\n        var rem = parentOffset - offset;\n        path.push(node, index, start + offset);\n        if (!rem) break;\n        node = node.child(index);\n        if (node.isText) break;\n        parentOffset = rem - 1;\n        start += offset + 1;\n      }\n\n      return new ResolvedPos(pos, path, parentOffset);\n    }\n  }, {\n    key: \"resolveCached\",\n    value: function resolveCached(doc, pos) {\n      for (var i = 0; i < resolveCache.length; i++) {\n        var cached = resolveCache[i];\n        if (cached.pos == pos && cached.doc == doc) return cached;\n      }\n\n      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);\n      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;\n      return result;\n    }\n  }]);\n\n  return ResolvedPos;\n}();\n\nvar resolveCache = [],\n    resolveCachePos = 0,\n    resolveCacheSize = 12;\n\nvar NodeRange = function () {\n  function NodeRange($from, $to, depth) {\n    _classCallCheck(this, NodeRange);\n\n    this.$from = $from;\n    this.$to = $to;\n    this.depth = depth;\n  }\n\n  _createClass(NodeRange, [{\n    key: \"start\",\n    get: function get() {\n      return this.$from.before(this.depth + 1);\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      return this.$to.after(this.depth + 1);\n    }\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.$from.node(this.depth);\n    }\n  }, {\n    key: \"startIndex\",\n    get: function get() {\n      return this.$from.index(this.depth);\n    }\n  }, {\n    key: \"endIndex\",\n    get: function get() {\n      return this.$to.indexAfter(this.depth);\n    }\n  }]);\n\n  return NodeRange;\n}();\n\nvar emptyAttrs = Object.create(null);\n\nvar Node = function () {\n  function Node(type, attrs, content) {\n    var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark.none;\n\n    _classCallCheck(this, Node);\n\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.content = content || Fragment.empty;\n  }\n\n  _createClass(Node, [{\n    key: \"nodeSize\",\n    get: function get() {\n      return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n  }, {\n    key: \"childCount\",\n    get: function get() {\n      return this.content.childCount;\n    }\n  }, {\n    key: \"child\",\n    value: function child(index) {\n      return this.content.child(index);\n    }\n  }, {\n    key: \"maybeChild\",\n    value: function maybeChild(index) {\n      return this.content.maybeChild(index);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      this.content.forEach(f);\n    }\n  }, {\n    key: \"nodesBetween\",\n    value: function nodesBetween(from, to, f) {\n      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      this.content.nodesBetween(from, to, f, startPos, this);\n    }\n  }, {\n    key: \"descendants\",\n    value: function descendants(f) {\n      this.nodesBetween(0, this.content.size, f);\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to, blockSeparator, leafText) {\n      return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.content.firstChild;\n    }\n  }, {\n    key: \"lastChild\",\n    get: function get() {\n      return this.content.lastChild;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n  }, {\n    key: \"sameMarkup\",\n    value: function sameMarkup(other) {\n      return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n  }, {\n    key: \"hasMarkup\",\n    value: function hasMarkup(type, attrs, marks) {\n      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (content == this.content) return this;\n      return new Node(this.type, this.attrs, content, this.marks);\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;\n      if (from == 0 && to == this.content.size) return this;\n      return this.copy(this.content.cut(from, to));\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;\n      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (from == to) return Slice.empty;\n      var $from = this.resolve(from),\n          $to = this.resolve(to);\n      var depth = includeParents ? 0 : $from.sharedDepth(to);\n      var start = $from.start(depth),\n          node = $from.node(depth);\n      var content = node.content.cut($from.pos - start, $to.pos - start);\n      return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from, to, slice) {\n      return _replace(this.resolve(from), this.resolve(to), slice);\n    }\n  }, {\n    key: \"nodeAt\",\n    value: function nodeAt(pos) {\n      for (var node = this;;) {\n        var _node$content$findInd2 = node.content.findIndex(pos),\n            index = _node$content$findInd2.index,\n            offset = _node$content$findInd2.offset;\n\n        node = node.maybeChild(index);\n        if (!node) return null;\n        if (offset == pos || node.isText) return node;\n        pos -= offset + 1;\n      }\n    }\n  }, {\n    key: \"childAfter\",\n    value: function childAfter(pos) {\n      var _this$content$findInd = this.content.findIndex(pos),\n          index = _this$content$findInd.index,\n          offset = _this$content$findInd.offset;\n\n      return {\n        node: this.content.maybeChild(index),\n        index: index,\n        offset: offset\n      };\n    }\n  }, {\n    key: \"childBefore\",\n    value: function childBefore(pos) {\n      if (pos == 0) return {\n        node: null,\n        index: 0,\n        offset: 0\n      };\n\n      var _this$content$findInd2 = this.content.findIndex(pos),\n          index = _this$content$findInd2.index,\n          offset = _this$content$findInd2.offset;\n\n      if (offset < pos) return {\n        node: this.content.child(index),\n        index: index,\n        offset: offset\n      };\n      var node = this.content.child(index - 1);\n      return {\n        node: node,\n        index: index - 1,\n        offset: offset - node.nodeSize\n      };\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(pos) {\n      return ResolvedPos.resolveCached(this, pos);\n    }\n  }, {\n    key: \"resolveNoCache\",\n    value: function resolveNoCache(pos) {\n      return ResolvedPos.resolve(this, pos);\n    }\n  }, {\n    key: \"rangeHasMark\",\n    value: function rangeHasMark(from, to, type) {\n      var found = false;\n      if (to > from) this.nodesBetween(from, to, function (node) {\n        if (type.isInSet(node.marks)) found = true;\n        return !found;\n      });\n      return found;\n    }\n  }, {\n    key: \"isBlock\",\n    get: function get() {\n      return this.type.isBlock;\n    }\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.type.isTextblock;\n    }\n  }, {\n    key: \"inlineContent\",\n    get: function get() {\n      return this.type.inlineContent;\n    }\n  }, {\n    key: \"isInline\",\n    get: function get() {\n      return this.type.isInline;\n    }\n  }, {\n    key: \"isText\",\n    get: function get() {\n      return this.type.isText;\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.type.isLeaf;\n    }\n  }, {\n    key: \"isAtom\",\n    get: function get() {\n      return this.type.isAtom;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n      var name = this.type.name;\n      if (this.content.size) name += \"(\" + this.content.toStringInner() + \")\";\n      return wrapMarks(this.marks, name);\n    }\n  }, {\n    key: \"contentMatchAt\",\n    value: function contentMatchAt(index) {\n      var match = this.type.contentMatch.matchFragment(this.content, 0, index);\n      if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\");\n      return match;\n    }\n  }, {\n    key: \"canReplace\",\n    value: function canReplace(from, to) {\n      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;\n      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;\n      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n      var two = one && one.matchFragment(this.content, to);\n      if (!two || !two.validEnd) return false;\n\n      for (var i = start; i < end; i++) {\n        if (!this.type.allowsMarks(replacement.child(i).marks)) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"canReplaceWith\",\n    value: function canReplaceWith(from, to, type, marks) {\n      if (marks && !this.type.allowsMarks(marks)) return false;\n      var start = this.contentMatchAt(from).matchType(type);\n      var end = start && start.matchFragment(this.content, to);\n      return end ? end.validEnd : false;\n    }\n  }, {\n    key: \"canAppend\",\n    value: function canAppend(other) {\n      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      if (!this.type.validContent(this.content)) throw new RangeError(\"Invalid content for node \".concat(this.type.name, \": \").concat(this.content.toString().slice(0, 50)));\n      var copy = Mark.none;\n\n      for (var i = 0; i < this.marks.length; i++) {\n        copy = this.marks[i].addToSet(copy);\n      }\n\n      if (!Mark.sameSet(copy, this.marks)) throw new RangeError(\"Invalid collection of marks for node \".concat(this.type.name, \": \").concat(this.marks.map(function (m) {\n        return m.type.name;\n      })));\n      this.content.forEach(function (node) {\n        return node.check();\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var obj = {\n        type: this.type.name\n      };\n\n      for (var _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n\n      if (this.content.size) obj.content = this.content.toJSON();\n      if (this.marks.length) obj.marks = this.marks.map(function (n) {\n        return n.toJSON();\n      });\n      return obj;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\");\n      var marks = null;\n\n      if (json.marks) {\n        if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n        marks = json.marks.map(schema.markFromJSON);\n      }\n\n      if (json.type == \"text\") {\n        if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\");\n        return schema.text(json.text, marks);\n      }\n\n      var content = Fragment.fromJSON(schema, json.content);\n      return schema.nodeType(json.type).create(json.attrs, content, marks);\n    }\n  }]);\n\n  return Node;\n}();\n\nNode.prototype.text = undefined;\n\nvar TextNode = function (_Node) {\n  _inherits(TextNode, _Node);\n\n  var _super2 = _createSuper(TextNode);\n\n  function TextNode(type, attrs, content, marks) {\n    var _this;\n\n    _classCallCheck(this, TextNode);\n\n    _this = _super2.call(this, type, attrs, null, marks);\n    if (!content) throw new RangeError(\"Empty text nodes are not allowed\");\n    _this.text = content;\n    return _this;\n  }\n\n  _createClass(TextNode, [{\n    key: \"toString\",\n    value: function toString() {\n      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n      return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      return this.text;\n    }\n  }, {\n    key: \"textBetween\",\n    value: function textBetween(from, to) {\n      return this.text.slice(from, to);\n    }\n  }, {\n    key: \"nodeSize\",\n    get: function get() {\n      return this.text.length;\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(marks) {\n      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n  }, {\n    key: \"withText\",\n    value: function withText(text) {\n      if (text == this.text) return this;\n      return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n  }, {\n    key: \"cut\",\n    value: function cut() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;\n      if (from == 0 && to == this.text.length) return this;\n      return this.withText(this.text.slice(from, to));\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this.sameMarkup(other) && this.text == other.text;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var base = _get(_getPrototypeOf(TextNode.prototype), \"toJSON\", this).call(this);\n\n      base.text = this.text;\n      return base;\n    }\n  }]);\n\n  return TextNode;\n}(Node);\n\nfunction wrapMarks(marks, str) {\n  for (var i = marks.length - 1; i >= 0; i--) {\n    str = marks[i].type.name + \"(\" + str + \")\";\n  }\n\n  return str;\n}\n\nvar ContentMatch = function () {\n  function ContentMatch(validEnd) {\n    _classCallCheck(this, ContentMatch);\n\n    this.validEnd = validEnd;\n    this.next = [];\n    this.wrapCache = [];\n  }\n\n  _createClass(ContentMatch, [{\n    key: \"matchType\",\n    value: function matchType(type) {\n      for (var i = 0; i < this.next.length; i++) {\n        if (this.next[i].type == type) return this.next[i].next;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"matchFragment\",\n    value: function matchFragment(frag) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;\n      var cur = this;\n\n      for (var i = start; cur && i < end; i++) {\n        cur = cur.matchType(frag.child(i).type);\n      }\n\n      return cur;\n    }\n  }, {\n    key: \"inlineContent\",\n    get: function get() {\n      return this.next.length && this.next[0].type.isInline;\n    }\n  }, {\n    key: \"defaultType\",\n    get: function get() {\n      for (var i = 0; i < this.next.length; i++) {\n        var type = this.next[i].type;\n        if (!(type.isText || type.hasRequiredAttrs())) return type;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"compatible\",\n    value: function compatible(other) {\n      for (var i = 0; i < this.next.length; i++) {\n        for (var j = 0; j < other.next.length; j++) {\n          if (this.next[i].type == other.next[j].type) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"fillBefore\",\n    value: function fillBefore(after) {\n      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var seen = [this];\n\n      function search(match, types) {\n        var finished = match.matchFragment(after, startIndex);\n        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {\n          return tp.createAndFill();\n        }));\n\n        for (var i = 0; i < match.next.length; i++) {\n          var _match$next$i = match.next[i],\n              type = _match$next$i.type,\n              next = _match$next$i.next;\n\n          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n            seen.push(next);\n\n            var _found = search(next, types.concat(type));\n\n            if (_found) return _found;\n          }\n        }\n\n        return null;\n      }\n\n      return search(this, []);\n    }\n  }, {\n    key: \"findWrapping\",\n    value: function findWrapping(target) {\n      for (var i = 0; i < this.wrapCache.length; i += 2) {\n        if (this.wrapCache[i] == target) return this.wrapCache[i + 1];\n      }\n\n      var computed = this.computeWrapping(target);\n      this.wrapCache.push(target, computed);\n      return computed;\n    }\n  }, {\n    key: \"computeWrapping\",\n    value: function computeWrapping(target) {\n      var seen = Object.create(null),\n          active = [{\n        match: this,\n        type: null,\n        via: null\n      }];\n\n      while (active.length) {\n        var current = active.shift(),\n            match = current.match;\n\n        if (match.matchType(target)) {\n          var result = [];\n\n          for (var obj = current; obj.type; obj = obj.via) {\n            result.push(obj.type);\n          }\n\n          return result.reverse();\n        }\n\n        for (var i = 0; i < match.next.length; i++) {\n          var _match$next$i2 = match.next[i],\n              type = _match$next$i2.type,\n              next = _match$next$i2.next;\n\n          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n            active.push({\n              match: type.contentMatch,\n              type: type,\n              via: current\n            });\n            seen[type.name] = true;\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"edgeCount\",\n    get: function get() {\n      return this.next.length;\n    }\n  }, {\n    key: \"edge\",\n    value: function edge(n) {\n      if (n >= this.next.length) throw new RangeError(\"There's no \".concat(n, \"th edge in this content match\"));\n      return this.next[n];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var seen = [];\n\n      function scan(m) {\n        seen.push(m);\n\n        for (var i = 0; i < m.next.length; i++) {\n          if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);\n        }\n      }\n\n      scan(this);\n      return seen.map(function (m, i) {\n        var out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n\n        for (var _i = 0; _i < m.next.length; _i++) {\n          out += (_i ? \", \" : \"\") + m.next[_i].type.name + \"->\" + seen.indexOf(m.next[_i].next);\n        }\n\n        return out;\n      }).join(\"\\n\");\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(string, nodeTypes) {\n      var stream = new TokenStream(string, nodeTypes);\n      if (stream.next == null) return ContentMatch.empty;\n      var expr = parseExpr(stream);\n      if (stream.next) stream.err(\"Unexpected trailing text\");\n      var match = dfa(nfa(expr));\n      checkForDeadEnds(match, stream);\n      return match;\n    }\n  }]);\n\n  return ContentMatch;\n}();\n\nContentMatch.empty = new ContentMatch(true);\n\nvar TokenStream = function () {\n  function TokenStream(string, nodeTypes) {\n    _classCallCheck(this, TokenStream);\n\n    this.string = string;\n    this.nodeTypes = nodeTypes;\n    this.inline = null;\n    this.pos = 0;\n    this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n    if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop();\n    if (this.tokens[0] == \"\") this.tokens.shift();\n  }\n\n  _createClass(TokenStream, [{\n    key: \"next\",\n    get: function get() {\n      return this.tokens[this.pos];\n    }\n  }, {\n    key: \"eat\",\n    value: function eat(tok) {\n      return this.next == tok && (this.pos++ || true);\n    }\n  }, {\n    key: \"err\",\n    value: function err(str) {\n      throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n  }]);\n\n  return TokenStream;\n}();\n\nfunction parseExpr(stream) {\n  var exprs = [];\n\n  do {\n    exprs.push(parseExprSeq(stream));\n  } while (stream.eat(\"|\"));\n\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"choice\",\n    exprs: exprs\n  };\n}\n\nfunction parseExprSeq(stream) {\n  var exprs = [];\n\n  do {\n    exprs.push(parseExprSubscript(stream));\n  } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n\n  return exprs.length == 1 ? exprs[0] : {\n    type: \"seq\",\n    exprs: exprs\n  };\n}\n\nfunction parseExprSubscript(stream) {\n  var expr = parseExprAtom(stream);\n\n  for (;;) {\n    if (stream.eat(\"+\")) expr = {\n      type: \"plus\",\n      expr: expr\n    };else if (stream.eat(\"*\")) expr = {\n      type: \"star\",\n      expr: expr\n    };else if (stream.eat(\"?\")) expr = {\n      type: \"opt\",\n      expr: expr\n    };else if (stream.eat(\"{\")) expr = parseExprRange(stream, expr);else break;\n  }\n\n  return expr;\n}\n\nfunction parseNum(stream) {\n  if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\");\n  var result = Number(stream.next);\n  stream.pos++;\n  return result;\n}\n\nfunction parseExprRange(stream, expr) {\n  var min = parseNum(stream),\n      max = min;\n\n  if (stream.eat(\",\")) {\n    if (stream.next != \"}\") max = parseNum(stream);else max = -1;\n  }\n\n  if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\");\n  return {\n    type: \"range\",\n    min: min,\n    max: max,\n    expr: expr\n  };\n}\n\nfunction resolveName(stream, name) {\n  var types = stream.nodeTypes,\n      type = types[name];\n  if (type) return [type];\n  var result = [];\n\n  for (var typeName in types) {\n    var _type = types[typeName];\n    if (_type.groups.indexOf(name) > -1) result.push(_type);\n  }\n\n  if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\");\n  return result;\n}\n\nfunction parseExprAtom(stream) {\n  if (stream.eat(\"(\")) {\n    var expr = parseExpr(stream);\n    if (!stream.eat(\")\")) stream.err(\"Missing closing paren\");\n    return expr;\n  } else if (!/\\W/.test(stream.next)) {\n    var exprs = resolveName(stream, stream.next).map(function (type) {\n      if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\");\n      return {\n        type: \"name\",\n        value: type\n      };\n    });\n    stream.pos++;\n    return exprs.length == 1 ? exprs[0] : {\n      type: \"choice\",\n      exprs: exprs\n    };\n  } else {\n    stream.err(\"Unexpected token '\" + stream.next + \"'\");\n  }\n}\n\nfunction nfa(expr) {\n  var nfa = [[]];\n  connect(compile(expr, 0), node());\n  return nfa;\n\n  function node() {\n    return nfa.push([]) - 1;\n  }\n\n  function edge(from, to, term) {\n    var edge = {\n      term: term,\n      to: to\n    };\n    nfa[from].push(edge);\n    return edge;\n  }\n\n  function connect(edges, to) {\n    edges.forEach(function (edge) {\n      return edge.to = to;\n    });\n  }\n\n  function compile(expr, from) {\n    if (expr.type == \"choice\") {\n      return expr.exprs.reduce(function (out, expr) {\n        return out.concat(compile(expr, from));\n      }, []);\n    } else if (expr.type == \"seq\") {\n      for (var i = 0;; i++) {\n        var next = compile(expr.exprs[i], from);\n        if (i == expr.exprs.length - 1) return next;\n        connect(next, from = node());\n      }\n    } else if (expr.type == \"star\") {\n      var loop = node();\n      edge(from, loop);\n      connect(compile(expr.expr, loop), loop);\n      return [edge(loop)];\n    } else if (expr.type == \"plus\") {\n      var _loop = node();\n\n      connect(compile(expr.expr, from), _loop);\n      connect(compile(expr.expr, _loop), _loop);\n      return [edge(_loop)];\n    } else if (expr.type == \"opt\") {\n      return [edge(from)].concat(compile(expr.expr, from));\n    } else if (expr.type == \"range\") {\n      var cur = from;\n\n      for (var _i2 = 0; _i2 < expr.min; _i2++) {\n        var _next = node();\n\n        connect(compile(expr.expr, cur), _next);\n        cur = _next;\n      }\n\n      if (expr.max == -1) {\n        connect(compile(expr.expr, cur), cur);\n      } else {\n        for (var _i3 = expr.min; _i3 < expr.max; _i3++) {\n          var _next2 = node();\n\n          edge(cur, _next2);\n          connect(compile(expr.expr, cur), _next2);\n          cur = _next2;\n        }\n      }\n\n      return [edge(cur)];\n    } else if (expr.type == \"name\") {\n      return [edge(from, undefined, expr.value)];\n    } else {\n      throw new Error(\"Unknown expr type\");\n    }\n  }\n}\n\nfunction cmp(a, b) {\n  return b - a;\n}\n\nfunction nullFrom(nfa, node) {\n  var result = [];\n  scan(node);\n  return result.sort(cmp);\n\n  function scan(node) {\n    var edges = nfa[node];\n    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);\n    result.push(node);\n\n    for (var i = 0; i < edges.length; i++) {\n      var _edges$i = edges[i],\n          term = _edges$i.term,\n          to = _edges$i.to;\n      if (!term && result.indexOf(to) == -1) scan(to);\n    }\n  }\n}\n\nfunction dfa(nfa) {\n  var labeled = Object.create(null);\n  return explore(nullFrom(nfa, 0));\n\n  function explore(states) {\n    var out = [];\n    states.forEach(function (node) {\n      nfa[node].forEach(function (_ref) {\n        var term = _ref.term,\n            to = _ref.to;\n        if (!term) return;\n        var set;\n\n        for (var i = 0; i < out.length; i++) {\n          if (out[i][0] == term) set = out[i][1];\n        }\n\n        nullFrom(nfa, to).forEach(function (node) {\n          if (!set) out.push([term, set = []]);\n          if (set.indexOf(node) == -1) set.push(node);\n        });\n      });\n    });\n    var state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n\n    for (var i = 0; i < out.length; i++) {\n      var _states = out[i][1].sort(cmp);\n\n      state.next.push({\n        type: out[i][0],\n        next: labeled[_states.join(\",\")] || explore(_states)\n      });\n    }\n\n    return state;\n  }\n}\n\nfunction checkForDeadEnds(match, stream) {\n  for (var i = 0, work = [match]; i < work.length; i++) {\n    var state = work[i],\n        dead = !state.validEnd,\n        nodes = [];\n\n    for (var j = 0; j < state.next.length; j++) {\n      var _state$next$j = state.next[j],\n          type = _state$next$j.type,\n          next = _state$next$j.next;\n      nodes.push(type.name);\n      if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;\n      if (work.indexOf(next) == -1) work.push(next);\n    }\n\n    if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n  }\n}\n\nfunction defaultAttrs(attrs) {\n  var defaults = Object.create(null);\n\n  for (var attrName in attrs) {\n    var attr = attrs[attrName];\n    if (!attr.hasDefault) return null;\n    defaults[attrName] = attr[\"default\"];\n  }\n\n  return defaults;\n}\n\nfunction _computeAttrs(attrs, value) {\n  var built = Object.create(null);\n\n  for (var name in attrs) {\n    var given = value && value[name];\n\n    if (given === undefined) {\n      var attr = attrs[name];\n      if (attr.hasDefault) given = attr[\"default\"];else throw new RangeError(\"No value supplied for attribute \" + name);\n    }\n\n    built[name] = given;\n  }\n\n  return built;\n}\n\nfunction initAttrs(attrs) {\n  var result = Object.create(null);\n  if (attrs) for (var name in attrs) {\n    result[name] = new Attribute(attrs[name]);\n  }\n  return result;\n}\n\nvar NodeType = function () {\n  function NodeType(name, schema, spec) {\n    _classCallCheck(this, NodeType);\n\n    this.name = name;\n    this.schema = schema;\n    this.spec = spec;\n    this.markSet = null;\n    this.groups = spec.group ? spec.group.split(\" \") : [];\n    this.attrs = initAttrs(spec.attrs);\n    this.defaultAttrs = defaultAttrs(this.attrs);\n    this.contentMatch = null;\n    this.inlineContent = null;\n    this.isBlock = !(spec.inline || name == \"text\");\n    this.isText = name == \"text\";\n  }\n\n  _createClass(NodeType, [{\n    key: \"isInline\",\n    get: function get() {\n      return !this.isBlock;\n    }\n  }, {\n    key: \"isTextblock\",\n    get: function get() {\n      return this.isBlock && this.inlineContent;\n    }\n  }, {\n    key: \"isLeaf\",\n    get: function get() {\n      return this.contentMatch == ContentMatch.empty;\n    }\n  }, {\n    key: \"isAtom\",\n    get: function get() {\n      return this.isLeaf || !!this.spec.atom;\n    }\n  }, {\n    key: \"whitespace\",\n    get: function get() {\n      return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n  }, {\n    key: \"hasRequiredAttrs\",\n    value: function hasRequiredAttrs() {\n      for (var n in this.attrs) {\n        if (this.attrs[n].isRequired) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"compatibleContent\",\n    value: function compatibleContent(other) {\n      return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n  }, {\n    key: \"computeAttrs\",\n    value: function computeAttrs(attrs) {\n      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);\n    }\n  }, {\n    key: \"create\",\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\");\n      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n  }, {\n    key: \"createChecked\",\n    value: function createChecked() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      content = Fragment.from(content);\n      if (!this.validContent(content)) throw new RangeError(\"Invalid content for node \" + this.name);\n      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n  }, {\n    key: \"createAndFill\",\n    value: function createAndFill() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var content = arguments.length > 1 ? arguments[1] : undefined;\n      var marks = arguments.length > 2 ? arguments[2] : undefined;\n      attrs = this.computeAttrs(attrs);\n      content = Fragment.from(content);\n\n      if (content.size) {\n        var before = this.contentMatch.fillBefore(content);\n        if (!before) return null;\n        content = before.append(content);\n      }\n\n      var matched = this.contentMatch.matchFragment(content);\n      var after = matched && matched.fillBefore(Fragment.empty, true);\n      if (!after) return null;\n      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n  }, {\n    key: \"validContent\",\n    value: function validContent(content) {\n      var result = this.contentMatch.matchFragment(content);\n      if (!result || !result.validEnd) return false;\n\n      for (var i = 0; i < content.childCount; i++) {\n        if (!this.allowsMarks(content.child(i).marks)) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"allowsMarkType\",\n    value: function allowsMarkType(markType) {\n      return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n  }, {\n    key: \"allowsMarks\",\n    value: function allowsMarks(marks) {\n      if (this.markSet == null) return true;\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!this.allowsMarkType(marks[i].type)) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"allowedMarks\",\n    value: function allowedMarks(marks) {\n      if (this.markSet == null) return marks;\n      var copy;\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!this.allowsMarkType(marks[i].type)) {\n          if (!copy) copy = marks.slice(0, i);\n        } else if (copy) {\n          copy.push(marks[i]);\n        }\n      }\n\n      return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(nodes, schema) {\n      var result = Object.create(null);\n      nodes.forEach(function (name, spec) {\n        return result[name] = new NodeType(name, schema, spec);\n      });\n      var topType = schema.spec.topNode || \"doc\";\n      if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n      if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\");\n\n      for (var _ in result.text.attrs) {\n        throw new RangeError(\"The text node type should not have attributes\");\n      }\n\n      return result;\n    }\n  }]);\n\n  return NodeType;\n}();\n\nvar Attribute = function () {\n  function Attribute(options) {\n    _classCallCheck(this, Attribute);\n\n    this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n    this[\"default\"] = options[\"default\"];\n  }\n\n  _createClass(Attribute, [{\n    key: \"isRequired\",\n    get: function get() {\n      return !this.hasDefault;\n    }\n  }]);\n\n  return Attribute;\n}();\n\nvar MarkType = function () {\n  function MarkType(name, rank, schema, spec) {\n    _classCallCheck(this, MarkType);\n\n    this.name = name;\n    this.rank = rank;\n    this.schema = schema;\n    this.spec = spec;\n    this.attrs = initAttrs(spec.attrs);\n    this.excluded = null;\n    var defaults = defaultAttrs(this.attrs);\n    this.instance = defaults ? new Mark(this, defaults) : null;\n  }\n\n  _createClass(MarkType, [{\n    key: \"create\",\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (!attrs && this.instance) return this.instance;\n      return new Mark(this, _computeAttrs(this.attrs, attrs));\n    }\n  }, {\n    key: \"removeFromSet\",\n    value: function removeFromSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        if (set[i].type == this) {\n          set = set.slice(0, i).concat(set.slice(i + 1));\n          i--;\n        }\n      }\n\n      return set;\n    }\n  }, {\n    key: \"isInSet\",\n    value: function isInSet(set) {\n      for (var i = 0; i < set.length; i++) {\n        if (set[i].type == this) return set[i];\n      }\n    }\n  }, {\n    key: \"excludes\",\n    value: function excludes(other) {\n      return this.excluded.indexOf(other) > -1;\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(marks, schema) {\n      var result = Object.create(null),\n          rank = 0;\n      marks.forEach(function (name, spec) {\n        return result[name] = new MarkType(name, rank++, schema, spec);\n      });\n      return result;\n    }\n  }]);\n\n  return MarkType;\n}();\n\nvar Schema = function () {\n  function Schema(spec) {\n    _classCallCheck(this, Schema);\n\n    this.cached = Object.create(null);\n    this.spec = {\n      nodes: OrderedMap__default[\"default\"].from(spec.nodes),\n      marks: OrderedMap__default[\"default\"].from(spec.marks || {}),\n      topNode: spec.topNode\n    };\n    this.nodes = NodeType.compile(this.spec.nodes, this);\n    this.marks = MarkType.compile(this.spec.marks, this);\n    var contentExprCache = Object.create(null);\n\n    for (var prop in this.nodes) {\n      if (prop in this.marks) throw new RangeError(prop + \" can not be both a node and a mark\");\n      var type = this.nodes[prop],\n          contentExpr = type.spec.content || \"\",\n          markExpr = type.spec.marks;\n      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n      type.inlineContent = type.contentMatch.inlineContent;\n      type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n    }\n\n    for (var _prop in this.marks) {\n      var _type2 = this.marks[_prop],\n          excl = _type2.spec.excludes;\n      _type2.excluded = excl == null ? [_type2] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n    }\n\n    this.nodeFromJSON = this.nodeFromJSON.bind(this);\n    this.markFromJSON = this.markFromJSON.bind(this);\n    this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n    this.cached.wrappings = Object.create(null);\n  }\n\n  _createClass(Schema, [{\n    key: \"node\",\n    value: function node(type) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var content = arguments.length > 2 ? arguments[2] : undefined;\n      var marks = arguments.length > 3 ? arguments[3] : undefined;\n      if (typeof type == \"string\") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError(\"Invalid node type: \" + type);else if (type.schema != this) throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n      return type.createChecked(attrs, content, marks);\n    }\n  }, {\n    key: \"text\",\n    value: function text(_text, marks) {\n      var type = this.nodes.text;\n      return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));\n    }\n  }, {\n    key: \"mark\",\n    value: function mark(type, attrs) {\n      if (typeof type == \"string\") type = this.marks[type];\n      return type.create(attrs);\n    }\n  }, {\n    key: \"nodeFromJSON\",\n    value: function nodeFromJSON(json) {\n      return Node.fromJSON(this, json);\n    }\n  }, {\n    key: \"markFromJSON\",\n    value: function markFromJSON(json) {\n      return Mark.fromJSON(this, json);\n    }\n  }, {\n    key: \"nodeType\",\n    value: function nodeType(name) {\n      var found = this.nodes[name];\n      if (!found) throw new RangeError(\"Unknown node type: \" + name);\n      return found;\n    }\n  }]);\n\n  return Schema;\n}();\n\nfunction gatherMarks(schema, marks) {\n  var found = [];\n\n  for (var i = 0; i < marks.length; i++) {\n    var name = marks[i],\n        mark = schema.marks[name],\n        ok = mark;\n\n    if (mark) {\n      found.push(mark);\n    } else {\n      for (var prop in schema.marks) {\n        var _mark = schema.marks[prop];\n        if (name == \"_\" || _mark.spec.group && _mark.spec.group.split(\" \").indexOf(name) > -1) found.push(ok = _mark);\n      }\n    }\n\n    if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n  }\n\n  return found;\n}\n\nvar DOMParser = function () {\n  function DOMParser(schema, rules) {\n    var _this2 = this;\n\n    _classCallCheck(this, DOMParser);\n\n    this.schema = schema;\n    this.rules = rules;\n    this.tags = [];\n    this.styles = [];\n    rules.forEach(function (rule) {\n      if (rule.tag) _this2.tags.push(rule);else if (rule.style) _this2.styles.push(rule);\n    });\n    this.normalizeLists = !this.tags.some(function (r) {\n      if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false;\n      var node = schema.nodes[r.node];\n      return node.contentMatch.matchType(node);\n    });\n  }\n\n  _createClass(DOMParser, [{\n    key: \"parse\",\n    value: function parse(dom) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = new ParseContext(this, options, false);\n      context.addAll(dom, options.from, options.to);\n      return context.finish();\n    }\n  }, {\n    key: \"parseSlice\",\n    value: function parseSlice(dom) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var context = new ParseContext(this, options, true);\n      context.addAll(dom, options.from, options.to);\n      return Slice.maxOpen(context.finish());\n    }\n  }, {\n    key: \"matchTag\",\n    value: function matchTag(dom, context, after) {\n      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n        var rule = this.tags[i];\n\n        if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n          if (rule.getAttrs) {\n            var result = rule.getAttrs(dom);\n            if (result === false) continue;\n            rule.attrs = result || undefined;\n          }\n\n          return rule;\n        }\n      }\n    }\n  }, {\n    key: \"matchStyle\",\n    value: function matchStyle(prop, value, context, after) {\n      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n        var rule = this.styles[i],\n            style = rule.style;\n        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;\n\n        if (rule.getAttrs) {\n          var result = rule.getAttrs(value);\n          if (result === false) continue;\n          rule.attrs = result || undefined;\n        }\n\n        return rule;\n      }\n    }\n  }], [{\n    key: \"schemaRules\",\n    value: function schemaRules(schema) {\n      var result = [];\n\n      function insert(rule) {\n        var priority = rule.priority == null ? 50 : rule.priority,\n            i = 0;\n\n        for (; i < result.length; i++) {\n          var next = result[i],\n              nextPriority = next.priority == null ? 50 : next.priority;\n          if (nextPriority < priority) break;\n        }\n\n        result.splice(i, 0, rule);\n      }\n\n      var _loop2 = function _loop2(name) {\n        var rules = schema.marks[name].spec.parseDOM;\n        if (rules) rules.forEach(function (rule) {\n          insert(rule = copy(rule));\n          rule.mark = name;\n        });\n      };\n\n      for (var name in schema.marks) {\n        _loop2(name);\n      }\n\n      var _loop3 = function _loop3(_name) {\n        var rules = schema.nodes[_name].spec.parseDOM;\n        if (rules) rules.forEach(function (rule) {\n          insert(rule = copy(rule));\n          rule.node = _name;\n        });\n      };\n\n      for (var _name in schema.nodes) {\n        _loop3(_name);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"fromSchema\",\n    value: function fromSchema(schema) {\n      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n  }]);\n\n  return DOMParser;\n}();\n\nvar blockTags = {\n  address: true,\n  article: true,\n  aside: true,\n  blockquote: true,\n  canvas: true,\n  dd: true,\n  div: true,\n  dl: true,\n  fieldset: true,\n  figcaption: true,\n  figure: true,\n  footer: true,\n  form: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  header: true,\n  hgroup: true,\n  hr: true,\n  li: true,\n  noscript: true,\n  ol: true,\n  output: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tfoot: true,\n  ul: true\n};\nvar ignoreTags = {\n  head: true,\n  noscript: true,\n  object: true,\n  script: true,\n  style: true,\n  title: true\n};\nvar listTags = {\n  ol: true,\n  ul: true\n};\nvar OPT_PRESERVE_WS = 1,\n    OPT_PRESERVE_WS_FULL = 2,\n    OPT_OPEN_LEFT = 4;\n\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n  return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\n\nvar NodeContext = function () {\n  function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {\n    _classCallCheck(this, NodeContext);\n\n    this.type = type;\n    this.attrs = attrs;\n    this.marks = marks;\n    this.pendingMarks = pendingMarks;\n    this.solid = solid;\n    this.options = options;\n    this.content = [];\n    this.activeMarks = Mark.none;\n    this.stashMarks = [];\n    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n  }\n\n  _createClass(NodeContext, [{\n    key: \"findWrapping\",\n    value: function findWrapping(node) {\n      if (!this.match) {\n        if (!this.type) return [];\n        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n\n        if (fill) {\n          this.match = this.type.contentMatch.matchFragment(fill);\n        } else {\n          var start = this.type.contentMatch,\n              wrap;\n\n          if (wrap = start.findWrapping(node.type)) {\n            this.match = start;\n            return wrap;\n          } else {\n            return null;\n          }\n        }\n      }\n\n      return this.match.findWrapping(node.type);\n    }\n  }, {\n    key: \"finish\",\n    value: function finish(openEnd) {\n      if (!(this.options & OPT_PRESERVE_WS)) {\n        var last = this.content[this.content.length - 1],\n            m;\n\n        if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n          var text = last;\n          if (last.text.length == m[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n        }\n      }\n\n      var content = Fragment.from(this.content);\n      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));\n      return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n  }, {\n    key: \"popFromStashMark\",\n    value: function popFromStashMark(mark) {\n      for (var i = this.stashMarks.length - 1; i >= 0; i--) {\n        if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0];\n      }\n    }\n  }, {\n    key: \"applyPending\",\n    value: function applyPending(nextType) {\n      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {\n        var mark = pending[i];\n\n        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {\n          this.activeMarks = mark.addToSet(this.activeMarks);\n          this.pendingMarks = mark.removeFromSet(this.pendingMarks);\n        }\n      }\n    }\n  }, {\n    key: \"inlineContext\",\n    value: function inlineContext(node) {\n      if (this.type) return this.type.inlineContent;\n      if (this.content.length) return this.content[0].isInline;\n      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n  }]);\n\n  return NodeContext;\n}();\n\nvar ParseContext = function () {\n  function ParseContext(parser, options, isOpen) {\n    _classCallCheck(this, ParseContext);\n\n    this.parser = parser;\n    this.options = options;\n    this.isOpen = isOpen;\n    this.open = 0;\n    var topNode = options.topNode,\n        topContext;\n    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n    if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);\n    this.nodes = [topContext];\n    this.find = options.findPositions;\n    this.needsBlock = false;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"top\",\n    get: function get() {\n      return this.nodes[this.open];\n    }\n  }, {\n    key: \"addDOM\",\n    value: function addDOM(dom) {\n      if (dom.nodeType == 3) {\n        this.addTextNode(dom);\n      } else if (dom.nodeType == 1) {\n        var style = dom.getAttribute(\"style\");\n        var marks = style ? this.readStyles(parseStyles(style)) : null,\n            top = this.top;\n        if (marks != null) for (var i = 0; i < marks.length; i++) {\n          this.addPendingMark(marks[i]);\n        }\n        this.addElement(dom);\n        if (marks != null) for (var _i4 = 0; _i4 < marks.length; _i4++) {\n          this.removePendingMark(marks[_i4], top);\n        }\n      }\n    }\n  }, {\n    key: \"addTextNode\",\n    value: function addTextNode(dom) {\n      var value = dom.nodeValue;\n      var top = this.top;\n\n      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n        if (!(top.options & OPT_PRESERVE_WS)) {\n          value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n\n          if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n            var nodeBefore = top.content[top.content.length - 1];\n            var domNodeBefore = dom.previousSibling;\n            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) value = value.slice(1);\n          }\n        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {\n          value = value.replace(/\\r?\\n|\\r/g, \" \");\n        } else {\n          value = value.replace(/\\r\\n?/g, \"\\n\");\n        }\n\n        if (value) this.insertNode(this.parser.schema.text(value));\n        this.findInText(dom);\n      } else {\n        this.findInside(dom);\n      }\n    }\n  }, {\n    key: \"addElement\",\n    value: function addElement(dom, matchAfter) {\n      var name = dom.nodeName.toLowerCase(),\n          ruleID;\n      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);\n      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n\n      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n        this.findInside(dom);\n        this.ignoreFallback(dom);\n      } else if (!rule || rule.skip || rule.closeParent) {\n        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;\n        var sync,\n            top = this.top,\n            oldNeedsBlock = this.needsBlock;\n\n        if (blockTags.hasOwnProperty(name)) {\n          sync = true;\n          if (!top.type) this.needsBlock = true;\n        } else if (!dom.firstChild) {\n          this.leafFallback(dom);\n          return;\n        }\n\n        this.addAll(dom);\n        if (sync) this.sync(top);\n        this.needsBlock = oldNeedsBlock;\n      } else {\n        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);\n      }\n    }\n  }, {\n    key: \"leafFallback\",\n    value: function leafFallback(dom) {\n      if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"));\n    }\n  }, {\n    key: \"ignoreFallback\",\n    value: function ignoreFallback(dom) {\n      if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text(\"-\"));\n    }\n  }, {\n    key: \"readStyles\",\n    value: function readStyles(styles) {\n      var marks = Mark.none;\n\n      style: for (var i = 0; i < styles.length; i += 2) {\n        for (var after = undefined;;) {\n          var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);\n          if (!rule) continue style;\n          if (rule.ignore) return null;\n          marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);\n          if (rule.consuming === false) after = rule;else break;\n        }\n      }\n\n      return marks;\n    }\n  }, {\n    key: \"addElementByRule\",\n    value: function addElementByRule(dom, rule, continueAfter) {\n      var _this3 = this;\n\n      var sync, nodeType, mark;\n\n      if (rule.node) {\n        nodeType = this.parser.schema.nodes[rule.node];\n\n        if (!nodeType.isLeaf) {\n          sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);\n        } else if (!this.insertNode(nodeType.create(rule.attrs))) {\n          this.leafFallback(dom);\n        }\n      } else {\n        var markType = this.parser.schema.marks[rule.mark];\n        mark = markType.create(rule.attrs);\n        this.addPendingMark(mark);\n      }\n\n      var startIn = this.top;\n\n      if (nodeType && nodeType.isLeaf) {\n        this.findInside(dom);\n      } else if (continueAfter) {\n        this.addElement(dom, continueAfter);\n      } else if (rule.getContent) {\n        this.findInside(dom);\n        rule.getContent(dom, this.parser.schema).forEach(function (node) {\n          return _this3.insertNode(node);\n        });\n      } else {\n        var contentDOM = dom;\n        if (typeof rule.contentElement == \"string\") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == \"function\") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;\n        this.findAround(dom, contentDOM, true);\n        this.addAll(contentDOM);\n      }\n\n      if (sync && this.sync(startIn)) this.open--;\n      if (mark) this.removePendingMark(mark, startIn);\n    }\n  }, {\n    key: \"addAll\",\n    value: function addAll(parent, startIndex, endIndex) {\n      var index = startIndex || 0;\n\n      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n        this.findAtPoint(parent, index);\n        this.addDOM(dom);\n      }\n\n      this.findAtPoint(parent, index);\n    }\n  }, {\n    key: \"findPlace\",\n    value: function findPlace(node) {\n      var route, sync;\n\n      for (var depth = this.open; depth >= 0; depth--) {\n        var cx = this.nodes[depth];\n\n        var _found2 = cx.findWrapping(node);\n\n        if (_found2 && (!route || route.length > _found2.length)) {\n          route = _found2;\n          sync = cx;\n          if (!_found2.length) break;\n        }\n\n        if (cx.solid) break;\n      }\n\n      if (!route) return false;\n      this.sync(sync);\n\n      for (var i = 0; i < route.length; i++) {\n        this.enterInner(route[i], null, false);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"insertNode\",\n    value: function insertNode(node) {\n      if (node.isInline && this.needsBlock && !this.top.type) {\n        var block = this.textblockFromContext();\n        if (block) this.enterInner(block);\n      }\n\n      if (this.findPlace(node)) {\n        this.closeExtra();\n        var top = this.top;\n        top.applyPending(node.type);\n        if (top.match) top.match = top.match.matchType(node.type);\n        var marks = top.activeMarks;\n\n        for (var i = 0; i < node.marks.length; i++) {\n          if (!top.type || top.type.allowsMarkType(node.marks[i].type)) marks = node.marks[i].addToSet(marks);\n        }\n\n        top.content.push(node.mark(marks));\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"enter\",\n    value: function enter(type, attrs, preserveWS) {\n      var ok = this.findPlace(type.create(attrs));\n      if (ok) this.enterInner(type, attrs, true, preserveWS);\n      return ok;\n    }\n  }, {\n    key: \"enterInner\",\n    value: function enterInner(type) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var solid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var preserveWS = arguments.length > 3 ? arguments[3] : undefined;\n      this.closeExtra();\n      var top = this.top;\n      top.applyPending(type);\n      top.match = top.match && top.match.matchType(type);\n      var options = wsOptionsFor(type, preserveWS, top.options);\n      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;\n      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));\n      this.open++;\n    }\n  }, {\n    key: \"closeExtra\",\n    value: function closeExtra() {\n      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var i = this.nodes.length - 1;\n\n      if (i > this.open) {\n        for (; i > this.open; i--) {\n          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n        }\n\n        this.nodes.length = this.open + 1;\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this.open = 0;\n      this.closeExtra(this.isOpen);\n      return this.nodes[0].finish(this.isOpen || this.options.topOpen);\n    }\n  }, {\n    key: \"sync\",\n    value: function sync(to) {\n      for (var i = this.open; i >= 0; i--) {\n        if (this.nodes[i] == to) {\n          this.open = i;\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"currentPos\",\n    get: function get() {\n      this.closeExtra();\n      var pos = 0;\n\n      for (var i = this.open; i >= 0; i--) {\n        var content = this.nodes[i].content;\n\n        for (var j = content.length - 1; j >= 0; j--) {\n          pos += content[j].nodeSize;\n        }\n\n        if (i) pos++;\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"findAtPoint\",\n    value: function findAtPoint(parent, offset) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;\n      }\n    }\n  }, {\n    key: \"findInside\",\n    value: function findInside(parent) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;\n      }\n    }\n  }, {\n    key: \"findAround\",\n    value: function findAround(parent, content, before) {\n      if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n          var pos = content.compareDocumentPosition(this.find[i].node);\n          if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;\n        }\n      }\n    }\n  }, {\n    key: \"findInText\",\n    value: function findInText(textNode) {\n      if (this.find) for (var i = 0; i < this.find.length; i++) {\n        if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n      }\n    }\n  }, {\n    key: \"matchesContext\",\n    value: function matchesContext(context) {\n      var _this4 = this;\n\n      if (context.indexOf(\"|\") > -1) return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n      var parts = context.split(\"/\");\n      var option = this.options.context;\n      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n\n      var match = function match(i, depth) {\n        for (; i >= 0; i--) {\n          var part = parts[i];\n\n          if (part == \"\") {\n            if (i == parts.length - 1 || i == 0) continue;\n\n            for (; depth >= minDepth; depth--) {\n              if (match(i - 1, depth)) return true;\n            }\n\n            return false;\n          } else {\n            var next = depth > 0 || depth == 0 && useRoot ? _this4.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n            if (!next || next.name != part && next.groups.indexOf(part) == -1) return false;\n            depth--;\n          }\n        }\n\n        return true;\n      };\n\n      return match(parts.length - 1, this.open);\n    }\n  }, {\n    key: \"textblockFromContext\",\n    value: function textblockFromContext() {\n      var $context = this.options.context;\n      if ($context) for (var d = $context.depth; d >= 0; d--) {\n        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;\n      }\n\n      for (var name in this.parser.schema.nodes) {\n        var type = this.parser.schema.nodes[name];\n        if (type.isTextblock && type.defaultAttrs) return type;\n      }\n    }\n  }, {\n    key: \"addPendingMark\",\n    value: function addPendingMark(mark) {\n      var found = findSameMarkInSet(mark, this.top.pendingMarks);\n      if (found) this.top.stashMarks.push(found);\n      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);\n    }\n  }, {\n    key: \"removePendingMark\",\n    value: function removePendingMark(mark, upto) {\n      for (var depth = this.open; depth >= 0; depth--) {\n        var level = this.nodes[depth];\n\n        var _found3 = level.pendingMarks.lastIndexOf(mark);\n\n        if (_found3 > -1) {\n          level.pendingMarks = mark.removeFromSet(level.pendingMarks);\n        } else {\n          level.activeMarks = mark.removeFromSet(level.activeMarks);\n          var stashMark = level.popFromStashMark(mark);\n          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) level.activeMarks = stashMark.addToSet(level.activeMarks);\n        }\n\n        if (level == upto) break;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}();\n\nfunction normalizeList(dom) {\n  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n\n    if (name && listTags.hasOwnProperty(name) && prevItem) {\n      prevItem.appendChild(child);\n      child = prevItem;\n    } else if (name == \"li\") {\n      prevItem = child;\n    } else if (name) {\n      prevItem = null;\n    }\n  }\n}\n\nfunction matches(dom, selector) {\n  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\n\nfunction parseStyles(style) {\n  var re = /\\s*([\\w-]+)\\s*:\\s*([^;]+)/g,\n      m,\n      result = [];\n\n  while (m = re.exec(style)) {\n    result.push(m[1], m[2].trim());\n  }\n\n  return result;\n}\n\nfunction copy(obj) {\n  var copy = {};\n\n  for (var prop in obj) {\n    copy[prop] = obj[prop];\n  }\n\n  return copy;\n}\n\nfunction markMayApply(markType, nodeType) {\n  var nodes = nodeType.schema.nodes;\n\n  var _loop4 = function _loop4(name) {\n    var parent = nodes[name];\n    if (!parent.allowsMarkType(markType)) return \"continue\";\n\n    var seen = [],\n        scan = function scan(match) {\n      seen.push(match);\n\n      for (var i = 0; i < match.edgeCount; i++) {\n        var _match$edge = match.edge(i),\n            type = _match$edge.type,\n            next = _match$edge.next;\n\n        if (type == nodeType) return true;\n        if (seen.indexOf(next) < 0 && scan(next)) return true;\n      }\n    };\n\n    if (scan(parent.contentMatch)) return {\n      v: true\n    };\n  };\n\n  for (var name in nodes) {\n    var _ret = _loop4(name);\n\n    if (_ret === \"continue\") continue;\n    if (_typeof(_ret) === \"object\") return _ret.v;\n  }\n}\n\nfunction findSameMarkInSet(mark, set) {\n  for (var i = 0; i < set.length; i++) {\n    if (mark.eq(set[i])) return set[i];\n  }\n}\n\nvar DOMSerializer = function () {\n  function DOMSerializer(nodes, marks) {\n    _classCallCheck(this, DOMSerializer);\n\n    this.nodes = nodes;\n    this.marks = marks;\n  }\n\n  _createClass(DOMSerializer, [{\n    key: \"serializeFragment\",\n    value: function serializeFragment(fragment) {\n      var _this5 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var target = arguments.length > 2 ? arguments[2] : undefined;\n      if (!target) target = doc(options).createDocumentFragment();\n      var top = target,\n          active = [];\n      fragment.forEach(function (node) {\n        if (active.length || node.marks.length) {\n          var keep = 0,\n              rendered = 0;\n\n          while (keep < active.length && rendered < node.marks.length) {\n            var next = node.marks[rendered];\n\n            if (!_this5.marks[next.type.name]) {\n              rendered++;\n              continue;\n            }\n\n            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;\n            keep++;\n            rendered++;\n          }\n\n          while (keep < active.length) {\n            top = active.pop()[1];\n          }\n\n          while (rendered < node.marks.length) {\n            var add = node.marks[rendered++];\n\n            var markDOM = _this5.serializeMark(add, node.isInline, options);\n\n            if (markDOM) {\n              active.push([add, top]);\n              top.appendChild(markDOM.dom);\n              top = markDOM.contentDOM || markDOM.dom;\n            }\n          }\n        }\n\n        top.appendChild(_this5.serializeNodeInner(node, options));\n      });\n      return target;\n    }\n  }, {\n    key: \"serializeNodeInner\",\n    value: function serializeNodeInner(node, options) {\n      var _DOMSerializer$render = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node)),\n          dom = _DOMSerializer$render.dom,\n          contentDOM = _DOMSerializer$render.contentDOM;\n\n      if (contentDOM) {\n        if (node.isLeaf) throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n        this.serializeFragment(node.content, options, contentDOM);\n      }\n\n      return dom;\n    }\n  }, {\n    key: \"serializeNode\",\n    value: function serializeNode(node) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var dom = this.serializeNodeInner(node, options);\n\n      for (var i = node.marks.length - 1; i >= 0; i--) {\n        var wrap = this.serializeMark(node.marks[i], node.isInline, options);\n\n        if (wrap) {\n          (wrap.contentDOM || wrap.dom).appendChild(dom);\n          dom = wrap.dom;\n        }\n      }\n\n      return dom;\n    }\n  }, {\n    key: \"serializeMark\",\n    value: function serializeMark(mark, inline) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var toDOM = this.marks[mark.type.name];\n      return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));\n    }\n  }], [{\n    key: \"renderSpec\",\n    value: function renderSpec(doc, structure) {\n      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (typeof structure == \"string\") return {\n        dom: doc.createTextNode(structure)\n      };\n      if (structure.nodeType != null) return {\n        dom: structure\n      };\n      if (structure.dom && structure.dom.nodeType != null) return structure;\n      var tagName = structure[0],\n          space = tagName.indexOf(\" \");\n\n      if (space > 0) {\n        xmlNS = tagName.slice(0, space);\n        tagName = tagName.slice(space + 1);\n      }\n\n      var contentDOM;\n      var dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n      var attrs = structure[1],\n          start = 1;\n\n      if (attrs && _typeof(attrs) == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n        start = 2;\n\n        for (var name in attrs) {\n          if (attrs[name] != null) {\n            var _space = name.indexOf(\" \");\n\n            if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);else dom.setAttribute(name, attrs[name]);\n          }\n        }\n      }\n\n      for (var i = start; i < structure.length; i++) {\n        var child = structure[i];\n\n        if (child === 0) {\n          if (i < structure.length - 1 || i > start) throw new RangeError(\"Content hole must be the only child of its parent node\");\n          return {\n            dom: dom,\n            contentDOM: dom\n          };\n        } else {\n          var _DOMSerializer$render2 = DOMSerializer.renderSpec(doc, child, xmlNS),\n              inner = _DOMSerializer$render2.dom,\n              innerContent = _DOMSerializer$render2.contentDOM;\n\n          dom.appendChild(inner);\n\n          if (innerContent) {\n            if (contentDOM) throw new RangeError(\"Multiple content holes\");\n            contentDOM = innerContent;\n          }\n        }\n      }\n\n      return {\n        dom: dom,\n        contentDOM: contentDOM\n      };\n    }\n  }, {\n    key: \"fromSchema\",\n    value: function fromSchema(schema) {\n      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n  }, {\n    key: \"nodesFromSchema\",\n    value: function nodesFromSchema(schema) {\n      var result = gatherToDOM(schema.nodes);\n      if (!result.text) result.text = function (node) {\n        return node.text;\n      };\n      return result;\n    }\n  }, {\n    key: \"marksFromSchema\",\n    value: function marksFromSchema(schema) {\n      return gatherToDOM(schema.marks);\n    }\n  }]);\n\n  return DOMSerializer;\n}();\n\nfunction gatherToDOM(obj) {\n  var result = {};\n\n  for (var name in obj) {\n    var toDOM = obj[name].spec.toDOM;\n    if (toDOM) result[name] = toDOM;\n  }\n\n  return result;\n}\n\nfunction doc(options) {\n  return options.document || window.document;\n}\n\nexports.ContentMatch = ContentMatch;\nexports.DOMParser = DOMParser;\nexports.DOMSerializer = DOMSerializer;\nexports.Fragment = Fragment;\nexports.Mark = Mark;\nexports.MarkType = MarkType;\nexports.Node = Node;\nexports.NodeRange = NodeRange;\nexports.NodeType = NodeType;\nexports.ReplaceError = ReplaceError;\nexports.ResolvedPos = ResolvedPos;\nexports.Schema = Schema;\nexports.Slice = Slice;\n", "'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar prosemirrorModel = require('prosemirror-model');\n\nvar lower16 = 0xffff;\nvar factor16 = Math.pow(2, 16);\n\nfunction makeRecover(index, offset) {\n  return index + offset * factor16;\n}\n\nfunction recoverIndex(value) {\n  return value & lower16;\n}\n\nfunction recoverOffset(value) {\n  return (value - (value & lower16)) / factor16;\n}\n\nvar DEL_BEFORE = 1,\n    DEL_AFTER = 2,\n    DEL_ACROSS = 4,\n    DEL_SIDE = 8;\n\nvar MapResult = function () {\n  function MapResult(pos, delInfo, recover) {\n    _classCallCheck(this, MapResult);\n\n    this.pos = pos;\n    this.delInfo = delInfo;\n    this.recover = recover;\n  }\n\n  _createClass(MapResult, [{\n    key: \"deleted\",\n    get: function get() {\n      return (this.delInfo & DEL_SIDE) > 0;\n    }\n  }, {\n    key: \"deletedBefore\",\n    get: function get() {\n      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n    }\n  }, {\n    key: \"deletedAfter\",\n    get: function get() {\n      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n    }\n  }, {\n    key: \"deletedAcross\",\n    get: function get() {\n      return (this.delInfo & DEL_ACROSS) > 0;\n    }\n  }]);\n\n  return MapResult;\n}();\n\nvar StepMap = function () {\n  function StepMap(ranges) {\n    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    _classCallCheck(this, StepMap);\n\n    this.ranges = ranges;\n    this.inverted = inverted;\n    if (!ranges.length && StepMap.empty) return StepMap.empty;\n  }\n\n  _createClass(StepMap, [{\n    key: \"recover\",\n    value: function recover(value) {\n      var diff = 0,\n          index = recoverIndex(value);\n      if (!this.inverted) for (var i = 0; i < index; i++) {\n        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n      }\n      return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, false);\n    }\n  }, {\n    key: \"map\",\n    value: function map(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, true);\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(pos, assoc, simple) {\n      var diff = 0,\n          oldIndex = this.inverted ? 2 : 1,\n          newIndex = this.inverted ? 1 : 2;\n\n      for (var i = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos) break;\n        var oldSize = this.ranges[i + oldIndex],\n            newSize = this.ranges[i + newIndex],\n            end = start + oldSize;\n\n        if (pos <= end) {\n          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n          var result = start + diff + (side < 0 ? 0 : newSize);\n          if (simple) return result;\n          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n          var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n          if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;\n          return new MapResult(result, del, recover);\n        }\n\n        diff += newSize - oldSize;\n      }\n\n      return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n  }, {\n    key: \"touches\",\n    value: function touches(pos, recover) {\n      var diff = 0,\n          index = recoverIndex(recover);\n      var oldIndex = this.inverted ? 2 : 1,\n          newIndex = this.inverted ? 1 : 2;\n\n      for (var i = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos) break;\n        var oldSize = this.ranges[i + oldIndex],\n            end = start + oldSize;\n        if (pos <= end && i == index * 3) return true;\n        diff += this.ranges[i + newIndex] - oldSize;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(f) {\n      var oldIndex = this.inverted ? 2 : 1,\n          newIndex = this.inverted ? 1 : 2;\n\n      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {\n        var start = this.ranges[i],\n            oldStart = start - (this.inverted ? diff : 0),\n            newStart = start + (this.inverted ? 0 : diff);\n        var oldSize = this.ranges[i + oldIndex],\n            newSize = this.ranges[i + newIndex];\n        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n        diff += newSize - oldSize;\n      }\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new StepMap(this.ranges, !this.inverted);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n  }], [{\n    key: \"offset\",\n    value: function offset(n) {\n      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n  }]);\n\n  return StepMap;\n}();\n\nStepMap.empty = new StepMap([]);\n\nvar Mapping = function () {\n  function Mapping() {\n    var maps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var mirror = arguments.length > 1 ? arguments[1] : undefined;\n    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maps.length;\n\n    _classCallCheck(this, Mapping);\n\n    this.maps = maps;\n    this.mirror = mirror;\n    this.from = from;\n    this.to = to;\n  }\n\n  _createClass(Mapping, [{\n    key: \"slice\",\n    value: function slice() {\n      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.maps.length;\n      return new Mapping(this.maps, this.mirror, from, to);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n    }\n  }, {\n    key: \"appendMap\",\n    value: function appendMap(map, mirrors) {\n      this.to = this.maps.push(map);\n      if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);\n    }\n  }, {\n    key: \"appendMapping\",\n    value: function appendMapping(mapping) {\n      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n        var mirr = mapping.getMirror(i);\n        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n      }\n    }\n  }, {\n    key: \"getMirror\",\n    value: function getMirror(n) {\n      if (this.mirror) for (var i = 0; i < this.mirror.length; i++) {\n        if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];\n      }\n    }\n  }, {\n    key: \"setMirror\",\n    value: function setMirror(n, m) {\n      if (!this.mirror) this.mirror = [];\n      this.mirror.push(n, m);\n    }\n  }, {\n    key: \"appendMappingInverted\",\n    value: function appendMappingInverted(mapping) {\n      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n        var mirr = mapping.getMirror(i);\n        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n      }\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      var inverse = new Mapping();\n      inverse.appendMappingInverted(this);\n      return inverse;\n    }\n  }, {\n    key: \"map\",\n    value: function map(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      if (this.mirror) return this._map(pos, assoc, true);\n\n      for (var i = this.from; i < this.to; i++) {\n        pos = this.maps[i].map(pos, assoc);\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"mapResult\",\n    value: function mapResult(pos) {\n      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this._map(pos, assoc, false);\n    }\n  }, {\n    key: \"_map\",\n    value: function _map(pos, assoc, simple) {\n      var delInfo = 0;\n\n      for (var i = this.from; i < this.to; i++) {\n        var map = this.maps[i],\n            result = map.mapResult(pos, assoc);\n\n        if (result.recover != null) {\n          var corr = this.getMirror(i);\n\n          if (corr != null && corr > i && corr < this.to) {\n            i = corr;\n            pos = this.maps[corr].recover(result.recover);\n            continue;\n          }\n        }\n\n        delInfo |= result.delInfo;\n        pos = result.pos;\n      }\n\n      return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n  }]);\n\n  return Mapping;\n}();\n\nvar stepsByID = Object.create(null);\n\nvar Step = function () {\n  function Step() {\n    _classCallCheck(this, Step);\n  }\n\n  _createClass(Step, [{\n    key: \"getMap\",\n    value: function getMap() {\n      return StepMap.empty;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      return null;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\");\n      var type = stepsByID[json.stepType];\n      if (!type) throw new RangeError(\"No step type \".concat(json.stepType, \" defined\"));\n      return type.fromJSON(schema, json);\n    }\n  }, {\n    key: \"jsonID\",\n    value: function jsonID(id, stepClass) {\n      if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n      stepsByID[id] = stepClass;\n      stepClass.prototype.jsonID = id;\n      return stepClass;\n    }\n  }]);\n\n  return Step;\n}();\n\nvar StepResult = function () {\n  function StepResult(doc, failed) {\n    _classCallCheck(this, StepResult);\n\n    this.doc = doc;\n    this.failed = failed;\n  }\n\n  _createClass(StepResult, null, [{\n    key: \"ok\",\n    value: function ok(doc) {\n      return new StepResult(doc, null);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(message) {\n      return new StepResult(null, message);\n    }\n  }, {\n    key: \"fromReplace\",\n    value: function fromReplace(doc, from, to, slice) {\n      try {\n        return StepResult.ok(doc.replace(from, to, slice));\n      } catch (e) {\n        if (e instanceof prosemirrorModel.ReplaceError) return StepResult.fail(e.message);\n        throw e;\n      }\n    }\n  }]);\n\n  return StepResult;\n}();\n\nfunction mapFragment(fragment, f, parent) {\n  var mapped = [];\n\n  for (var i = 0; i < fragment.childCount; i++) {\n    var child = fragment.child(i);\n    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));\n    if (child.isInline) child = f(child, parent, i);\n    mapped.push(child);\n  }\n\n  return prosemirrorModel.Fragment.fromArray(mapped);\n}\n\nvar AddMarkStep = function (_Step) {\n  _inherits(AddMarkStep, _Step);\n\n  var _super = _createSuper(AddMarkStep);\n\n  function AddMarkStep(from, to, mark) {\n    var _this;\n\n    _classCallCheck(this, AddMarkStep);\n\n    _this = _super.call(this);\n    _this.from = from;\n    _this.to = to;\n    _this.mark = mark;\n    return _this;\n  }\n\n  _createClass(AddMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var _this2 = this;\n\n      var oldSlice = doc.slice(this.from, this.to),\n          $from = doc.resolve(this.from);\n      var parent = $from.node($from.sharedDepth(this.to));\n      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node, parent) {\n        if (!node.isAtom || !parent.type.allowsMarkType(_this2.mark.type)) return node;\n        return node.mark(_this2.mark.addToSet(node.marks));\n      }, parent), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n          to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n      return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"addMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n  }]);\n\n  return AddMarkStep;\n}(Step);\n\nStep.jsonID(\"addMark\", AddMarkStep);\n\nvar RemoveMarkStep = function (_Step2) {\n  _inherits(RemoveMarkStep, _Step2);\n\n  var _super2 = _createSuper(RemoveMarkStep);\n\n  function RemoveMarkStep(from, to, mark) {\n    var _this3;\n\n    _classCallCheck(this, RemoveMarkStep);\n\n    _this3 = _super2.call(this);\n    _this3.from = from;\n    _this3.to = to;\n    _this3.mark = mark;\n    return _this3;\n  }\n\n  _createClass(RemoveMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var _this4 = this;\n\n      var oldSlice = doc.slice(this.from, this.to);\n      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node) {\n        return node.mark(_this4.mark.removeFromSet(node.marks));\n      }, doc), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert() {\n      return new AddMarkStep(this.from, this.to, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n          to = mapping.mapResult(this.to, -1);\n      if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n      return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"removeMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n  }]);\n\n  return RemoveMarkStep;\n}(Step);\n\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n\nvar AddNodeMarkStep = function (_Step3) {\n  _inherits(AddNodeMarkStep, _Step3);\n\n  var _super3 = _createSuper(AddNodeMarkStep);\n\n  function AddNodeMarkStep(pos, mark) {\n    var _this5;\n\n    _classCallCheck(this, AddNodeMarkStep);\n\n    _this5 = _super3.call(this);\n    _this5.pos = pos;\n    _this5.mark = mark;\n    return _this5;\n  }\n\n  _createClass(AddNodeMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at mark step's position\");\n      var updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var node = doc.nodeAt(this.pos);\n\n      if (node) {\n        var newSet = this.mark.addToSet(node.marks);\n\n        if (newSet.length == node.marks.length) {\n          for (var i = 0; i < node.marks.length; i++) {\n            if (!node.marks[i].isInSet(newSet)) return new AddNodeMarkStep(this.pos, node.marks[i]);\n          }\n\n          return new AddNodeMarkStep(this.pos, this.mark);\n        }\n      }\n\n      return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"addNodeMark\",\n        pos: this.pos,\n        mark: this.mark.toJSON()\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n      return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n  }]);\n\n  return AddNodeMarkStep;\n}(Step);\n\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n\nvar RemoveNodeMarkStep = function (_Step4) {\n  _inherits(RemoveNodeMarkStep, _Step4);\n\n  var _super4 = _createSuper(RemoveNodeMarkStep);\n\n  function RemoveNodeMarkStep(pos, mark) {\n    var _this6;\n\n    _classCallCheck(this, RemoveNodeMarkStep);\n\n    _this6 = _super4.call(this);\n    _this6.pos = pos;\n    _this6.mark = mark;\n    return _this6;\n  }\n\n  _createClass(RemoveNodeMarkStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at mark step's position\");\n      var updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node || !this.mark.isInSet(node.marks)) return this;\n      return new AddNodeMarkStep(this.pos, this.mark);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"removeNodeMark\",\n        pos: this.pos,\n        mark: this.mark.toJSON()\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n      return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n  }]);\n\n  return RemoveNodeMarkStep;\n}(Step);\n\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n\nvar ReplaceStep = function (_Step5) {\n  _inherits(ReplaceStep, _Step5);\n\n  var _super5 = _createSuper(ReplaceStep);\n\n  function ReplaceStep(from, to, slice) {\n    var _this7;\n\n    var structure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, ReplaceStep);\n\n    _this7 = _super5.call(this);\n    _this7.from = from;\n    _this7.to = to;\n    _this7.slice = slice;\n    _this7.structure = structure;\n    return _this7;\n  }\n\n  _createClass(ReplaceStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail(\"Structure replace would overwrite content\");\n      return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n          to = mapping.mapResult(this.to, -1);\n      if (from.deletedAcross && to.deletedAcross) return null;\n      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;\n\n      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n        var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n        var _slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n\n        return new ReplaceStep(other.from, this.to, _slice, this.structure);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        stepType: \"replace\",\n        from: this.from,\n        to: this.to\n      };\n      if (this.slice.size) json.slice = this.slice.toJSON();\n      if (this.structure) json.structure = true;\n      return json;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n      return new ReplaceStep(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n  }]);\n\n  return ReplaceStep;\n}(Step);\n\nStep.jsonID(\"replace\", ReplaceStep);\n\nvar ReplaceAroundStep = function (_Step6) {\n  _inherits(ReplaceAroundStep, _Step6);\n\n  var _super6 = _createSuper(ReplaceAroundStep);\n\n  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert) {\n    var _this8;\n\n    var structure = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n    _classCallCheck(this, ReplaceAroundStep);\n\n    _this8 = _super6.call(this);\n    _this8.from = from;\n    _this8.to = to;\n    _this8.gapFrom = gapFrom;\n    _this8.gapTo = gapTo;\n    _this8.slice = slice;\n    _this8.insert = insert;\n    _this8.structure = structure;\n    return _this8;\n  }\n\n  _createClass(ReplaceAroundStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail(\"Structure gap-replace would overwrite content\");\n      var gap = doc.slice(this.gapFrom, this.gapTo);\n      if (gap.openStart || gap.openEnd) return StepResult.fail(\"Gap is not a flat range\");\n      var inserted = this.slice.insertAt(this.insert, gap.content);\n      if (!inserted) return StepResult.fail(\"Content does not fit in gap\");\n      return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      var gap = this.gapTo - this.gapFrom;\n      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var from = mapping.mapResult(this.from, 1),\n          to = mapping.mapResult(this.to, -1);\n      var gapFrom = mapping.map(this.gapFrom, -1),\n          gapTo = mapping.map(this.gapTo, 1);\n      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;\n      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var json = {\n        stepType: \"replaceAround\",\n        from: this.from,\n        to: this.to,\n        gapFrom: this.gapFrom,\n        gapTo: this.gapTo,\n        insert: this.insert\n      };\n      if (this.slice.size) json.slice = this.slice.toJSON();\n      if (this.structure) json.structure = true;\n      return json;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\") throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n  }]);\n\n  return ReplaceAroundStep;\n}(Step);\n\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\n\nfunction contentBetween(doc, from, to) {\n  var $from = doc.resolve(from),\n      dist = to - from,\n      depth = $from.depth;\n\n  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n    depth--;\n    dist--;\n  }\n\n  if (dist > 0) {\n    var next = $from.node(depth).maybeChild($from.indexAfter(depth));\n\n    while (dist > 0) {\n      if (!next || next.isLeaf) return true;\n      next = next.firstChild;\n      dist--;\n    }\n  }\n\n  return false;\n}\n\nfunction _addMark(tr, from, to, mark) {\n  var removed = [],\n      added = [];\n  var removing, adding;\n  tr.doc.nodesBetween(from, to, function (node, pos, parent) {\n    if (!node.isInline) return;\n    var marks = node.marks;\n\n    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n      var start = Math.max(pos, from),\n          end = Math.min(pos + node.nodeSize, to);\n      var newSet = mark.addToSet(marks);\n\n      for (var i = 0; i < marks.length; i++) {\n        if (!marks[i].isInSet(newSet)) {\n          if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n        }\n      }\n\n      if (adding && adding.to == start) adding.to = end;else added.push(adding = new AddMarkStep(start, end, mark));\n    }\n  });\n  removed.forEach(function (s) {\n    return tr.step(s);\n  });\n  added.forEach(function (s) {\n    return tr.step(s);\n  });\n}\n\nfunction _removeMark(tr, from, to, mark) {\n  var matched = [],\n      step = 0;\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    if (!node.isInline) return;\n    step++;\n    var toRemove = null;\n\n    if (mark instanceof prosemirrorModel.MarkType) {\n      var set = node.marks,\n          found;\n\n      while (found = mark.isInSet(set)) {\n        (toRemove || (toRemove = [])).push(found);\n        set = found.removeFromSet(set);\n      }\n    } else if (mark) {\n      if (mark.isInSet(node.marks)) toRemove = [mark];\n    } else {\n      toRemove = node.marks;\n    }\n\n    if (toRemove && toRemove.length) {\n      var end = Math.min(pos + node.nodeSize, to);\n\n      for (var i = 0; i < toRemove.length; i++) {\n        var style = toRemove[i],\n            _found = void 0;\n\n        for (var j = 0; j < matched.length; j++) {\n          var m = matched[j];\n          if (m.step == step - 1 && style.eq(matched[j].style)) _found = m;\n        }\n\n        if (_found) {\n          _found.to = end;\n          _found.step = step;\n        } else {\n          matched.push({\n            style: style,\n            from: Math.max(pos, from),\n            to: end,\n            step: step\n          });\n        }\n      }\n    }\n  });\n  matched.forEach(function (m) {\n    return tr.step(new RemoveMarkStep(m.from, m.to, m.style));\n  });\n}\n\nfunction _clearIncompatible(tr, pos, parentType) {\n  var match = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : parentType.contentMatch;\n  var node = tr.doc.nodeAt(pos);\n  var delSteps = [],\n      cur = pos + 1;\n\n  for (var i = 0; i < node.childCount; i++) {\n    var child = node.child(i),\n        end = cur + child.nodeSize;\n    var allowed = match.matchType(child.type);\n\n    if (!allowed) {\n      delSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));\n    } else {\n      match = allowed;\n\n      for (var j = 0; j < child.marks.length; j++) {\n        if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n      }\n    }\n\n    cur = end;\n  }\n\n  if (!match.validEnd) {\n    var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);\n    tr.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));\n  }\n\n  for (var _i = delSteps.length - 1; _i >= 0; _i--) {\n    tr.step(delSteps[_i]);\n  }\n}\n\nfunction canCut(node, start, end) {\n  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n}\n\nfunction liftTarget(range) {\n  var parent = range.parent;\n  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n\n  for (var depth = range.depth;; --depth) {\n    var node = range.$from.node(depth);\n    var index = range.$from.index(depth),\n        endIndex = range.$to.indexAfter(depth);\n    if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;\n    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;\n  }\n\n  return null;\n}\n\nfunction _lift(tr, range, target) {\n  var $from = range.$from,\n      $to = range.$to,\n      depth = range.depth;\n  var gapStart = $from.before(depth + 1),\n      gapEnd = $to.after(depth + 1);\n  var start = gapStart,\n      end = gapEnd;\n  var before = prosemirrorModel.Fragment.empty,\n      openStart = 0;\n\n  for (var d = depth, splitting = false; d > target; d--) {\n    if (splitting || $from.index(d) > 0) {\n      splitting = true;\n      before = prosemirrorModel.Fragment.from($from.node(d).copy(before));\n      openStart++;\n    } else {\n      start--;\n    }\n  }\n\n  var after = prosemirrorModel.Fragment.empty,\n      openEnd = 0;\n\n  for (var _d = depth, _splitting = false; _d > target; _d--) {\n    if (_splitting || $to.after(_d + 1) < $to.end(_d)) {\n      _splitting = true;\n      after = prosemirrorModel.Fragment.from($to.node(_d).copy(after));\n      openEnd++;\n    } else {\n      end++;\n    }\n  }\n\n  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirrorModel.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n\nfunction findWrapping(range, nodeType) {\n  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var innerRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : range;\n  var around = findWrappingOutside(range, nodeType);\n  var inner = around && findWrappingInside(innerRange, nodeType);\n  if (!inner) return null;\n  return around.map(withAttrs).concat({\n    type: nodeType,\n    attrs: attrs\n  }).concat(inner.map(withAttrs));\n}\n\nfunction withAttrs(type) {\n  return {\n    type: type,\n    attrs: null\n  };\n}\n\nfunction findWrappingOutside(range, type) {\n  var parent = range.parent,\n      startIndex = range.startIndex,\n      endIndex = range.endIndex;\n  var around = parent.contentMatchAt(startIndex).findWrapping(type);\n  if (!around) return null;\n  var outer = around.length ? around[0] : type;\n  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\n\nfunction findWrappingInside(range, type) {\n  var parent = range.parent,\n      startIndex = range.startIndex,\n      endIndex = range.endIndex;\n  var inner = parent.child(startIndex);\n  var inside = type.contentMatch.findWrapping(inner.type);\n  if (!inside) return null;\n  var lastType = inside.length ? inside[inside.length - 1] : type;\n  var innerMatch = lastType.contentMatch;\n\n  for (var i = startIndex; innerMatch && i < endIndex; i++) {\n    innerMatch = innerMatch.matchType(parent.child(i).type);\n  }\n\n  if (!innerMatch || !innerMatch.validEnd) return null;\n  return inside;\n}\n\nfunction _wrap2(tr, range, wrappers) {\n  var content = prosemirrorModel.Fragment.empty;\n\n  for (var i = wrappers.length - 1; i >= 0; i--) {\n    if (content.size) {\n      var match = wrappers[i].type.contentMatch.matchFragment(content);\n      if (!match || !match.validEnd) throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n    }\n\n    content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n  }\n\n  var start = range.start,\n      end = range.end;\n  tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));\n}\n\nfunction _setBlockType(tr, from, to, type, attrs) {\n  if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\");\n  var mapFrom = tr.steps.length;\n  tr.doc.nodesBetween(from, to, function (node, pos) {\n    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);\n      var mapping = tr.mapping.slice(mapFrom);\n      var startM = mapping.map(pos, 1),\n          endM = mapping.map(pos + node.nodeSize, 1);\n      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n      return false;\n    }\n  });\n}\n\nfunction canChangeType(doc, pos, type) {\n  var $pos = doc.resolve(pos),\n      index = $pos.index();\n  return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n\nfunction _setNodeMarkup(tr, pos, type, attrs, marks) {\n  var node = tr.doc.nodeAt(pos);\n  if (!node) throw new RangeError(\"No node at given position\");\n  if (!type) type = node.type;\n  var newNode = type.create(attrs, null, marks || node.marks);\n  if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n  if (!type.validContent(node.content)) throw new RangeError(\"Invalid content for node type \" + type.name);\n  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true));\n}\n\nfunction canSplit(doc, pos) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;\n  var $pos = doc.resolve(pos),\n      base = $pos.depth - depth;\n  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;\n\n  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n    var node = $pos.node(d),\n        _index = $pos.index(d);\n\n    if (node.type.spec.isolating) return false;\n    var rest = node.content.cutByIndex(_index, node.childCount);\n    var after = typesAfter && typesAfter[i] || node;\n    if (after != node) rest = rest.replaceChild(0, after.type.create(after.attrs));\n    if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest)) return false;\n  }\n\n  var index = $pos.indexAfter(base);\n  var baseType = typesAfter && typesAfter[0];\n  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\n\nfunction _split(tr, pos) {\n  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;\n  var $pos = tr.doc.resolve(pos),\n      before = prosemirrorModel.Fragment.empty,\n      after = prosemirrorModel.Fragment.empty;\n\n  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n    before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));\n    var typeAfter = typesAfter && typesAfter[i];\n    after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n  }\n\n  tr.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth), true));\n}\n\nfunction canJoin(doc, pos) {\n  var $pos = doc.resolve(pos),\n      index = $pos.index();\n  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\n\nfunction joinable(a, b) {\n  return !!(a && b && !a.isLeaf && a.canAppend(b));\n}\n\nfunction joinPoint(doc, pos) {\n  var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n  var $pos = doc.resolve(pos);\n\n  for (var d = $pos.depth;; d--) {\n    var before = void 0,\n        after = void 0,\n        index = $pos.index(d);\n\n    if (d == $pos.depth) {\n      before = $pos.nodeBefore;\n      after = $pos.nodeAfter;\n    } else if (dir > 0) {\n      before = $pos.node(d + 1);\n      index++;\n      after = $pos.node(d).maybeChild(index);\n    } else {\n      before = $pos.node(d).maybeChild(index - 1);\n      after = $pos.node(d + 1);\n    }\n\n    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;\n    if (d == 0) break;\n    pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n  }\n}\n\nfunction _join(tr, pos, depth) {\n  var step = new ReplaceStep(pos - depth, pos + depth, prosemirrorModel.Slice.empty, true);\n  tr.step(step);\n}\n\nfunction insertPoint(doc, pos, nodeType) {\n  var $pos = doc.resolve(pos);\n  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;\n  if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {\n    var index = $pos.index(d);\n    if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);\n    if (index > 0) return null;\n  }\n  if ($pos.parentOffset == $pos.parent.content.size) for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {\n    var _index2 = $pos.indexAfter(_d2);\n\n    if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType)) return $pos.after(_d2 + 1);\n    if (_index2 < $pos.node(_d2).childCount) return null;\n  }\n  return null;\n}\n\nfunction dropPoint(doc, pos, slice) {\n  var $pos = doc.resolve(pos);\n  if (!slice.content.size) return pos;\n  var content = slice.content;\n\n  for (var i = 0; i < slice.openStart; i++) {\n    content = content.firstChild.content;\n  }\n\n  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n    for (var d = $pos.depth; d >= 0; d--) {\n      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n      var parent = $pos.node(d),\n          fits = false;\n\n      if (pass == 1) {\n        fits = parent.canReplace(insertPos, insertPos, content);\n      } else {\n        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n      }\n\n      if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n    }\n  }\n\n  return null;\n}\n\nfunction replaceStep(doc, from) {\n  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;\n  var slice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prosemirrorModel.Slice.empty;\n  if (from == to && !slice.size) return null;\n  var $from = doc.resolve(from),\n      $to = doc.resolve(to);\n  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);\n  return new Fitter($from, $to, slice).fit();\n}\n\nfunction fitsTrivially($from, $to, slice) {\n  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n\nvar Fitter = function () {\n  function Fitter($from, $to, unplaced) {\n    _classCallCheck(this, Fitter);\n\n    this.$from = $from;\n    this.$to = $to;\n    this.unplaced = unplaced;\n    this.frontier = [];\n    this.placed = prosemirrorModel.Fragment.empty;\n\n    for (var i = 0; i <= $from.depth; i++) {\n      var node = $from.node(i);\n      this.frontier.push({\n        type: node.type,\n        match: node.contentMatchAt($from.indexAfter(i))\n      });\n    }\n\n    for (var _i2 = $from.depth; _i2 > 0; _i2--) {\n      this.placed = prosemirrorModel.Fragment.from($from.node(_i2).copy(this.placed));\n    }\n  }\n\n  _createClass(Fitter, [{\n    key: \"depth\",\n    get: function get() {\n      return this.frontier.length - 1;\n    }\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      while (this.unplaced.size) {\n        var fit = this.findFittable();\n        if (fit) this.placeNodes(fit);else this.openMore() || this.dropNode();\n      }\n\n      var moveInline = this.mustMoveInline(),\n          placedSize = this.placed.size - this.depth - this.$from.depth;\n      var $from = this.$from,\n          $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n      if (!$to) return null;\n      var content = this.placed,\n          openStart = $from.depth,\n          openEnd = $to.depth;\n\n      while (openStart && openEnd && content.childCount == 1) {\n        content = content.firstChild.content;\n        openStart--;\n        openEnd--;\n      }\n\n      var slice = new prosemirrorModel.Slice(content, openStart, openEnd);\n      if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n      if (slice.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice);\n      return null;\n    }\n  }, {\n    key: \"findFittable\",\n    value: function findFittable() {\n      for (var pass = 1; pass <= 2; pass++) {\n        for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n          var fragment = void 0,\n              parent = null;\n\n          if (sliceDepth) {\n            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n            fragment = parent.content;\n          } else {\n            fragment = this.unplaced.content;\n          }\n\n          var first = fragment.firstChild;\n\n          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n            var _this$frontier$fronti = this.frontier[frontierDepth],\n                type = _this$frontier$fronti.type,\n                match = _this$frontier$fronti.match,\n                _wrap = void 0,\n                inject = null;\n\n            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirrorModel.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {\n              sliceDepth: sliceDepth,\n              frontierDepth: frontierDepth,\n              parent: parent,\n              inject: inject\n            };else if (pass == 2 && first && (_wrap = match.findWrapping(first.type))) return {\n              sliceDepth: sliceDepth,\n              frontierDepth: frontierDepth,\n              parent: parent,\n              wrap: _wrap\n            };\n            if (parent && match.matchType(parent.type)) break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"openMore\",\n    value: function openMore() {\n      var _this$unplaced = this.unplaced,\n          content = _this$unplaced.content,\n          openStart = _this$unplaced.openStart,\n          openEnd = _this$unplaced.openEnd;\n      var inner = contentAt(content, openStart);\n      if (!inner.childCount || inner.firstChild.isLeaf) return false;\n      this.unplaced = new prosemirrorModel.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n      return true;\n    }\n  }, {\n    key: \"dropNode\",\n    value: function dropNode() {\n      var _this$unplaced2 = this.unplaced,\n          content = _this$unplaced2.content,\n          openStart = _this$unplaced2.openStart,\n          openEnd = _this$unplaced2.openEnd;\n      var inner = contentAt(content, openStart);\n\n      if (inner.childCount <= 1 && openStart > 0) {\n        var openAtEnd = content.size - openStart <= openStart + inner.size;\n        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n      } else {\n        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n      }\n    }\n  }, {\n    key: \"placeNodes\",\n    value: function placeNodes(_ref) {\n      var sliceDepth = _ref.sliceDepth,\n          frontierDepth = _ref.frontierDepth,\n          parent = _ref.parent,\n          inject = _ref.inject,\n          wrap = _ref.wrap;\n\n      while (this.depth > frontierDepth) {\n        this.closeFrontierNode();\n      }\n\n      if (wrap) for (var i = 0; i < wrap.length; i++) {\n        this.openFrontierNode(wrap[i]);\n      }\n      var slice = this.unplaced,\n          fragment = parent ? parent.content : slice.content;\n      var openStart = slice.openStart - sliceDepth;\n      var taken = 0,\n          add = [];\n      var _this$frontier$fronti2 = this.frontier[frontierDepth],\n          match = _this$frontier$fronti2.match,\n          type = _this$frontier$fronti2.type;\n\n      if (inject) {\n        for (var i = 0; i < inject.childCount; i++) {\n          add.push(inject.child(i));\n        }\n\n        match = match.matchFragment(inject);\n      }\n\n      var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);\n\n      while (taken < fragment.childCount) {\n        var next = fragment.child(taken),\n            matches = match.matchType(next.type);\n        if (!matches) break;\n        taken++;\n\n        if (taken > 1 || openStart == 0 || next.content.size) {\n          match = matches;\n          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n        }\n      }\n\n      var toEnd = taken == fragment.childCount;\n      if (!toEnd) openEndCount = -1;\n      this.placed = addToFragment(this.placed, frontierDepth, prosemirrorModel.Fragment.from(add));\n      this.frontier[frontierDepth].match = match;\n      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();\n\n      for (var _i3 = 0, cur = fragment; _i3 < openEndCount; _i3++) {\n        var node = cur.lastChild;\n        this.frontier.push({\n          type: node.type,\n          match: node.contentMatchAt(node.childCount)\n        });\n        cur = node.content;\n      }\n\n      this.unplaced = !toEnd ? new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n  }, {\n    key: \"mustMoveInline\",\n    value: function mustMoveInline() {\n      if (!this.$to.parent.isTextblock) return -1;\n      var top = this.frontier[this.depth],\n          level;\n      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;\n      var depth = this.$to.depth,\n          after = this.$to.after(depth);\n\n      while (depth > 1 && after == this.$to.end(--depth)) {\n        ++after;\n      }\n\n      return after;\n    }\n  }, {\n    key: \"findCloseLevel\",\n    value: function findCloseLevel($to) {\n      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n        var _this$frontier$i = this.frontier[i],\n            match = _this$frontier$i.match,\n            type = _this$frontier$i.type;\n        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n        var fit = contentAfterFits($to, i, type, match, dropInner);\n        if (!fit) continue;\n\n        for (var d = i - 1; d >= 0; d--) {\n          var _this$frontier$d = this.frontier[d],\n              _match = _this$frontier$d.match,\n              _type = _this$frontier$d.type;\n          var matches = contentAfterFits($to, d, _type, _match, true);\n          if (!matches || matches.childCount) continue scan;\n        }\n\n        return {\n          depth: i,\n          fit: fit,\n          move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to\n        };\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close($to) {\n      var close = this.findCloseLevel($to);\n      if (!close) return null;\n\n      while (this.depth > close.depth) {\n        this.closeFrontierNode();\n      }\n\n      if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);\n      $to = close.move;\n\n      for (var d = close.depth + 1; d <= $to.depth; d++) {\n        var node = $to.node(d),\n            add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n        this.openFrontierNode(node.type, node.attrs, add);\n      }\n\n      return $to;\n    }\n  }, {\n    key: \"openFrontierNode\",\n    value: function openFrontierNode(type) {\n      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var content = arguments.length > 2 ? arguments[2] : undefined;\n      var top = this.frontier[this.depth];\n      top.match = top.match.matchType(type);\n      this.placed = addToFragment(this.placed, this.depth, prosemirrorModel.Fragment.from(type.create(attrs, content)));\n      this.frontier.push({\n        type: type,\n        match: type.contentMatch\n      });\n    }\n  }, {\n    key: \"closeFrontierNode\",\n    value: function closeFrontierNode() {\n      var open = this.frontier.pop();\n      var add = open.match.fillBefore(prosemirrorModel.Fragment.empty, true);\n      if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n  }]);\n\n  return Fitter;\n}();\n\nfunction dropFromFragment(fragment, depth, count) {\n  if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);\n  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\n\nfunction addToFragment(fragment, depth, content) {\n  if (depth == 0) return fragment.append(content);\n  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\n\nfunction contentAt(fragment, depth) {\n  for (var i = 0; i < depth; i++) {\n    fragment = fragment.firstChild.content;\n  }\n\n  return fragment;\n}\n\nfunction closeNodeStart(node, openStart, openEnd) {\n  if (openStart <= 0) return node;\n  var frag = node.content;\n  if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n\n  if (openStart > 0) {\n    frag = node.type.contentMatch.fillBefore(frag).append(frag);\n    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirrorModel.Fragment.empty, true));\n  }\n\n  return node.copy(frag);\n}\n\nfunction contentAfterFits($to, depth, type, match, open) {\n  var node = $to.node(depth),\n      index = open ? $to.indexAfter(depth) : $to.index(depth);\n  if (index == node.childCount && !type.compatibleContent(node.type)) return null;\n  var fit = match.fillBefore(node.content, true, index);\n  return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\n\nfunction invalidMarks(type, fragment, start) {\n  for (var i = start; i < fragment.childCount; i++) {\n    if (!type.allowsMarks(fragment.child(i).marks)) return true;\n  }\n\n  return false;\n}\n\nfunction definesContent(type) {\n  return type.spec.defining || type.spec.definingForContent;\n}\n\nfunction _replaceRange(tr, from, to, slice) {\n  if (!slice.size) return tr.deleteRange(from, to);\n  var $from = tr.doc.resolve(from),\n      $to = tr.doc.resolve(to);\n  if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));\n  var targetDepths = coveredDepths($from, tr.doc.resolve(to));\n  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();\n  var preferredTarget = -($from.depth + 1);\n  targetDepths.unshift(preferredTarget);\n\n  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n    var spec = $from.node(d).type.spec;\n    if (spec.defining || spec.definingAsContext || spec.isolating) break;\n    if (targetDepths.indexOf(d) > -1) preferredTarget = d;else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);\n  }\n\n  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n  var leftNodes = [],\n      preferredDepth = slice.openStart;\n\n  for (var content = slice.content, i = 0;; i++) {\n    var node = content.firstChild;\n    leftNodes.push(node);\n    if (i == slice.openStart) break;\n    content = node.content;\n  }\n\n  for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {\n    var type = leftNodes[_d3].type,\n        def = definesContent(type);\n    if (def && $from.node(preferredTargetIndex).type != type) preferredDepth = _d3;else if (def || !type.isTextblock) break;\n  }\n\n  for (var j = slice.openStart; j >= 0; j--) {\n    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n    var insert = leftNodes[openDepth];\n    if (!insert) continue;\n\n    for (var _i4 = 0; _i4 < targetDepths.length; _i4++) {\n      var targetDepth = targetDepths[(_i4 + preferredTargetIndex) % targetDepths.length],\n          expand = true;\n\n      if (targetDepth < 0) {\n        expand = false;\n        targetDepth = -targetDepth;\n      }\n\n      var parent = $from.node(targetDepth - 1),\n          index = $from.index(targetDepth - 1);\n      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n    }\n  }\n\n  var startSteps = tr.steps.length;\n\n  for (var _i5 = targetDepths.length - 1; _i5 >= 0; _i5--) {\n    tr.replace(from, to, slice);\n    if (tr.steps.length > startSteps) break;\n    var depth = targetDepths[_i5];\n    if (depth < 0) continue;\n    from = $from.before(depth);\n    to = $to.after(depth);\n  }\n}\n\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n  if (depth < oldOpen) {\n    var first = fragment.firstChild;\n    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n  }\n\n  if (depth > newOpen) {\n    var match = parent.contentMatchAt(0);\n    var start = match.fillBefore(fragment).append(fragment);\n    fragment = start.append(match.matchFragment(start).fillBefore(prosemirrorModel.Fragment.empty, true));\n  }\n\n  return fragment;\n}\n\nfunction _replaceRangeWith(tr, from, to, node) {\n  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n    var point = insertPoint(tr.doc, from, node.type);\n    if (point != null) from = to = point;\n  }\n\n  tr.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));\n}\n\nfunction _deleteRange(tr, from, to) {\n  var $from = tr.doc.resolve(from),\n      $to = tr.doc.resolve(to);\n  var covered = coveredDepths($from, $to);\n\n  for (var i = 0; i < covered.length; i++) {\n    var depth = covered[i],\n        last = i == covered.length - 1;\n    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr[\"delete\"]($from.start(depth), $to.end(depth));\n    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr[\"delete\"]($from.before(depth), $to.after(depth));\n  }\n\n  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {\n    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) return tr[\"delete\"]($from.before(d), to);\n  }\n\n  tr[\"delete\"](from, to);\n}\n\nfunction coveredDepths($from, $to) {\n  var result = [],\n      minDepth = Math.min($from.depth, $to.depth);\n\n  for (var d = minDepth; d >= 0; d--) {\n    var start = $from.start(d);\n    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;\n    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);\n  }\n\n  return result;\n}\n\nvar AttrStep = function (_Step7) {\n  _inherits(AttrStep, _Step7);\n\n  var _super7 = _createSuper(AttrStep);\n\n  function AttrStep(pos, attr, value) {\n    var _this9;\n\n    _classCallCheck(this, AttrStep);\n\n    _this9 = _super7.call(this);\n    _this9.pos = pos;\n    _this9.attr = attr;\n    _this9.value = value;\n    return _this9;\n  }\n\n  _createClass(AttrStep, [{\n    key: \"apply\",\n    value: function apply(doc) {\n      var node = doc.nodeAt(this.pos);\n      if (!node) return StepResult.fail(\"No node at attribute step's position\");\n      var attrs = Object.create(null);\n\n      for (var name in node.attrs) {\n        attrs[name] = node.attrs[name];\n      }\n\n      attrs[this.attr] = this.value;\n      var updated = node.type.create(attrs, null, node.marks);\n      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return StepMap.empty;\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(doc) {\n      return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping) {\n      var pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        stepType: \"attr\",\n        pos: this.pos,\n        attr: this.attr,\n        value: this.value\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(schema, json) {\n      if (typeof json.pos != \"number\" || typeof json.attr != \"string\") throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n      return new AttrStep(json.pos, json.attr, json.value);\n    }\n  }]);\n\n  return AttrStep;\n}(Step);\n\nStep.jsonID(\"attr\", AttrStep);\n\nexports.TransformError = function (_Error) {\n  _inherits(_class, _Error);\n\n  var _super8 = _createSuper(_class);\n\n  function _class() {\n    _classCallCheck(this, _class);\n\n    return _super8.apply(this, arguments);\n  }\n\n  return _createClass(_class);\n}(_wrapNativeSuper(Error));\n\nexports.TransformError = function TransformError(message) {\n  var err = Error.call(this, message);\n  err.__proto__ = TransformError.prototype;\n  return err;\n};\n\nexports.TransformError.prototype = Object.create(Error.prototype);\nexports.TransformError.prototype.constructor = exports.TransformError;\nexports.TransformError.prototype.name = \"TransformError\";\n\nvar Transform = function () {\n  function Transform(doc) {\n    _classCallCheck(this, Transform);\n\n    this.doc = doc;\n    this.steps = [];\n    this.docs = [];\n    this.mapping = new Mapping();\n  }\n\n  _createClass(Transform, [{\n    key: \"before\",\n    get: function get() {\n      return this.docs.length ? this.docs[0] : this.doc;\n    }\n  }, {\n    key: \"step\",\n    value: function step(_step) {\n      var result = this.maybeStep(_step);\n      if (result.failed) throw new exports.TransformError(result.failed);\n      return this;\n    }\n  }, {\n    key: \"maybeStep\",\n    value: function maybeStep(step) {\n      var result = step.apply(this.doc);\n      if (!result.failed) this.addStep(step, result.doc);\n      return result;\n    }\n  }, {\n    key: \"docChanged\",\n    get: function get() {\n      return this.steps.length > 0;\n    }\n  }, {\n    key: \"addStep\",\n    value: function addStep(step, doc) {\n      this.docs.push(this.doc);\n      this.steps.push(step);\n      this.mapping.appendMap(step.getMap());\n      this.doc = doc;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      var slice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prosemirrorModel.Slice.empty;\n      var step = replaceStep(this.doc, from, to, slice);\n      if (step) this.step(step);\n      return this;\n    }\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(from, to, content) {\n      return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0));\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(from, to) {\n      return this.replace(from, to, prosemirrorModel.Slice.empty);\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, content) {\n      return this.replaceWith(pos, pos, content);\n    }\n  }, {\n    key: \"replaceRange\",\n    value: function replaceRange(from, to, slice) {\n      _replaceRange(this, from, to, slice);\n\n      return this;\n    }\n  }, {\n    key: \"replaceRangeWith\",\n    value: function replaceRangeWith(from, to, node) {\n      _replaceRangeWith(this, from, to, node);\n\n      return this;\n    }\n  }, {\n    key: \"deleteRange\",\n    value: function deleteRange(from, to) {\n      _deleteRange(this, from, to);\n\n      return this;\n    }\n  }, {\n    key: \"lift\",\n    value: function lift(range, target) {\n      _lift(this, range, target);\n\n      return this;\n    }\n  }, {\n    key: \"join\",\n    value: function join(pos) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      _join(this, pos, depth);\n\n      return this;\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(range, wrappers) {\n      _wrap2(this, range, wrappers);\n\n      return this;\n    }\n  }, {\n    key: \"setBlockType\",\n    value: function setBlockType(from) {\n      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n      var type = arguments.length > 2 ? arguments[2] : undefined;\n      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n      _setBlockType(this, from, to, type, attrs);\n\n      return this;\n    }\n  }, {\n    key: \"setNodeMarkup\",\n    value: function setNodeMarkup(pos, type) {\n      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n      _setNodeMarkup(this, pos, type, attrs, marks);\n\n      return this;\n    }\n  }, {\n    key: \"setNodeAttribute\",\n    value: function setNodeAttribute(pos, attr, value) {\n      this.step(new AttrStep(pos, attr, value));\n      return this;\n    }\n  }, {\n    key: \"addNodeMark\",\n    value: function addNodeMark(pos, mark) {\n      this.step(new AddNodeMarkStep(pos, mark));\n      return this;\n    }\n  }, {\n    key: \"removeNodeMark\",\n    value: function removeNodeMark(pos, mark) {\n      if (!(mark instanceof prosemirrorModel.Mark)) {\n        var node = this.doc.nodeAt(pos);\n        if (!node) throw new RangeError(\"No node at position \" + pos);\n        mark = mark.isInSet(node.marks);\n        if (!mark) return this;\n      }\n\n      this.step(new RemoveNodeMarkStep(pos, mark));\n      return this;\n    }\n  }, {\n    key: \"split\",\n    value: function split(pos) {\n      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var typesAfter = arguments.length > 2 ? arguments[2] : undefined;\n\n      _split(this, pos, depth, typesAfter);\n\n      return this;\n    }\n  }, {\n    key: \"addMark\",\n    value: function addMark(from, to, mark) {\n      _addMark(this, from, to, mark);\n\n      return this;\n    }\n  }, {\n    key: \"removeMark\",\n    value: function removeMark(from, to, mark) {\n      _removeMark(this, from, to, mark);\n\n      return this;\n    }\n  }, {\n    key: \"clearIncompatible\",\n    value: function clearIncompatible(pos, parentType, match) {\n      _clearIncompatible(this, pos, parentType, match);\n\n      return this;\n    }\n  }]);\n\n  return Transform;\n}();\n\nexports.AddMarkStep = AddMarkStep;\nexports.AddNodeMarkStep = AddNodeMarkStep;\nexports.AttrStep = AttrStep;\nexports.MapResult = MapResult;\nexports.Mapping = Mapping;\nexports.RemoveMarkStep = RemoveMarkStep;\nexports.RemoveNodeMarkStep = RemoveNodeMarkStep;\nexports.ReplaceAroundStep = ReplaceAroundStep;\nexports.ReplaceStep = ReplaceStep;\nexports.Step = Step;\nexports.StepMap = StepMap;\nexports.StepResult = StepResult;\nexports.Transform = Transform;\nexports.canJoin = canJoin;\nexports.canSplit = canSplit;\nexports.dropPoint = dropPoint;\nexports.findWrapping = findWrapping;\nexports.insertPoint = insertPoint;\nexports.joinPoint = joinPoint;\nexports.liftTarget = liftTarget;\nexports.replaceStep = replaceStep;\n", "'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar prosemirrorModel = require('prosemirror-model');\n\nvar prosemirrorTransform = require('prosemirror-transform');\n\nvar classesById = Object.create(null);\n\nvar Selection = function () {\n  function Selection($anchor, $head, ranges) {\n    _classCallCheck(this, Selection);\n\n    this.$anchor = $anchor;\n    this.$head = $head;\n    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n  }\n\n  _createClass(Selection, [{\n    key: \"anchor\",\n    get: function get() {\n      return this.$anchor.pos;\n    }\n  }, {\n    key: \"head\",\n    get: function get() {\n      return this.$head.pos;\n    }\n  }, {\n    key: \"from\",\n    get: function get() {\n      return this.$from.pos;\n    }\n  }, {\n    key: \"to\",\n    get: function get() {\n      return this.$to.pos;\n    }\n  }, {\n    key: \"$from\",\n    get: function get() {\n      return this.ranges[0].$from;\n    }\n  }, {\n    key: \"$to\",\n    get: function get() {\n      return this.ranges[0].$to;\n    }\n  }, {\n    key: \"empty\",\n    get: function get() {\n      var ranges = this.ranges;\n\n      for (var i = 0; i < ranges.length; i++) {\n        if (ranges[i].$from.pos != ranges[i].$to.pos) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      return this.$from.doc.slice(this.from, this.to, true);\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;\n      var lastNode = content.content.lastChild,\n          lastParent = null;\n\n      for (var i = 0; i < content.openEnd; i++) {\n        lastParent = lastNode;\n        lastNode = lastNode.lastChild;\n      }\n\n      var mapFrom = tr.steps.length,\n          ranges = this.ranges;\n\n      for (var _i = 0; _i < ranges.length; _i++) {\n        var _ranges$_i = ranges[_i],\n            $from = _ranges$_i.$from,\n            $to = _ranges$_i.$to,\n            mapping = tr.mapping.slice(mapFrom);\n        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? prosemirrorModel.Slice.empty : content);\n        if (_i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n      }\n    }\n  }, {\n    key: \"replaceWith\",\n    value: function replaceWith(tr, node) {\n      var mapFrom = tr.steps.length,\n          ranges = this.ranges;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var _ranges$i = ranges[i],\n            $from = _ranges$i.$from,\n            $to = _ranges$i.$to,\n            mapping = tr.mapping.slice(mapFrom);\n        var from = mapping.map($from.pos),\n            to = mapping.map($to.pos);\n\n        if (i) {\n          tr.deleteRange(from, to);\n        } else {\n          tr.replaceRangeWith(from, to, node);\n          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n        }\n      }\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n  }], [{\n    key: \"findFrom\",\n    value: function findFrom($pos, dir) {\n      var textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n      if (inner) return inner;\n\n      for (var depth = $pos.depth - 1; depth >= 0; depth--) {\n        var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n        if (found) return found;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"near\",\n    value: function near($pos) {\n      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n  }, {\n    key: \"atStart\",\n    value: function atStart(doc) {\n      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n  }, {\n    key: \"atEnd\",\n    value: function atEnd(doc) {\n      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (!json || !json.type) throw new RangeError(\"Invalid input for Selection.fromJSON\");\n      var cls = classesById[json.type];\n      if (!cls) throw new RangeError(\"No selection type \".concat(json.type, \" defined\"));\n      return cls.fromJSON(doc, json);\n    }\n  }, {\n    key: \"jsonID\",\n    value: function jsonID(id, selectionClass) {\n      if (id in classesById) throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n      classesById[id] = selectionClass;\n      selectionClass.prototype.jsonID = id;\n      return selectionClass;\n    }\n  }]);\n\n  return Selection;\n}();\n\nSelection.prototype.visible = true;\n\nvar SelectionRange = _createClass(function SelectionRange($from, $to) {\n  _classCallCheck(this, SelectionRange);\n\n  this.$from = $from;\n  this.$to = $to;\n});\n\nvar warnedAboutTextSelection = false;\n\nfunction checkTextSelection($pos) {\n  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n    warnedAboutTextSelection = true;\n    console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n  }\n}\n\nvar TextSelection = function (_Selection) {\n  _inherits(TextSelection, _Selection);\n\n  var _super = _createSuper(TextSelection);\n\n  function TextSelection($anchor) {\n    var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;\n\n    _classCallCheck(this, TextSelection);\n\n    checkTextSelection($anchor);\n    checkTextSelection($head);\n    return _super.call(this, $anchor, $head);\n  }\n\n  _createClass(TextSelection, [{\n    key: \"$cursor\",\n    get: function get() {\n      return this.$anchor.pos == this.$head.pos ? this.$head : null;\n    }\n  }, {\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var $head = doc.resolve(mapping.map(this.head));\n      if (!$head.parent.inlineContent) return Selection.near($head);\n      var $anchor = doc.resolve(mapping.map(this.anchor));\n      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;\n\n      _get(_getPrototypeOf(TextSelection.prototype), \"replace\", this).call(this, tr, content);\n\n      if (content == prosemirrorModel.Slice.empty) {\n        var marks = this.$from.marksAcross(this.$to);\n        if (marks) tr.ensureMarks(marks);\n      }\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return new TextBookmark(this.anchor, this.head);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"text\",\n        anchor: this.anchor,\n        head: this.head\n      };\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (typeof json.anchor != \"number\" || typeof json.head != \"number\") throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n      return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n  }, {\n    key: \"create\",\n    value: function create(doc, anchor) {\n      var head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;\n      var $anchor = doc.resolve(anchor);\n      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n  }, {\n    key: \"between\",\n    value: function between($anchor, $head, bias) {\n      var dPos = $anchor.pos - $head.pos;\n      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;\n\n      if (!$head.parent.inlineContent) {\n        var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n        if (found) $head = found.$head;else return Selection.near($head, bias);\n      }\n\n      if (!$anchor.parent.inlineContent) {\n        if (dPos == 0) {\n          $anchor = $head;\n        } else {\n          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;\n        }\n      }\n\n      return new TextSelection($anchor, $head);\n    }\n  }]);\n\n  return TextSelection;\n}(Selection);\n\nSelection.jsonID(\"text\", TextSelection);\n\nvar TextBookmark = function () {\n  function TextBookmark(anchor, head) {\n    _classCallCheck(this, TextBookmark);\n\n    this.anchor = anchor;\n    this.head = head;\n  }\n\n  _createClass(TextBookmark, [{\n    key: \"map\",\n    value: function map(mapping) {\n      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(doc) {\n      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n  }]);\n\n  return TextBookmark;\n}();\n\nvar NodeSelection = function (_Selection2) {\n  _inherits(NodeSelection, _Selection2);\n\n  var _super2 = _createSuper(NodeSelection);\n\n  function NodeSelection($pos) {\n    var _this;\n\n    _classCallCheck(this, NodeSelection);\n\n    var node = $pos.nodeAfter;\n    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n    _this = _super2.call(this, $pos, $end);\n    _this.node = node;\n    return _this;\n  }\n\n  _createClass(NodeSelection, [{\n    key: \"map\",\n    value: function map(doc, mapping) {\n      var _mapping$mapResult = mapping.mapResult(this.anchor),\n          deleted = _mapping$mapResult.deleted,\n          pos = _mapping$mapResult.pos;\n\n      var $pos = doc.resolve(pos);\n      if (deleted) return Selection.near($pos);\n      return new NodeSelection($pos);\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(this.node), 0, 0);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"node\",\n        anchor: this.anchor\n      };\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return new NodeBookmark(this.anchor);\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc, json) {\n      if (typeof json.anchor != \"number\") throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n      return new NodeSelection(doc.resolve(json.anchor));\n    }\n  }, {\n    key: \"create\",\n    value: function create(doc, from) {\n      return new NodeSelection(doc.resolve(from));\n    }\n  }, {\n    key: \"isSelectable\",\n    value: function isSelectable(node) {\n      return !node.isText && node.type.spec.selectable !== false;\n    }\n  }]);\n\n  return NodeSelection;\n}(Selection);\n\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\n\nvar NodeBookmark = function () {\n  function NodeBookmark(anchor) {\n    _classCallCheck(this, NodeBookmark);\n\n    this.anchor = anchor;\n  }\n\n  _createClass(NodeBookmark, [{\n    key: \"map\",\n    value: function map(mapping) {\n      var _mapping$mapResult2 = mapping.mapResult(this.anchor),\n          deleted = _mapping$mapResult2.deleted,\n          pos = _mapping$mapResult2.pos;\n\n      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(doc) {\n      var $pos = doc.resolve(this.anchor),\n          node = $pos.nodeAfter;\n      if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);\n      return Selection.near($pos);\n    }\n  }]);\n\n  return NodeBookmark;\n}();\n\nvar AllSelection = function (_Selection3) {\n  _inherits(AllSelection, _Selection3);\n\n  var _super3 = _createSuper(AllSelection);\n\n  function AllSelection(doc) {\n    _classCallCheck(this, AllSelection);\n\n    return _super3.call(this, doc.resolve(0), doc.resolve(doc.content.size));\n  }\n\n  _createClass(AllSelection, [{\n    key: \"replace\",\n    value: function replace(tr) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;\n\n      if (content == prosemirrorModel.Slice.empty) {\n        tr[\"delete\"](0, tr.doc.content.size);\n        var sel = Selection.atStart(tr.doc);\n        if (!sel.eq(tr.selection)) tr.setSelection(sel);\n      } else {\n        _get(_getPrototypeOf(AllSelection.prototype), \"replace\", this).call(this, tr, content);\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: \"all\"\n      };\n    }\n  }, {\n    key: \"map\",\n    value: function map(doc) {\n      return new AllSelection(doc);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return other instanceof AllSelection;\n    }\n  }, {\n    key: \"getBookmark\",\n    value: function getBookmark() {\n      return AllBookmark;\n    }\n  }], [{\n    key: \"fromJSON\",\n    value: function fromJSON(doc) {\n      return new AllSelection(doc);\n    }\n  }]);\n\n  return AllSelection;\n}(Selection);\n\nSelection.jsonID(\"all\", AllSelection);\nvar AllBookmark = {\n  map: function map() {\n    return this;\n  },\n  resolve: function resolve(doc) {\n    return new AllSelection(doc);\n  }\n};\n\nfunction findSelectionIn(doc, node, pos, index, dir) {\n  var text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  if (node.inlineContent) return TextSelection.create(doc, pos);\n\n  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n    var child = node.child(i);\n\n    if (!child.isAtom) {\n      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n      if (inner) return inner;\n    } else if (!text && NodeSelection.isSelectable(child)) {\n      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n    }\n\n    pos += child.nodeSize * dir;\n  }\n\n  return null;\n}\n\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n  var last = tr.steps.length - 1;\n  if (last < startLen) return;\n  var step = tr.steps[last];\n  if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) return;\n  var map = tr.mapping.maps[last],\n      end;\n  map.forEach(function (_from, _to, _newFrom, newTo) {\n    if (end == null) end = newTo;\n  });\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nvar UPDATED_SEL = 1,\n    UPDATED_MARKS = 2,\n    UPDATED_SCROLL = 4;\n\nvar Transaction = function (_prosemirrorTransform) {\n  _inherits(Transaction, _prosemirrorTransform);\n\n  var _super4 = _createSuper(Transaction);\n\n  function Transaction(state) {\n    var _this2;\n\n    _classCallCheck(this, Transaction);\n\n    _this2 = _super4.call(this, state.doc);\n    _this2.curSelectionFor = 0;\n    _this2.updated = 0;\n    _this2.meta = Object.create(null);\n    _this2.time = Date.now();\n    _this2.curSelection = state.selection;\n    _this2.storedMarks = state.storedMarks;\n    return _this2;\n  }\n\n  _createClass(Transaction, [{\n    key: \"selection\",\n    get: function get() {\n      if (this.curSelectionFor < this.steps.length) {\n        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n        this.curSelectionFor = this.steps.length;\n      }\n\n      return this.curSelection;\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      if (selection.$from.doc != this.doc) throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n      this.curSelection = selection;\n      this.curSelectionFor = this.steps.length;\n      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n      this.storedMarks = null;\n      return this;\n    }\n  }, {\n    key: \"selectionSet\",\n    get: function get() {\n      return (this.updated & UPDATED_SEL) > 0;\n    }\n  }, {\n    key: \"setStoredMarks\",\n    value: function setStoredMarks(marks) {\n      this.storedMarks = marks;\n      this.updated |= UPDATED_MARKS;\n      return this;\n    }\n  }, {\n    key: \"ensureMarks\",\n    value: function ensureMarks(marks) {\n      if (!prosemirrorModel.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);\n      return this;\n    }\n  }, {\n    key: \"addStoredMark\",\n    value: function addStoredMark(mark) {\n      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n  }, {\n    key: \"removeStoredMark\",\n    value: function removeStoredMark(mark) {\n      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n  }, {\n    key: \"storedMarksSet\",\n    get: function get() {\n      return (this.updated & UPDATED_MARKS) > 0;\n    }\n  }, {\n    key: \"addStep\",\n    value: function addStep(step, doc) {\n      _get(_getPrototypeOf(Transaction.prototype), \"addStep\", this).call(this, step, doc);\n\n      this.updated = this.updated & ~UPDATED_MARKS;\n      this.storedMarks = null;\n    }\n  }, {\n    key: \"setTime\",\n    value: function setTime(time) {\n      this.time = time;\n      return this;\n    }\n  }, {\n    key: \"replaceSelection\",\n    value: function replaceSelection(slice) {\n      this.selection.replace(this, slice);\n      return this;\n    }\n  }, {\n    key: \"replaceSelectionWith\",\n    value: function replaceSelectionWith(node) {\n      var inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var selection = this.selection;\n      if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirrorModel.Mark.none));\n      selection.replaceWith(this, node);\n      return this;\n    }\n  }, {\n    key: \"deleteSelection\",\n    value: function deleteSelection() {\n      this.selection.replace(this);\n      return this;\n    }\n  }, {\n    key: \"insertText\",\n    value: function insertText(text, from, to) {\n      var schema = this.doc.type.schema;\n\n      if (from == null) {\n        if (!text) return this.deleteSelection();\n        return this.replaceSelectionWith(schema.text(text), true);\n      } else {\n        if (to == null) to = from;\n        to = to == null ? from : to;\n        if (!text) return this.deleteRange(from, to);\n        var marks = this.storedMarks;\n\n        if (!marks) {\n          var $from = this.doc.resolve(from);\n          marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n        }\n\n        this.replaceRangeWith(from, to, schema.text(text, marks));\n        if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));\n        return this;\n      }\n    }\n  }, {\n    key: \"setMeta\",\n    value: function setMeta(key, value) {\n      this.meta[typeof key == \"string\" ? key : key.key] = value;\n      return this;\n    }\n  }, {\n    key: \"getMeta\",\n    value: function getMeta(key) {\n      return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n  }, {\n    key: \"isGeneric\",\n    get: function get() {\n      for (var _ in this.meta) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"scrollIntoView\",\n    value: function scrollIntoView() {\n      this.updated |= UPDATED_SCROLL;\n      return this;\n    }\n  }, {\n    key: \"scrolledIntoView\",\n    get: function get() {\n      return (this.updated & UPDATED_SCROLL) > 0;\n    }\n  }]);\n\n  return Transaction;\n}(prosemirrorTransform.Transform);\n\nfunction bind(f, self) {\n  return !self || !f ? f : f.bind(self);\n}\n\nvar FieldDesc = _createClass(function FieldDesc(name, desc, self) {\n  _classCallCheck(this, FieldDesc);\n\n  this.name = name;\n  this.init = bind(desc.init, self);\n  this.apply = bind(desc.apply, self);\n});\n\nvar baseFields = [new FieldDesc(\"doc\", {\n  init: function init(config) {\n    return config.doc || config.schema.topNodeType.createAndFill();\n  },\n  apply: function apply(tr) {\n    return tr.doc;\n  }\n}), new FieldDesc(\"selection\", {\n  init: function init(config, instance) {\n    return config.selection || Selection.atStart(instance.doc);\n  },\n  apply: function apply(tr) {\n    return tr.selection;\n  }\n}), new FieldDesc(\"storedMarks\", {\n  init: function init(config) {\n    return config.storedMarks || null;\n  },\n  apply: function apply(tr, _marks, _old, state) {\n    return state.selection.$cursor ? tr.storedMarks : null;\n  }\n}), new FieldDesc(\"scrollToSelection\", {\n  init: function init() {\n    return 0;\n  },\n  apply: function apply(tr, prev) {\n    return tr.scrolledIntoView ? prev + 1 : prev;\n  }\n})];\n\nvar Configuration = _createClass(function Configuration(schema, plugins) {\n  var _this3 = this;\n\n  _classCallCheck(this, Configuration);\n\n  this.schema = schema;\n  this.plugins = [];\n  this.pluginsByKey = Object.create(null);\n  this.fields = baseFields.slice();\n  if (plugins) plugins.forEach(function (plugin) {\n    if (_this3.pluginsByKey[plugin.key]) throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n\n    _this3.plugins.push(plugin);\n\n    _this3.pluginsByKey[plugin.key] = plugin;\n    if (plugin.spec.state) _this3.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n  });\n});\n\nvar EditorState = function () {\n  function EditorState(config) {\n    _classCallCheck(this, EditorState);\n\n    this.config = config;\n  }\n\n  _createClass(EditorState, [{\n    key: \"schema\",\n    get: function get() {\n      return this.config.schema;\n    }\n  }, {\n    key: \"plugins\",\n    get: function get() {\n      return this.config.plugins;\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(tr) {\n      return this.applyTransaction(tr).state;\n    }\n  }, {\n    key: \"filterTransaction\",\n    value: function filterTransaction(tr) {\n      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n      for (var i = 0; i < this.config.plugins.length; i++) {\n        if (i != ignore) {\n          var plugin = this.config.plugins[i];\n          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"applyTransaction\",\n    value: function applyTransaction(rootTr) {\n      if (!this.filterTransaction(rootTr)) return {\n        state: this,\n        transactions: []\n      };\n      var trs = [rootTr],\n          newState = this.applyInner(rootTr),\n          seen = null;\n\n      for (;;) {\n        var haveNew = false;\n\n        for (var i = 0; i < this.config.plugins.length; i++) {\n          var plugin = this.config.plugins[i];\n\n          if (plugin.spec.appendTransaction) {\n            var n = seen ? seen[i].n : 0,\n                oldState = seen ? seen[i].state : this;\n            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n\n            if (tr && newState.filterTransaction(tr, i)) {\n              tr.setMeta(\"appendedTransaction\", rootTr);\n\n              if (!seen) {\n                seen = [];\n\n                for (var j = 0; j < this.config.plugins.length; j++) {\n                  seen.push(j < i ? {\n                    state: newState,\n                    n: trs.length\n                  } : {\n                    state: this,\n                    n: 0\n                  });\n                }\n              }\n\n              trs.push(tr);\n              newState = newState.applyInner(tr);\n              haveNew = true;\n            }\n\n            if (seen) seen[i] = {\n              state: newState,\n              n: trs.length\n            };\n          }\n        }\n\n        if (!haveNew) return {\n          state: newState,\n          transactions: trs\n        };\n      }\n    }\n  }, {\n    key: \"applyInner\",\n    value: function applyInner(tr) {\n      if (!tr.before.eq(this.doc)) throw new RangeError(\"Applying a mismatched transaction\");\n      var newInstance = new EditorState(this.config),\n          fields = this.config.fields;\n\n      for (var i = 0; i < fields.length; i++) {\n        var field = fields[i];\n        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n      }\n\n      return newInstance;\n    }\n  }, {\n    key: \"tr\",\n    get: function get() {\n      return new Transaction(this);\n    }\n  }, {\n    key: \"reconfigure\",\n    value: function reconfigure(config) {\n      var $config = new Configuration(this.schema, config.plugins);\n      var fields = $config.fields,\n          instance = new EditorState($config);\n\n      for (var i = 0; i < fields.length; i++) {\n        var name = fields[i].name;\n        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n      }\n\n      return instance;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(pluginFields) {\n      var result = {\n        doc: this.doc.toJSON(),\n        selection: this.selection.toJSON()\n      };\n      if (this.storedMarks) result.storedMarks = this.storedMarks.map(function (m) {\n        return m.toJSON();\n      });\n      if (pluginFields && _typeof(pluginFields) == 'object') for (var prop in pluginFields) {\n        if (prop == \"doc\" || prop == \"selection\") throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n        var plugin = pluginFields[prop],\n            state = plugin.spec.state;\n        if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n      }\n      return result;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(config) {\n      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n      var instance = new EditorState($config);\n\n      for (var i = 0; i < $config.fields.length; i++) {\n        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n      }\n\n      return instance;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(config, json, pluginFields) {\n      if (!json) throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n      if (!config.schema) throw new RangeError(\"Required config field 'schema' missing\");\n      var $config = new Configuration(config.schema, config.plugins);\n      var instance = new EditorState($config);\n      $config.fields.forEach(function (field) {\n        if (field.name == \"doc\") {\n          instance.doc = prosemirrorModel.Node.fromJSON(config.schema, json.doc);\n        } else if (field.name == \"selection\") {\n          instance.selection = Selection.fromJSON(instance.doc, json.selection);\n        } else if (field.name == \"storedMarks\") {\n          if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n        } else {\n          if (pluginFields) for (var prop in pluginFields) {\n            var plugin = pluginFields[prop],\n                state = plugin.spec.state;\n\n            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {\n              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n              return;\n            }\n          }\n          instance[field.name] = field.init(config, instance);\n        }\n      });\n      return instance;\n    }\n  }]);\n\n  return EditorState;\n}();\n\nfunction bindProps(obj, self, target) {\n  for (var prop in obj) {\n    var val = obj[prop];\n    if (val instanceof Function) val = val.bind(self);else if (prop == \"handleDOMEvents\") val = bindProps(val, self, {});\n    target[prop] = val;\n  }\n\n  return target;\n}\n\nvar Plugin = function () {\n  function Plugin(spec) {\n    _classCallCheck(this, Plugin);\n\n    this.spec = spec;\n    this.props = {};\n    if (spec.props) bindProps(spec.props, this, this.props);\n    this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n  }\n\n  _createClass(Plugin, [{\n    key: \"getState\",\n    value: function getState(state) {\n      return state[this.key];\n    }\n  }]);\n\n  return Plugin;\n}();\n\nvar keys = Object.create(null);\n\nfunction createKey(name) {\n  if (name in keys) return name + \"$\" + ++keys[name];\n  keys[name] = 0;\n  return name + \"$\";\n}\n\nvar PluginKey = function () {\n  function PluginKey() {\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"key\";\n\n    _classCallCheck(this, PluginKey);\n\n    this.key = createKey(name);\n  }\n\n  _createClass(PluginKey, [{\n    key: \"get\",\n    value: function get(state) {\n      return state.config.pluginsByKey[this.key];\n    }\n  }, {\n    key: \"getState\",\n    value: function getState(state) {\n      return state[this.key];\n    }\n  }]);\n\n  return PluginKey;\n}();\n\nexports.AllSelection = AllSelection;\nexports.EditorState = EditorState;\nexports.NodeSelection = NodeSelection;\nexports.Plugin = Plugin;\nexports.PluginKey = PluginKey;\nexports.Selection = Selection;\nexports.SelectionRange = SelectionRange;\nexports.TextSelection = TextSelection;\nexports.Transaction = Transaction;\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n};\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n};\n\nvar chrome = typeof navigator != \"undefined\" && /Chrome\\/(\\d+)/.exec(navigator.userAgent);\nvar gecko = typeof navigator != \"undefined\" && /Gecko\\/\\d+/.test(navigator.userAgent);\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nvar brokenModifierNames = mac || chrome && +chrome[1] < 57;\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i;\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32);\n  shift[i] = String.fromCharCode(i);\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];\n\nfunction keyName(event) {\n  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||\n    ie && event.shiftKey && event.key && event.key.length == 1 ||\n    event.key == \"Unidentified\";\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\";\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\";\n  if (name == \"Del\") name = \"Delete\";\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\";\n  if (name == \"Up\") name = \"ArrowUp\";\n  if (name == \"Right\") name = \"ArrowRight\";\n  if (name == \"Down\") name = \"ArrowDown\";\n  return name\n}\n\nexports.base = base;\nexports.keyName = keyName;\nexports.shift = shift;\n", "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar w3cKeyname = require('w3c-keyname');\n\nvar prosemirrorState = require('prosemirror-state');\n\nvar mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\n\nfunction normalizeKeyName(name) {\n  var parts = name.split(/-(?!$)/),\n      result = parts[parts.length - 1];\n  if (result == \"Space\") result = \" \";\n  var alt, ctrl, shift, meta;\n\n  for (var i = 0; i < parts.length - 1; i++) {\n    var mod = parts[i];\n    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {\n      if (mac) meta = true;else ctrl = true;\n    } else throw new Error(\"Unrecognized modifier name: \" + mod);\n  }\n\n  if (alt) result = \"Alt-\" + result;\n  if (ctrl) result = \"Ctrl-\" + result;\n  if (meta) result = \"Meta-\" + result;\n  if (shift) result = \"Shift-\" + result;\n  return result;\n}\n\nfunction normalize(map) {\n  var copy = Object.create(null);\n\n  for (var prop in map) {\n    copy[normalizeKeyName(prop)] = map[prop];\n  }\n\n  return copy;\n}\n\nfunction modifiers(name, event, shift) {\n  if (event.altKey) name = \"Alt-\" + name;\n  if (event.ctrlKey) name = \"Ctrl-\" + name;\n  if (event.metaKey) name = \"Meta-\" + name;\n  if (shift !== false && event.shiftKey) name = \"Shift-\" + name;\n  return name;\n}\n\nfunction keymap(bindings) {\n  return new prosemirrorState.Plugin({\n    props: {\n      handleKeyDown: keydownHandler(bindings)\n    }\n  });\n}\n\nfunction keydownHandler(bindings) {\n  var map = normalize(bindings);\n  return function (view, event) {\n    var name = w3cKeyname.keyName(event),\n        isChar = name.length == 1 && name != \" \",\n        baseName;\n    var direct = map[modifiers(name, event, !isChar)];\n    if (direct && direct(view.state, view.dispatch, view)) return true;\n\n    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {\n      var fromCode = map[modifiers(baseName, event, true)];\n      if (fromCode && fromCode(view.state, view.dispatch, view)) return true;\n    } else if (isChar && event.shiftKey) {\n      var withShift = map[modifiers(name, event, true)];\n      if (withShift && withShift(view.state, view.dispatch, view)) return true;\n    }\n\n    return false;\n  };\n}\n\nexports.keydownHandler = keydownHandler;\nexports.keymap = keymap;\n", "'use strict';\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nfunction _get() { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar prosemirrorState = require('prosemirror-state');\n\nvar prosemirrorModel = require('prosemirror-model');\n\nvar prosemirrorTransform = require('prosemirror-transform');\n\nvar domIndex = function domIndex(node) {\n  for (var index = 0;; index++) {\n    node = node.previousSibling;\n    if (!node) return index;\n  }\n};\n\nvar parentNode = function parentNode(node) {\n  var parent = node.assignedSlot || node.parentNode;\n  return parent && parent.nodeType == 11 ? parent.host : parent;\n};\n\nvar reusedRange = null;\n\nvar textRange = function textRange(node, from, to) {\n  var range = reusedRange || (reusedRange = document.createRange());\n  range.setEnd(node, to == null ? node.nodeValue.length : to);\n  range.setStart(node, from || 0);\n  return range;\n};\n\nvar isEquivalentPosition = function isEquivalentPosition(node, off, targetNode, targetOff) {\n  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n};\n\nvar atomElements = /^(img|br|input|textarea|hr)$/i;\n\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n  for (;;) {\n    if (node == targetNode && off == targetOff) return true;\n\n    if (off == (dir < 0 ? 0 : nodeSize(node))) {\n      var parent = node.parentNode;\n      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\") return false;\n      off = domIndex(node) + (dir < 0 ? 0 : 1);\n      node = parent;\n    } else if (node.nodeType == 1) {\n      node = node.childNodes[off + (dir < 0 ? -1 : 0)];\n      if (node.contentEditable == \"false\") return false;\n      off = dir < 0 ? nodeSize(node) : 0;\n    } else {\n      return false;\n    }\n  }\n}\n\nfunction nodeSize(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\n\nfunction isOnEdge(node, offset, parent) {\n  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n    if (node == parent) return true;\n    var index = domIndex(node);\n    node = node.parentNode;\n    if (!node) return false;\n    atStart = atStart && index == 0;\n    atEnd = atEnd && index == nodeSize(node);\n  }\n}\n\nfunction hasBlockDesc(dom) {\n  var desc;\n\n  for (var cur = dom; cur; cur = cur.parentNode) {\n    if (desc = cur.pmViewDesc) break;\n  }\n\n  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n\nvar selectionCollapsed = function selectionCollapsed(domSel) {\n  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\n\nfunction keyEvent(keyCode, key) {\n  var event = document.createEvent(\"Event\");\n  event.initEvent(\"keydown\", true, true);\n  event.keyCode = keyCode;\n  event.key = event.code = key;\n  return event;\n}\n\nfunction deepActiveElement(doc) {\n  var elt = doc.activeElement;\n\n  while (elt && elt.shadowRoot) {\n    elt = elt.shadowRoot.activeElement;\n  }\n\n  return elt;\n}\n\nvar nav = typeof navigator != \"undefined\" ? navigator : null;\nvar doc = typeof document != \"undefined\" ? document : null;\nvar agent = nav && nav.userAgent || \"\";\nvar ie_edge = /Edge\\/(\\d+)/.exec(agent);\nvar ie_upto10 = /MSIE \\d/.exec(agent);\nvar ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nvar ie = !!(ie_upto10 || ie_11up || ie_edge);\nvar ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nvar gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\n\nvar _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\n\nvar chrome = !!_chrome;\nvar chrome_version = _chrome ? +_chrome[1] : 0;\nvar safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\nvar ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nvar mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nvar android = /Android \\d/.test(agent);\nvar webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nvar webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\n\nfunction windowRect(doc) {\n  return {\n    left: 0,\n    right: doc.documentElement.clientWidth,\n    top: 0,\n    bottom: doc.documentElement.clientHeight\n  };\n}\n\nfunction getSide(value, side) {\n  return typeof value == \"number\" ? value : value[side];\n}\n\nfunction clientRect(node) {\n  var rect = node.getBoundingClientRect();\n  var scaleX = rect.width / node.offsetWidth || 1;\n  var scaleY = rect.height / node.offsetHeight || 1;\n  return {\n    left: rect.left,\n    right: rect.left + node.clientWidth * scaleX,\n    top: rect.top,\n    bottom: rect.top + node.clientHeight * scaleY\n  };\n}\n\nfunction scrollRectIntoView(view, rect, startDOM) {\n  var scrollThreshold = view.someProp(\"scrollThreshold\") || 0,\n      scrollMargin = view.someProp(\"scrollMargin\") || 5;\n  var doc = view.dom.ownerDocument;\n\n  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {\n    if (!parent) break;\n    if (parent.nodeType != 1) continue;\n    var elt = parent;\n    var atTop = elt == doc.body;\n    var bounding = atTop ? windowRect(doc) : clientRect(elt);\n    var moveX = 0,\n        moveY = 0;\n    if (rect.top < bounding.top + getSide(scrollThreshold, \"top\")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\")) moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n    if (rect.left < bounding.left + getSide(scrollThreshold, \"left\")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\")) moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n\n    if (moveX || moveY) {\n      if (atTop) {\n        doc.defaultView.scrollBy(moveX, moveY);\n      } else {\n        var startX = elt.scrollLeft,\n            startY = elt.scrollTop;\n        if (moveY) elt.scrollTop += moveY;\n        if (moveX) elt.scrollLeft += moveX;\n        var dX = elt.scrollLeft - startX,\n            dY = elt.scrollTop - startY;\n        rect = {\n          left: rect.left - dX,\n          top: rect.top - dY,\n          right: rect.right - dX,\n          bottom: rect.bottom - dY\n        };\n      }\n    }\n\n    if (atTop) break;\n  }\n}\n\nfunction storeScrollPos(view) {\n  var rect = view.dom.getBoundingClientRect(),\n      startY = Math.max(0, rect.top);\n  var refDOM, refTop;\n\n  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {\n    var dom = view.root.elementFromPoint(x, y);\n    if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;\n    var localRect = dom.getBoundingClientRect();\n\n    if (localRect.top >= startY - 20) {\n      refDOM = dom;\n      refTop = localRect.top;\n      break;\n    }\n  }\n\n  return {\n    refDOM: refDOM,\n    refTop: refTop,\n    stack: scrollStack(view.dom)\n  };\n}\n\nfunction scrollStack(dom) {\n  var stack = [],\n      doc = dom.ownerDocument;\n\n  for (var cur = dom; cur; cur = parentNode(cur)) {\n    stack.push({\n      dom: cur,\n      top: cur.scrollTop,\n      left: cur.scrollLeft\n    });\n    if (dom == doc) break;\n  }\n\n  return stack;\n}\n\nfunction resetScrollPos(_ref) {\n  var refDOM = _ref.refDOM,\n      refTop = _ref.refTop,\n      stack = _ref.stack;\n  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\n\nfunction restoreScrollStack(stack, dTop) {\n  for (var i = 0; i < stack.length; i++) {\n    var _stack$i = stack[i],\n        dom = _stack$i.dom,\n        top = _stack$i.top,\n        left = _stack$i.left;\n    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;\n    if (dom.scrollLeft != left) dom.scrollLeft = left;\n  }\n}\n\nvar preventScrollSupported = null;\n\nfunction focusPreventScroll(dom) {\n  if (dom.setActive) return dom.setActive();\n  if (preventScrollSupported) return dom.focus(preventScrollSupported);\n  var stored = scrollStack(dom);\n  dom.focus(preventScrollSupported == null ? {\n    get preventScroll() {\n      preventScrollSupported = {\n        preventScroll: true\n      };\n      return true;\n    }\n\n  } : undefined);\n\n  if (!preventScrollSupported) {\n    preventScrollSupported = false;\n    restoreScrollStack(stored, 0);\n  }\n}\n\nfunction findOffsetInNode(node, coords) {\n  var closest,\n      dxClosest = 2e8,\n      coordsClosest,\n      offset = 0;\n  var rowBot = coords.top,\n      rowTop = coords.top;\n\n  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n    var rects = void 0;\n    if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRange(child).getClientRects();else continue;\n\n    for (var i = 0; i < rects.length; i++) {\n      var rect = rects[i];\n\n      if (rect.top <= rowBot && rect.bottom >= rowTop) {\n        rowBot = Math.max(rect.bottom, rowBot);\n        rowTop = Math.min(rect.top, rowTop);\n        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n\n        if (dx < dxClosest) {\n          closest = child;\n          dxClosest = dx;\n          coordsClosest = dx && closest.nodeType == 3 ? {\n            left: rect.right < coords.left ? rect.right : rect.left,\n            top: coords.top\n          } : coords;\n          if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n          continue;\n        }\n      }\n\n      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;\n    }\n  }\n\n  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);\n  if (!closest || dxClosest && closest.nodeType == 1) return {\n    node: node,\n    offset: offset\n  };\n  return findOffsetInNode(closest, coordsClosest);\n}\n\nfunction findOffsetInText(node, coords) {\n  var len = node.nodeValue.length;\n  var range = document.createRange();\n\n  for (var i = 0; i < len; i++) {\n    range.setEnd(node, i + 1);\n    range.setStart(node, i);\n    var rect = singleRect(range, 1);\n    if (rect.top == rect.bottom) continue;\n    if (inRect(coords, rect)) return {\n      node: node,\n      offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)\n    };\n  }\n\n  return {\n    node: node,\n    offset: 0\n  };\n}\n\nfunction inRect(coords, rect) {\n  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\n\nfunction targetKludge(dom, coords) {\n  var parent = dom.parentNode;\n  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;\n  return dom;\n}\n\nfunction posFromElement(view, elt, coords) {\n  var _findOffsetInNode = findOffsetInNode(elt, coords),\n      node = _findOffsetInNode.node,\n      offset = _findOffsetInNode.offset,\n      bias = -1;\n\n  if (node.nodeType == 1 && !node.firstChild) {\n    var rect = node.getBoundingClientRect();\n    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n  }\n\n  return view.docView.posFromDOM(node, offset, bias);\n}\n\nfunction posFromCaret(view, node, offset, coords) {\n  var outside = -1;\n\n  for (var cur = node;;) {\n    if (cur == view.dom) break;\n    var desc = view.docView.nearestDesc(cur, true);\n    if (!desc) return null;\n\n    if (desc.node.isBlock && desc.parent) {\n      var rect = desc.dom.getBoundingClientRect();\n      if (rect.left > coords.left || rect.top > coords.top) outside = desc.posBefore;else if (rect.right < coords.left || rect.bottom < coords.top) outside = desc.posAfter;else break;\n    }\n\n    cur = desc.dom.parentNode;\n  }\n\n  return outside > -1 ? outside : view.docView.posFromDOM(node, offset, 1);\n}\n\nfunction elementFromPoint(element, coords, box) {\n  var len = element.childNodes.length;\n\n  if (len && box.top < box.bottom) {\n    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n      var child = element.childNodes[i];\n\n      if (child.nodeType == 1) {\n        var rects = child.getClientRects();\n\n        for (var j = 0; j < rects.length; j++) {\n          var rect = rects[j];\n          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);\n        }\n      }\n\n      if ((i = (i + 1) % len) == startI) break;\n    }\n  }\n\n  return element;\n}\n\nfunction _posAtCoords(view, coords) {\n  var doc = view.dom.ownerDocument,\n      node,\n      offset = 0;\n\n  if (doc.caretPositionFromPoint) {\n    try {\n      var _pos = doc.caretPositionFromPoint(coords.left, coords.top);\n\n      if (_pos) {\n        node = _pos.offsetNode;\n        offset = _pos.offset;\n      }\n    } catch (_) {}\n  }\n\n  if (!node && doc.caretRangeFromPoint) {\n    var range = doc.caretRangeFromPoint(coords.left, coords.top);\n\n    if (range) {\n      node = range.startContainer;\n      offset = range.startOffset;\n    }\n  }\n\n  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top);\n  var pos;\n\n  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n    var box = view.dom.getBoundingClientRect();\n    if (!inRect(coords, box)) return null;\n    elt = elementFromPoint(view.dom, coords, box);\n    if (!elt) return null;\n  }\n\n  if (safari) {\n    for (var p = elt; node && p; p = parentNode(p)) {\n      if (p.draggable) node = undefined;\n    }\n  }\n\n  elt = targetKludge(elt, coords);\n\n  if (node) {\n    if (gecko && node.nodeType == 1) {\n      offset = Math.min(offset, node.childNodes.length);\n\n      if (offset < node.childNodes.length) {\n        var next = node.childNodes[offset],\n            _box;\n\n        if (next.nodeName == \"IMG\" && (_box = next.getBoundingClientRect()).right <= coords.left && _box.bottom > coords.top) offset++;\n      }\n    }\n\n    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\") pos = posFromCaret(view, node, offset, coords);\n  }\n\n  if (pos == null) pos = posFromElement(view, elt, coords);\n  var desc = view.docView.nearestDesc(elt, true);\n  return {\n    pos: pos,\n    inside: desc ? desc.posAtStart - desc.border : -1\n  };\n}\n\nfunction singleRect(target, bias) {\n  var rects = target.getClientRects();\n  return !rects.length ? target.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];\n}\n\nvar BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\nfunction _coordsAtPos(view, pos, side) {\n  var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1),\n      node = _view$docView$domFrom.node,\n      offset = _view$docView$domFrom.offset,\n      atom = _view$docView$domFrom.atom;\n\n  var supportEmptyRange = webkit || gecko;\n\n  if (node.nodeType == 3) {\n    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n      var rect = singleRect(textRange(node, offset, offset), side);\n\n      if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n\n        if (rectBefore.top == rect.top) {\n          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n          if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n        }\n      }\n\n      return rect;\n    } else {\n      var from = offset,\n          to = offset,\n          takeSide = side < 0 ? 1 : -1;\n\n      if (side < 0 && !offset) {\n        to++;\n        takeSide = -1;\n      } else if (side >= 0 && offset == node.nodeValue.length) {\n        from--;\n        takeSide = 1;\n      } else if (side < 0) {\n        from--;\n      } else {\n        to++;\n      }\n\n      return flattenV(singleRect(textRange(node, from, to), 1), takeSide < 0);\n    }\n  }\n\n  var $dom = view.state.doc.resolve(pos - (atom || 0));\n\n  if (!$dom.parent.inlineContent) {\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n      var before = node.childNodes[offset - 1];\n      if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);\n    }\n\n    if (atom == null && offset < nodeSize(node)) {\n      var after = node.childNodes[offset];\n      if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);\n    }\n\n    return flattenH(node.getBoundingClientRect(), side >= 0);\n  }\n\n  if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n    var _before = node.childNodes[offset - 1];\n    var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1)) : _before.nodeType == 1 && (_before.nodeName != \"BR\" || !_before.nextSibling) ? _before : null;\n    if (target) return flattenV(singleRect(target, 1), false);\n  }\n\n  if (atom == null && offset < nodeSize(node)) {\n    var _after = node.childNodes[offset];\n\n    while (_after.pmViewDesc && _after.pmViewDesc.ignoreForCoords) {\n      _after = _after.nextSibling;\n    }\n\n    var _target = !_after ? null : _after.nodeType == 3 ? textRange(_after, 0, supportEmptyRange ? 0 : 1) : _after.nodeType == 1 ? _after : null;\n\n    if (_target) return flattenV(singleRect(_target, -1), true);\n  }\n\n  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\n\nfunction flattenV(rect, left) {\n  if (rect.width == 0) return rect;\n  var x = left ? rect.left : rect.right;\n  return {\n    top: rect.top,\n    bottom: rect.bottom,\n    left: x,\n    right: x\n  };\n}\n\nfunction flattenH(rect, top) {\n  if (rect.height == 0) return rect;\n  var y = top ? rect.top : rect.bottom;\n  return {\n    top: y,\n    bottom: y,\n    left: rect.left,\n    right: rect.right\n  };\n}\n\nfunction withFlushedState(view, state, f) {\n  var viewState = view.state,\n      active = view.root.activeElement;\n  if (viewState != state) view.updateState(state);\n  if (active != view.dom) view.focus();\n\n  try {\n    return f();\n  } finally {\n    if (viewState != state) view.updateState(viewState);\n    if (active != view.dom && active) active.focus();\n  }\n}\n\nfunction endOfTextblockVertical(view, state, dir) {\n  var sel = state.selection;\n  var $pos = dir == \"up\" ? sel.$from : sel.$to;\n  return withFlushedState(view, state, function () {\n    var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1),\n        dom = _view$docView$domFrom2.node;\n\n    for (;;) {\n      var nearest = view.docView.nearestDesc(dom, true);\n      if (!nearest) break;\n\n      if (nearest.node.isBlock) {\n        dom = nearest.dom;\n        break;\n      }\n\n      dom = nearest.dom.parentNode;\n    }\n\n    var coords = _coordsAtPos(view, $pos.pos, 1);\n\n    for (var child = dom.firstChild; child; child = child.nextSibling) {\n      var boxes = void 0;\n      if (child.nodeType == 1) boxes = child.getClientRects();else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();else continue;\n\n      for (var i = 0; i < boxes.length; i++) {\n        var box = boxes[i];\n        if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;\n      }\n    }\n\n    return true;\n  });\n}\n\nvar maybeRTL = /[\\u0590-\\u08ac]/;\n\nfunction endOfTextblockHorizontal(view, state, dir) {\n  var $head = state.selection.$head;\n  if (!$head.parent.isTextblock) return false;\n  var offset = $head.parentOffset,\n      atStart = !offset,\n      atEnd = offset == $head.parent.content.size;\n  var sel = view.domSelection();\n  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n  return withFlushedState(view, state, function () {\n    var _view$domSelectionRan = view.domSelectionRange(),\n        oldNode = _view$domSelectionRan.focusNode,\n        oldOff = _view$domSelectionRan.focusOffset,\n        anchorNode = _view$domSelectionRan.anchorNode,\n        anchorOffset = _view$domSelectionRan.anchorOffset;\n\n    var oldBidiLevel = sel.caretBidiLevel;\n    sel.modify(\"move\", dir, \"character\");\n    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n\n    var _view$domSelectionRan2 = view.domSelectionRange(),\n        newNode = _view$domSelectionRan2.focusNode,\n        newOff = _view$domSelectionRan2.focusOffset;\n\n    var result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n\n    try {\n      sel.collapse(anchorNode, anchorOffset);\n      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);\n    } catch (_) {}\n\n    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;\n    return result;\n  });\n}\n\nvar cachedState = null;\nvar cachedDir = null;\nvar cachedResult = false;\n\nfunction _endOfTextblock(view, state, dir) {\n  if (cachedState == state && cachedDir == dir) return cachedResult;\n  cachedState = state;\n  cachedDir = dir;\n  return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n}\n\nvar NOT_DIRTY = 0,\n    CHILD_DIRTY = 1,\n    CONTENT_DIRTY = 2,\n    NODE_DIRTY = 3;\n\nvar ViewDesc = function () {\n  function ViewDesc(parent, children, dom, contentDOM) {\n    _classCallCheck(this, ViewDesc);\n\n    this.parent = parent;\n    this.children = children;\n    this.dom = dom;\n    this.contentDOM = contentDOM;\n    this.dirty = NOT_DIRTY;\n    dom.pmViewDesc = this;\n  }\n\n  _createClass(ViewDesc, [{\n    key: \"matchesWidget\",\n    value: function matchesWidget(widget) {\n      return false;\n    }\n  }, {\n    key: \"matchesMark\",\n    value: function matchesMark(mark) {\n      return false;\n    }\n  }, {\n    key: \"matchesNode\",\n    value: function matchesNode(node, outerDeco, innerDeco) {\n      return false;\n    }\n  }, {\n    key: \"matchesHack\",\n    value: function matchesHack(nodeName) {\n      return false;\n    }\n  }, {\n    key: \"parseRule\",\n    value: function parseRule() {\n      return null;\n    }\n  }, {\n    key: \"stopEvent\",\n    value: function stopEvent(event) {\n      return false;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      var size = 0;\n\n      for (var i = 0; i < this.children.length; i++) {\n        size += this.children[i].size;\n      }\n\n      return size;\n    }\n  }, {\n    key: \"border\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.parent = undefined;\n      if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;\n\n      for (var i = 0; i < this.children.length; i++) {\n        this.children[i].destroy();\n      }\n    }\n  }, {\n    key: \"posBeforeChild\",\n    value: function posBeforeChild(child) {\n      for (var i = 0, pos = this.posAtStart;; i++) {\n        var cur = this.children[i];\n        if (cur == child) return pos;\n        pos += cur.size;\n      }\n    }\n  }, {\n    key: \"posBefore\",\n    get: function get() {\n      return this.parent.posBeforeChild(this);\n    }\n  }, {\n    key: \"posAtStart\",\n    get: function get() {\n      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n  }, {\n    key: \"posAfter\",\n    get: function get() {\n      return this.posBefore + this.size;\n    }\n  }, {\n    key: \"posAtEnd\",\n    get: function get() {\n      return this.posAtStart + this.size - 2 * this.border;\n    }\n  }, {\n    key: \"localPosFromDOM\",\n    value: function localPosFromDOM(dom, offset, bias) {\n      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n        if (bias < 0) {\n          var domBefore, desc;\n\n          if (dom == this.contentDOM) {\n            domBefore = dom.childNodes[offset - 1];\n          } else {\n            while (dom.parentNode != this.contentDOM) {\n              dom = dom.parentNode;\n            }\n\n            domBefore = dom.previousSibling;\n          }\n\n          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {\n            domBefore = domBefore.previousSibling;\n          }\n\n          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n        } else {\n          var domAfter, _desc;\n\n          if (dom == this.contentDOM) {\n            domAfter = dom.childNodes[offset];\n          } else {\n            while (dom.parentNode != this.contentDOM) {\n              dom = dom.parentNode;\n            }\n\n            domAfter = dom.nextSibling;\n          }\n\n          while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this)) {\n            domAfter = domAfter.nextSibling;\n          }\n\n          return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;\n        }\n      }\n\n      var atEnd;\n\n      if (dom == this.dom && this.contentDOM) {\n        atEnd = offset > domIndex(this.contentDOM);\n      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n      } else if (this.dom.firstChild) {\n        if (offset == 0) for (var search = dom;; search = search.parentNode) {\n          if (search == this.dom) {\n            atEnd = false;\n            break;\n          }\n\n          if (search.previousSibling) break;\n        }\n        if (atEnd == null && offset == dom.childNodes.length) for (var _search = dom;; _search = _search.parentNode) {\n          if (_search == this.dom) {\n            atEnd = true;\n            break;\n          }\n\n          if (_search.nextSibling) break;\n        }\n      }\n\n      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n  }, {\n    key: \"nearestDesc\",\n    value: function nearestDesc(dom) {\n      var onlyNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      for (var first = true, cur = dom; cur; cur = cur.parentNode) {\n        var desc = this.getDesc(cur),\n            nodeDOM = void 0;\n\n        if (desc && (!onlyNodes || desc.node)) {\n          if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;else return desc;\n        }\n      }\n    }\n  }, {\n    key: \"getDesc\",\n    value: function getDesc(dom) {\n      var desc = dom.pmViewDesc;\n\n      for (var cur = desc; cur; cur = cur.parent) {\n        if (cur == this) return desc;\n      }\n    }\n  }, {\n    key: \"posFromDOM\",\n    value: function posFromDOM(dom, offset, bias) {\n      for (var scan = dom; scan; scan = scan.parentNode) {\n        var desc = this.getDesc(scan);\n        if (desc) return desc.localPosFromDOM(dom, offset, bias);\n      }\n\n      return -1;\n    }\n  }, {\n    key: \"descAt\",\n    value: function descAt(pos) {\n      for (var i = 0, offset = 0; i < this.children.length; i++) {\n        var child = this.children[i],\n            end = offset + child.size;\n\n        if (offset == pos && end != offset) {\n          while (!child.border && child.children.length) {\n            child = child.children[0];\n          }\n\n          return child;\n        }\n\n        if (pos < end) return child.descAt(pos - offset - child.border);\n        offset = end;\n      }\n    }\n  }, {\n    key: \"domFromPos\",\n    value: function domFromPos(pos, side) {\n      if (!this.contentDOM) return {\n        node: this.dom,\n        offset: 0,\n        atom: pos + 1\n      };\n      var i = 0,\n          offset = 0;\n\n      for (var curPos = 0; i < this.children.length; i++) {\n        var child = this.children[i],\n            end = curPos + child.size;\n\n        if (end > pos || child instanceof TrailingHackViewDesc) {\n          offset = pos - curPos;\n          break;\n        }\n\n        curPos = end;\n      }\n\n      if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);\n\n      for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {}\n\n      if (side <= 0) {\n        var _prev,\n            enter = true;\n\n        for (;; i--, enter = false) {\n          _prev = i ? this.children[i - 1] : null;\n          if (!_prev || _prev.dom.parentNode == this.contentDOM) break;\n        }\n\n        if (_prev && side && enter && !_prev.border && !_prev.domAtom) return _prev.domFromPos(_prev.size, side);\n        return {\n          node: this.contentDOM,\n          offset: _prev ? domIndex(_prev.dom) + 1 : 0\n        };\n      } else {\n        var next,\n            _enter = true;\n\n        for (;; i++, _enter = false) {\n          next = i < this.children.length ? this.children[i] : null;\n          if (!next || next.dom.parentNode == this.contentDOM) break;\n        }\n\n        if (next && _enter && !next.border && !next.domAtom) return next.domFromPos(0, side);\n        return {\n          node: this.contentDOM,\n          offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length\n        };\n      }\n    }\n  }, {\n    key: \"parseRange\",\n    value: function parseRange(from, to) {\n      var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      if (this.children.length == 0) return {\n        node: this.contentDOM,\n        from: from,\n        to: to,\n        fromOffset: 0,\n        toOffset: this.contentDOM.childNodes.length\n      };\n      var fromOffset = -1,\n          toOffset = -1;\n\n      for (var offset = base, i = 0;; i++) {\n        var child = this.children[i],\n            end = offset + child.size;\n\n        if (fromOffset == -1 && from <= end) {\n          var childBase = offset + child.border;\n          if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);\n          from = offset;\n\n          for (var j = i; j > 0; j--) {\n            var prev = this.children[j - 1];\n\n            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n              fromOffset = domIndex(prev.dom) + 1;\n              break;\n            }\n\n            from -= prev.size;\n          }\n\n          if (fromOffset == -1) fromOffset = 0;\n        }\n\n        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n          to = end;\n\n          for (var _j = i + 1; _j < this.children.length; _j++) {\n            var next = this.children[_j];\n\n            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n              toOffset = domIndex(next.dom);\n              break;\n            }\n\n            to += next.size;\n          }\n\n          if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;\n          break;\n        }\n\n        offset = end;\n      }\n\n      return {\n        node: this.contentDOM,\n        from: from,\n        to: to,\n        fromOffset: fromOffset,\n        toOffset: toOffset\n      };\n    }\n  }, {\n    key: \"emptyChildAt\",\n    value: function emptyChildAt(side) {\n      if (this.border || !this.contentDOM || !this.children.length) return false;\n      var child = this.children[side < 0 ? 0 : this.children.length - 1];\n      return child.size == 0 || child.emptyChildAt(side);\n    }\n  }, {\n    key: \"domAfterPos\",\n    value: function domAfterPos(pos) {\n      var _this$domFromPos = this.domFromPos(pos, 0),\n          node = _this$domFromPos.node,\n          offset = _this$domFromPos.offset;\n\n      if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError(\"No node after pos \" + pos);\n      return node.childNodes[offset];\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(anchor, head, root) {\n      var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var from = Math.min(anchor, head),\n          to = Math.max(anchor, head);\n\n      for (var i = 0, offset = 0; i < this.children.length; i++) {\n        var child = this.children[i],\n            end = offset + child.size;\n        if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);\n        offset = end;\n      }\n\n      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n      var domSel = root.getSelection();\n      var brKludge = false;\n\n      if ((gecko || safari) && anchor == head) {\n        var _anchorDOM = anchorDOM,\n            node = _anchorDOM.node,\n            _offset = _anchorDOM.offset;\n\n        if (node.nodeType == 3) {\n          brKludge = !!(_offset && node.nodeValue[_offset - 1] == \"\\n\");\n\n          if (brKludge && _offset == node.nodeValue.length) {\n            for (var scan = node, after; scan; scan = scan.parentNode) {\n              if (after = scan.nextSibling) {\n                if (after.nodeName == \"BR\") anchorDOM = headDOM = {\n                  node: after.parentNode,\n                  offset: domIndex(after) + 1\n                };\n                break;\n              }\n\n              var desc = scan.pmViewDesc;\n              if (desc && desc.node && desc.node.isBlock) break;\n            }\n          }\n        } else {\n          var prev = node.childNodes[_offset - 1];\n          brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n        }\n      }\n\n      if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {\n        var _after2 = domSel.focusNode.childNodes[domSel.focusOffset];\n        if (_after2 && _after2.contentEditable == \"false\") force = true;\n      }\n\n      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) return;\n      var domSelExtended = false;\n\n      if ((domSel.extend || anchor == head) && !brKludge) {\n        domSel.collapse(anchorDOM.node, anchorDOM.offset);\n\n        try {\n          if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);\n          domSelExtended = true;\n        } catch (_) {}\n      }\n\n      if (!domSelExtended) {\n        if (anchor > head) {\n          var tmp = anchorDOM;\n          anchorDOM = headDOM;\n          headDOM = tmp;\n        }\n\n        var range = document.createRange();\n        range.setEnd(headDOM.node, headDOM.offset);\n        range.setStart(anchorDOM.node, anchorDOM.offset);\n        domSel.removeAllRanges();\n        domSel.addRange(range);\n      }\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation(mutation) {\n      return !this.contentDOM && mutation.type != \"selection\";\n    }\n  }, {\n    key: \"contentLost\",\n    get: function get() {\n      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n  }, {\n    key: \"markDirty\",\n    value: function markDirty(from, to) {\n      for (var offset = 0, i = 0; i < this.children.length; i++) {\n        var child = this.children[i],\n            end = offset + child.size;\n\n        if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n          var startInside = offset + child.border,\n              endInside = end - child.border;\n\n          if (from >= startInside && to <= endInside) {\n            this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;else child.markDirty(from - startInside, to - startInside);\n            return;\n          } else {\n            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n          }\n        }\n\n        offset = end;\n      }\n\n      this.dirty = CONTENT_DIRTY;\n    }\n  }, {\n    key: \"markParentsDirty\",\n    value: function markParentsDirty() {\n      var level = 1;\n\n      for (var node = this.parent; node; node = node.parent, level++) {\n        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n        if (node.dirty < dirty) node.dirty = dirty;\n      }\n    }\n  }, {\n    key: \"domAtom\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"ignoreForCoords\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return ViewDesc;\n}();\n\nvar WidgetViewDesc = function (_ViewDesc) {\n  _inherits(WidgetViewDesc, _ViewDesc);\n\n  var _super = _createSuper(WidgetViewDesc);\n\n  function WidgetViewDesc(parent, widget, view, pos) {\n    var _this;\n\n    _classCallCheck(this, WidgetViewDesc);\n\n    var self,\n        dom = widget.type.toDOM;\n    if (typeof dom == \"function\") dom = dom(view, function () {\n      if (!self) return pos;\n      if (self.parent) return self.parent.posBeforeChild(self);\n    });\n\n    if (!widget.type.spec.raw) {\n      if (dom.nodeType != 1) {\n        var wrap = document.createElement(\"span\");\n        wrap.appendChild(dom);\n        dom = wrap;\n      }\n\n      dom.contentEditable = \"false\";\n      dom.classList.add(\"ProseMirror-widget\");\n    }\n\n    _this = _super.call(this, parent, [], dom, null);\n    _this.widget = widget;\n    _this.widget = widget;\n    self = _assertThisInitialized(_this);\n    return _this;\n  }\n\n  _createClass(WidgetViewDesc, [{\n    key: \"matchesWidget\",\n    value: function matchesWidget(widget) {\n      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n  }, {\n    key: \"parseRule\",\n    value: function parseRule() {\n      return {\n        ignore: true\n      };\n    }\n  }, {\n    key: \"stopEvent\",\n    value: function stopEvent(event) {\n      var stop = this.widget.spec.stopEvent;\n      return stop ? stop(event) : false;\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation(mutation) {\n      return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.widget.type.destroy(this.dom);\n\n      _get(_getPrototypeOf(WidgetViewDesc.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"domAtom\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"side\",\n    get: function get() {\n      return this.widget.type.side;\n    }\n  }]);\n\n  return WidgetViewDesc;\n}(ViewDesc);\n\nvar CompositionViewDesc = function (_ViewDesc2) {\n  _inherits(CompositionViewDesc, _ViewDesc2);\n\n  var _super2 = _createSuper(CompositionViewDesc);\n\n  function CompositionViewDesc(parent, dom, textDOM, text) {\n    var _this2;\n\n    _classCallCheck(this, CompositionViewDesc);\n\n    _this2 = _super2.call(this, parent, [], dom, null);\n    _this2.textDOM = textDOM;\n    _this2.text = text;\n    return _this2;\n  }\n\n  _createClass(CompositionViewDesc, [{\n    key: \"size\",\n    get: function get() {\n      return this.text.length;\n    }\n  }, {\n    key: \"localPosFromDOM\",\n    value: function localPosFromDOM(dom, offset) {\n      if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);\n      return this.posAtStart + offset;\n    }\n  }, {\n    key: \"domFromPos\",\n    value: function domFromPos(pos) {\n      return {\n        node: this.textDOM,\n        offset: pos\n      };\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation(mut) {\n      return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;\n    }\n  }]);\n\n  return CompositionViewDesc;\n}(ViewDesc);\n\nvar MarkViewDesc = function (_ViewDesc3) {\n  _inherits(MarkViewDesc, _ViewDesc3);\n\n  var _super3 = _createSuper(MarkViewDesc);\n\n  function MarkViewDesc(parent, mark, dom, contentDOM) {\n    var _this3;\n\n    _classCallCheck(this, MarkViewDesc);\n\n    _this3 = _super3.call(this, parent, [], dom, contentDOM);\n    _this3.mark = mark;\n    return _this3;\n  }\n\n  _createClass(MarkViewDesc, [{\n    key: \"parseRule\",\n    value: function parseRule() {\n      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;\n      return {\n        mark: this.mark.type.name,\n        attrs: this.mark.attrs,\n        contentElement: this.contentDOM || undefined\n      };\n    }\n  }, {\n    key: \"matchesMark\",\n    value: function matchesMark(mark) {\n      return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n    }\n  }, {\n    key: \"markDirty\",\n    value: function markDirty(from, to) {\n      _get(_getPrototypeOf(MarkViewDesc.prototype), \"markDirty\", this).call(this, from, to);\n\n      if (this.dirty != NOT_DIRTY) {\n        var parent = this.parent;\n\n        while (!parent.node) {\n          parent = parent.parent;\n        }\n\n        if (parent.dirty < this.dirty) parent.dirty = this.dirty;\n        this.dirty = NOT_DIRTY;\n      }\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(from, to, view) {\n      var copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n      var nodes = this.children,\n          size = this.size;\n      if (to < size) nodes = replaceNodes(nodes, to, size, view);\n      if (from > 0) nodes = replaceNodes(nodes, 0, from, view);\n\n      for (var i = 0; i < nodes.length; i++) {\n        nodes[i].parent = copy;\n      }\n\n      copy.children = nodes;\n      return copy;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(parent, mark, inline, view) {\n      var custom = view.nodeViews[mark.type.name];\n      var spec = custom && custom(mark, view, inline);\n      if (!spec || !spec.dom) spec = prosemirrorModel.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));\n      return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);\n    }\n  }]);\n\n  return MarkViewDesc;\n}(ViewDesc);\n\nvar NodeViewDesc = function (_ViewDesc4) {\n  _inherits(NodeViewDesc, _ViewDesc4);\n\n  var _super4 = _createSuper(NodeViewDesc);\n\n  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n    var _this4;\n\n    _classCallCheck(this, NodeViewDesc);\n\n    _this4 = _super4.call(this, parent, [], dom, contentDOM);\n    _this4.node = node;\n    _this4.outerDeco = outerDeco;\n    _this4.innerDeco = innerDeco;\n    _this4.nodeDOM = nodeDOM;\n    if (contentDOM) _this4.updateChildren(view, pos);\n    return _this4;\n  }\n\n  _createClass(NodeViewDesc, [{\n    key: \"parseRule\",\n    value: function parseRule() {\n      var _this5 = this;\n\n      if (this.node.type.spec.reparseInView) return null;\n      var rule = {\n        node: this.node.type.name,\n        attrs: this.node.attrs\n      };\n      if (this.node.type.whitespace == \"pre\") rule.preserveWhitespace = \"full\";\n\n      if (!this.contentDOM) {\n        rule.getContent = function () {\n          return _this5.node.content;\n        };\n      } else if (!this.contentLost) {\n        rule.contentElement = this.contentDOM;\n      } else {\n        for (var i = this.children.length - 1; i >= 0; i--) {\n          var child = this.children[i];\n\n          if (this.dom.contains(child.dom.parentNode)) {\n            rule.contentElement = child.dom.parentNode;\n            break;\n          }\n        }\n\n        if (!rule.contentElement) rule.getContent = function () {\n          return prosemirrorModel.Fragment.empty;\n        };\n      }\n\n      return rule;\n    }\n  }, {\n    key: \"matchesNode\",\n    value: function matchesNode(node, outerDeco, innerDeco) {\n      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.node.nodeSize;\n    }\n  }, {\n    key: \"border\",\n    get: function get() {\n      return this.node.isLeaf ? 0 : 1;\n    }\n  }, {\n    key: \"updateChildren\",\n    value: function updateChildren(view, pos) {\n      var _this6 = this;\n\n      var inline = this.node.inlineContent,\n          off = pos;\n      var composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n      var localComposition = composition && composition.pos > -1 ? composition : null;\n      var compositionInChild = composition && composition.pos < 0;\n      var updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n      iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {\n        if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == _this6.node.childCount ? prosemirrorModel.Mark.none : _this6.node.child(i).marks, inline, view);\n        updater.placeWidget(widget, view, off);\n      }, function (child, outerDeco, innerDeco, i) {\n        updater.syncToMarks(child.marks, inline, view);\n        var compIndex;\n        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ;else {\n          updater.addNode(child, outerDeco, innerDeco, view, off);\n        }\n        off += child.nodeSize;\n      });\n      updater.syncToMarks([], inline, view);\n      if (this.node.isTextblock) updater.addTextblockHacks();\n      updater.destroyRest();\n\n      if (updater.changed || this.dirty == CONTENT_DIRTY) {\n        if (localComposition) this.protectLocalComposition(view, localComposition);\n        renderDescs(this.contentDOM, this.children, view);\n        if (ios) iosHacks(this.dom);\n      }\n    }\n  }, {\n    key: \"localCompositionInfo\",\n    value: function localCompositionInfo(view, pos) {\n      var _view$state$selection = view.state.selection,\n          from = _view$state$selection.from,\n          to = _view$state$selection.to;\n      if (!(view.state.selection instanceof prosemirrorState.TextSelection) || from < pos || to > pos + this.node.content.size) return null;\n      var sel = view.domSelectionRange();\n      var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);\n      if (!textNode || !this.dom.contains(textNode.parentNode)) return null;\n\n      if (this.node.inlineContent) {\n        var text = textNode.nodeValue;\n        var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n        return textPos < 0 ? null : {\n          node: textNode,\n          pos: textPos,\n          text: text\n        };\n      } else {\n        return {\n          node: textNode,\n          pos: -1,\n          text: \"\"\n        };\n      }\n    }\n  }, {\n    key: \"protectLocalComposition\",\n    value: function protectLocalComposition(view, _ref2) {\n      var node = _ref2.node,\n          pos = _ref2.pos,\n          text = _ref2.text;\n      if (this.getDesc(node)) return;\n      var topNode = node;\n\n      for (;; topNode = topNode.parentNode) {\n        if (topNode.parentNode == this.contentDOM) break;\n\n        while (topNode.previousSibling) {\n          topNode.parentNode.removeChild(topNode.previousSibling);\n        }\n\n        while (topNode.nextSibling) {\n          topNode.parentNode.removeChild(topNode.nextSibling);\n        }\n\n        if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;\n      }\n\n      var desc = new CompositionViewDesc(this, topNode, node, text);\n      view.input.compositionNodes.push(desc);\n      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n  }, {\n    key: \"update\",\n    value: function update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;\n      this.updateInner(node, outerDeco, innerDeco, view);\n      return true;\n    }\n  }, {\n    key: \"updateInner\",\n    value: function updateInner(node, outerDeco, innerDeco, view) {\n      this.updateOuterDeco(outerDeco);\n      this.node = node;\n      this.innerDeco = innerDeco;\n      if (this.contentDOM) this.updateChildren(view, this.posAtStart);\n      this.dirty = NOT_DIRTY;\n    }\n  }, {\n    key: \"updateOuterDeco\",\n    value: function updateOuterDeco(outerDeco) {\n      if (sameOuterDeco(outerDeco, this.outerDeco)) return;\n      var needsWrap = this.nodeDOM.nodeType != 1;\n      var oldDOM = this.dom;\n      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n\n      if (this.dom != oldDOM) {\n        oldDOM.pmViewDesc = undefined;\n        this.dom.pmViewDesc = this;\n      }\n\n      this.outerDeco = outerDeco;\n    }\n  }, {\n    key: \"selectNode\",\n    value: function selectNode() {\n      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;\n    }\n  }, {\n    key: \"deselectNode\",\n    value: function deselectNode() {\n      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute(\"draggable\");\n    }\n  }, {\n    key: \"domAtom\",\n    get: function get() {\n      return this.node.isAtom;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(parent, node, outerDeco, innerDeco, view, pos) {\n      var custom = view.nodeViews[node.type.name],\n          descObj;\n      var spec = custom && custom(node, view, function () {\n        if (!descObj) return pos;\n        if (descObj.parent) return descObj.parent.posBeforeChild(descObj);\n      }, outerDeco, innerDeco);\n      var dom = spec && spec.dom,\n          contentDOM = spec && spec.contentDOM;\n\n      if (node.isText) {\n        if (!dom) dom = document.createTextNode(node.text);else if (dom.nodeType != 3) throw new RangeError(\"Text must be rendered as a DOM text node\");\n      } else if (!dom) {\n        var _prosemirrorModel$DOM = prosemirrorModel.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node));\n\n        dom = _prosemirrorModel$DOM.dom;\n        contentDOM = _prosemirrorModel$DOM.contentDOM;\n      }\n\n      if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n        if (!dom.hasAttribute(\"contenteditable\")) dom.contentEditable = \"false\";\n        if (node.type.spec.draggable) dom.draggable = true;\n      }\n\n      var nodeDOM = dom;\n      dom = applyOuterDeco(dom, outerDeco, node);\n      if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n  }]);\n\n  return NodeViewDesc;\n}(ViewDesc);\n\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n  applyOuterDeco(dom, outerDeco, doc);\n  return new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n}\n\nvar TextViewDesc = function (_NodeViewDesc) {\n  _inherits(TextViewDesc, _NodeViewDesc);\n\n  var _super5 = _createSuper(TextViewDesc);\n\n  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n    _classCallCheck(this, TextViewDesc);\n\n    return _super5.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n  }\n\n  _createClass(TextViewDesc, [{\n    key: \"parseRule\",\n    value: function parseRule() {\n      var skip = this.nodeDOM.parentNode;\n\n      while (skip && skip != this.dom && !skip.pmIsDeco) {\n        skip = skip.parentNode;\n      }\n\n      return {\n        skip: skip || true\n      };\n    }\n  }, {\n    key: \"update\",\n    value: function update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;\n      this.updateOuterDeco(outerDeco);\n\n      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n        this.nodeDOM.nodeValue = node.text;\n        if (view.trackWrites == this.nodeDOM) view.trackWrites = null;\n      }\n\n      this.node = node;\n      this.dirty = NOT_DIRTY;\n      return true;\n    }\n  }, {\n    key: \"inParent\",\n    value: function inParent() {\n      var parentDOM = this.parent.contentDOM;\n\n      for (var n = this.nodeDOM; n; n = n.parentNode) {\n        if (n == parentDOM) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"domFromPos\",\n    value: function domFromPos(pos) {\n      return {\n        node: this.nodeDOM,\n        offset: pos\n      };\n    }\n  }, {\n    key: \"localPosFromDOM\",\n    value: function localPosFromDOM(dom, offset, bias) {\n      if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);\n      return _get(_getPrototypeOf(TextViewDesc.prototype), \"localPosFromDOM\", this).call(this, dom, offset, bias);\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation(mutation) {\n      return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n  }, {\n    key: \"slice\",\n    value: function slice(from, to, view) {\n      var node = this.node.cut(from, to),\n          dom = document.createTextNode(node.text);\n      return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n  }, {\n    key: \"markDirty\",\n    value: function markDirty(from, to) {\n      _get(_getPrototypeOf(TextViewDesc.prototype), \"markDirty\", this).call(this, from, to);\n\n      if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;\n    }\n  }, {\n    key: \"domAtom\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return TextViewDesc;\n}(NodeViewDesc);\n\nvar TrailingHackViewDesc = function (_ViewDesc5) {\n  _inherits(TrailingHackViewDesc, _ViewDesc5);\n\n  var _super6 = _createSuper(TrailingHackViewDesc);\n\n  function TrailingHackViewDesc() {\n    _classCallCheck(this, TrailingHackViewDesc);\n\n    return _super6.apply(this, arguments);\n  }\n\n  _createClass(TrailingHackViewDesc, [{\n    key: \"parseRule\",\n    value: function parseRule() {\n      return {\n        ignore: true\n      };\n    }\n  }, {\n    key: \"matchesHack\",\n    value: function matchesHack(nodeName) {\n      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n    }\n  }, {\n    key: \"domAtom\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"ignoreForCoords\",\n    get: function get() {\n      return this.dom.nodeName == \"IMG\";\n    }\n  }]);\n\n  return TrailingHackViewDesc;\n}(ViewDesc);\n\nvar CustomNodeViewDesc = function (_NodeViewDesc2) {\n  _inherits(CustomNodeViewDesc, _NodeViewDesc2);\n\n  var _super7 = _createSuper(CustomNodeViewDesc);\n\n  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n    var _this7;\n\n    _classCallCheck(this, CustomNodeViewDesc);\n\n    _this7 = _super7.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n    _this7.spec = spec;\n    return _this7;\n  }\n\n  _createClass(CustomNodeViewDesc, [{\n    key: \"update\",\n    value: function update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY) return false;\n\n      if (this.spec.update) {\n        var result = this.spec.update(node, outerDeco, innerDeco);\n        if (result) this.updateInner(node, outerDeco, innerDeco, view);\n        return result;\n      } else if (!this.contentDOM && !node.isLeaf) {\n        return false;\n      } else {\n        return _get(_getPrototypeOf(CustomNodeViewDesc.prototype), \"update\", this).call(this, node, outerDeco, innerDeco, view);\n      }\n    }\n  }, {\n    key: \"selectNode\",\n    value: function selectNode() {\n      this.spec.selectNode ? this.spec.selectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), \"selectNode\", this).call(this);\n    }\n  }, {\n    key: \"deselectNode\",\n    value: function deselectNode() {\n      this.spec.deselectNode ? this.spec.deselectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), \"deselectNode\", this).call(this);\n    }\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(anchor, head, root, force) {\n      this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), \"setSelection\", this).call(this, anchor, head, root, force);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.spec.destroy) this.spec.destroy();\n\n      _get(_getPrototypeOf(CustomNodeViewDesc.prototype), \"destroy\", this).call(this);\n    }\n  }, {\n    key: \"stopEvent\",\n    value: function stopEvent(event) {\n      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n  }, {\n    key: \"ignoreMutation\",\n    value: function ignoreMutation(mutation) {\n      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), \"ignoreMutation\", this).call(this, mutation);\n    }\n  }]);\n\n  return CustomNodeViewDesc;\n}(NodeViewDesc);\n\nfunction renderDescs(parentDOM, descs, view) {\n  var dom = parentDOM.firstChild,\n      written = false;\n\n  for (var i = 0; i < descs.length; i++) {\n    var desc = descs[i],\n        childDOM = desc.dom;\n\n    if (childDOM.parentNode == parentDOM) {\n      while (childDOM != dom) {\n        dom = rm(dom);\n        written = true;\n      }\n\n      dom = dom.nextSibling;\n    } else {\n      written = true;\n      parentDOM.insertBefore(childDOM, dom);\n    }\n\n    if (desc instanceof MarkViewDesc) {\n      var pos = dom ? dom.previousSibling : parentDOM.lastChild;\n      renderDescs(desc.contentDOM, desc.children, view);\n      dom = pos ? pos.nextSibling : parentDOM.firstChild;\n    }\n  }\n\n  while (dom) {\n    dom = rm(dom);\n    written = true;\n  }\n\n  if (written && view.trackWrites == parentDOM) view.trackWrites = null;\n}\n\nvar OuterDecoLevel = function OuterDecoLevel(nodeName) {\n  if (nodeName) this.nodeName = nodeName;\n};\n\nOuterDecoLevel.prototype = Object.create(null);\nvar noDeco = [new OuterDecoLevel()];\n\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n  if (outerDeco.length == 0) return noDeco;\n  var top = needsWrap ? noDeco[0] : new OuterDecoLevel(),\n      result = [top];\n\n  for (var i = 0; i < outerDeco.length; i++) {\n    var attrs = outerDeco[i].type.attrs;\n    if (!attrs) continue;\n    if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));\n\n    for (var name in attrs) {\n      var val = attrs[name];\n      if (val == null) continue;\n      if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n      if (name == \"class\") top[\"class\"] = (top[\"class\"] ? top[\"class\"] + \" \" : \"\") + val;else if (name == \"style\") top.style = (top.style ? top.style + \";\" : \"\") + val;else if (name != \"nodeName\") top[name] = val;\n    }\n  }\n\n  return result;\n}\n\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;\n  var curDOM = nodeDOM;\n\n  for (var i = 0; i < curComputed.length; i++) {\n    var deco = curComputed[i],\n        prev = prevComputed[i];\n\n    if (i) {\n      var parent = void 0;\n\n      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n        curDOM = parent;\n      } else {\n        parent = document.createElement(deco.nodeName);\n        parent.pmIsDeco = true;\n        parent.appendChild(curDOM);\n        prev = noDeco[0];\n        curDOM = parent;\n      }\n    }\n\n    patchAttributes(curDOM, prev || noDeco[0], deco);\n  }\n\n  return curDOM;\n}\n\nfunction patchAttributes(dom, prev, cur) {\n  for (var name in prev) {\n    if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur)) dom.removeAttribute(name);\n  }\n\n  for (var _name in cur) {\n    if (_name != \"class\" && _name != \"style\" && _name != \"nodeName\" && cur[_name] != prev[_name]) dom.setAttribute(_name, cur[_name]);\n  }\n\n  if (prev[\"class\"] != cur[\"class\"]) {\n    var prevList = prev[\"class\"] ? prev[\"class\"].split(\" \").filter(Boolean) : [];\n    var curList = cur[\"class\"] ? cur[\"class\"].split(\" \").filter(Boolean) : [];\n\n    for (var i = 0; i < prevList.length; i++) {\n      if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);\n    }\n\n    for (var _i = 0; _i < curList.length; _i++) {\n      if (prevList.indexOf(curList[_i]) == -1) dom.classList.add(curList[_i]);\n    }\n\n    if (dom.classList.length == 0) dom.removeAttribute(\"class\");\n  }\n\n  if (prev.style != cur.style) {\n    if (prev.style) {\n      var prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g,\n          m;\n\n      while (m = prop.exec(prev.style)) {\n        dom.style.removeProperty(m[1]);\n      }\n    }\n\n    if (cur.style) dom.style.cssText += cur.style;\n  }\n}\n\nfunction applyOuterDeco(dom, deco, node) {\n  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\n\nfunction sameOuterDeco(a, b) {\n  if (a.length != b.length) return false;\n\n  for (var i = 0; i < a.length; i++) {\n    if (!a[i].type.eq(b[i].type)) return false;\n  }\n\n  return true;\n}\n\nfunction rm(dom) {\n  var next = dom.nextSibling;\n  dom.parentNode.removeChild(dom);\n  return next;\n}\n\nvar ViewTreeUpdater = function () {\n  function ViewTreeUpdater(top, lock, view) {\n    _classCallCheck(this, ViewTreeUpdater);\n\n    this.lock = lock;\n    this.view = view;\n    this.index = 0;\n    this.stack = [];\n    this.changed = false;\n    this.top = top;\n    this.preMatch = preMatch(top.node.content, top);\n  }\n\n  _createClass(ViewTreeUpdater, [{\n    key: \"destroyBetween\",\n    value: function destroyBetween(start, end) {\n      if (start == end) return;\n\n      for (var i = start; i < end; i++) {\n        this.top.children[i].destroy();\n      }\n\n      this.top.children.splice(start, end - start);\n      this.changed = true;\n    }\n  }, {\n    key: \"destroyRest\",\n    value: function destroyRest() {\n      this.destroyBetween(this.index, this.top.children.length);\n    }\n  }, {\n    key: \"syncToMarks\",\n    value: function syncToMarks(marks, inline, view) {\n      var keep = 0,\n          depth = this.stack.length >> 1;\n      var maxKeep = Math.min(depth, marks.length);\n\n      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) {\n        keep++;\n      }\n\n      while (keep < depth) {\n        this.destroyRest();\n        this.top.dirty = NOT_DIRTY;\n        this.index = this.stack.pop();\n        this.top = this.stack.pop();\n        depth--;\n      }\n\n      while (depth < marks.length) {\n        this.stack.push(this.top, this.index + 1);\n        var found = -1;\n\n        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n          if (this.top.children[i].matchesMark(marks[depth])) {\n            found = i;\n            break;\n          }\n        }\n\n        if (found > -1) {\n          if (found > this.index) {\n            this.changed = true;\n            this.destroyBetween(this.index, found);\n          }\n\n          this.top = this.top.children[this.index];\n        } else {\n          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n          this.top.children.splice(this.index, 0, markDesc);\n          this.top = markDesc;\n          this.changed = true;\n        }\n\n        this.index = 0;\n        depth++;\n      }\n    }\n  }, {\n    key: \"findNodeMatch\",\n    value: function findNodeMatch(node, outerDeco, innerDeco, index) {\n      var found = -1,\n          targetDesc;\n\n      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n        found = this.top.children.indexOf(targetDesc, this.index);\n      } else {\n        for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n          var child = this.top.children[i];\n\n          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n            found = i;\n            break;\n          }\n        }\n      }\n\n      if (found < 0) return false;\n      this.destroyBetween(this.index, found);\n      this.index++;\n      return true;\n    }\n  }, {\n    key: \"updateNodeAt\",\n    value: function updateNodeAt(node, outerDeco, innerDeco, index, view) {\n      var child = this.top.children[index];\n      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;\n      if (!child.update(node, outerDeco, innerDeco, view)) return false;\n      this.destroyBetween(this.index, index);\n      this.index++;\n      return true;\n    }\n  }, {\n    key: \"findIndexWithChild\",\n    value: function findIndexWithChild(domNode) {\n      for (;;) {\n        var parent = domNode.parentNode;\n        if (!parent) return -1;\n\n        if (parent == this.top.contentDOM) {\n          var desc = domNode.pmViewDesc;\n          if (desc) for (var i = this.index; i < this.top.children.length; i++) {\n            if (this.top.children[i] == desc) return i;\n          }\n          return -1;\n        }\n\n        domNode = parent;\n      }\n    }\n  }, {\n    key: \"updateNextNode\",\n    value: function updateNextNode(node, outerDeco, innerDeco, view, index) {\n      for (var i = this.index; i < this.top.children.length; i++) {\n        var next = this.top.children[i];\n\n        if (next instanceof NodeViewDesc) {\n          var _preMatch = this.preMatch.matched.get(next);\n\n          if (_preMatch != null && _preMatch != index) return false;\n          var nextDOM = next.dom;\n          var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n\n          if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n            this.destroyBetween(this.index, i);\n            if (next.dom != nextDOM) this.changed = true;\n            this.index++;\n            return true;\n          }\n\n          break;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node, outerDeco, innerDeco, view, pos) {\n      this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));\n      this.changed = true;\n    }\n  }, {\n    key: \"placeWidget\",\n    value: function placeWidget(widget, view, pos) {\n      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n\n      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n        this.index++;\n      } else {\n        var desc = new WidgetViewDesc(this.top, widget, view, pos);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n      }\n    }\n  }, {\n    key: \"addTextblockHacks\",\n    value: function addTextblockHacks() {\n      var lastChild = this.top.children[this.index - 1],\n          parent = this.top;\n\n      while (lastChild instanceof MarkViewDesc) {\n        parent = lastChild;\n        lastChild = parent.children[parent.children.length - 1];\n      }\n\n      if (!lastChild || !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\") this.addHackNode(\"IMG\", parent);\n        this.addHackNode(\"BR\", this.top);\n      }\n    }\n  }, {\n    key: \"addHackNode\",\n    value: function addHackNode(nodeName, parent) {\n      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n        this.index++;\n      } else {\n        var dom = document.createElement(nodeName);\n\n        if (nodeName == \"IMG\") {\n          dom.className = \"ProseMirror-separator\";\n          dom.alt = \"\";\n        }\n\n        if (nodeName == \"BR\") dom.className = \"ProseMirror-trailingBreak\";\n        var hack = new TrailingHackViewDesc(this.top, [], dom, null);\n        if (parent != this.top) parent.children.push(hack);else parent.children.splice(this.index++, 0, hack);\n        this.changed = true;\n      }\n    }\n  }]);\n\n  return ViewTreeUpdater;\n}();\n\nfunction preMatch(frag, parentDesc) {\n  var curDesc = parentDesc,\n      descI = curDesc.children.length;\n  var fI = frag.childCount,\n      matched = new Map(),\n      matches = [];\n\n  outer: while (fI > 0) {\n    var desc = void 0;\n\n    for (;;) {\n      if (descI) {\n        var next = curDesc.children[descI - 1];\n\n        if (next instanceof MarkViewDesc) {\n          curDesc = next;\n          descI = next.children.length;\n        } else {\n          desc = next;\n          descI--;\n          break;\n        }\n      } else if (curDesc == parentDesc) {\n        break outer;\n      } else {\n        descI = curDesc.parent.children.indexOf(curDesc);\n        curDesc = curDesc.parent;\n      }\n    }\n\n    var node = desc.node;\n    if (!node) continue;\n    if (node != frag.child(fI - 1)) break;\n    --fI;\n    matched.set(desc, fI);\n    matches.push(desc);\n  }\n\n  return {\n    index: fI,\n    matched: matched,\n    matches: matches.reverse()\n  };\n}\n\nfunction compareSide(a, b) {\n  return a.type.side - b.type.side;\n}\n\nfunction iterDeco(parent, deco, onWidget, onNode) {\n  var locals = deco.locals(parent),\n      offset = 0;\n\n  if (locals.length == 0) {\n    for (var i = 0; i < parent.childCount; i++) {\n      var child = parent.child(i);\n      onNode(child, locals, deco.forChild(offset, child), i);\n      offset += child.nodeSize;\n    }\n\n    return;\n  }\n\n  var decoIndex = 0,\n      active = [],\n      restNode = null;\n\n  for (var parentIndex = 0;;) {\n    if (decoIndex < locals.length && locals[decoIndex].to == offset) {\n      var widget = locals[decoIndex++],\n          widgets = void 0;\n\n      while (decoIndex < locals.length && locals[decoIndex].to == offset) {\n        (widgets || (widgets = [widget])).push(locals[decoIndex++]);\n      }\n\n      if (widgets) {\n        widgets.sort(compareSide);\n\n        for (var _i2 = 0; _i2 < widgets.length; _i2++) {\n          onWidget(widgets[_i2], parentIndex, !!restNode);\n        }\n      } else {\n        onWidget(widget, parentIndex, !!restNode);\n      }\n    }\n\n    var _child = void 0,\n        index = void 0;\n\n    if (restNode) {\n      index = -1;\n      _child = restNode;\n      restNode = null;\n    } else if (parentIndex < parent.childCount) {\n      index = parentIndex;\n      _child = parent.child(parentIndex++);\n    } else {\n      break;\n    }\n\n    for (var _i3 = 0; _i3 < active.length; _i3++) {\n      if (active[_i3].to <= offset) active.splice(_i3--, 1);\n    }\n\n    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) {\n      active.push(locals[decoIndex++]);\n    }\n\n    var end = offset + _child.nodeSize;\n\n    if (_child.isText) {\n      var cutAt = end;\n      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;\n\n      for (var _i4 = 0; _i4 < active.length; _i4++) {\n        if (active[_i4].to < cutAt) cutAt = active[_i4].to;\n      }\n\n      if (cutAt < end) {\n        restNode = _child.cut(cutAt - offset);\n        _child = _child.cut(0, cutAt - offset);\n        end = cutAt;\n        index = -1;\n      }\n    }\n\n    var outerDeco = _child.isInline && !_child.isLeaf ? active.filter(function (d) {\n      return !d.inline;\n    }) : active.slice();\n    onNode(_child, outerDeco, deco.forChild(offset, _child), index);\n    offset = end;\n  }\n}\n\nfunction iosHacks(dom) {\n  if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n    var oldCSS = dom.style.cssText;\n    dom.style.cssText = oldCSS + \"; list-style: square !important\";\n    window.getComputedStyle(dom).listStyle;\n    dom.style.cssText = oldCSS;\n  }\n}\n\nfunction nearbyTextNode(node, offset) {\n  for (;;) {\n    if (node.nodeType == 3) return node;\n\n    if (node.nodeType == 1 && offset > 0) {\n      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3) return node.childNodes[offset];\n      node = node.childNodes[offset - 1];\n      offset = nodeSize(node);\n    } else if (node.nodeType == 1 && offset < node.childNodes.length) {\n      node = node.childNodes[offset];\n      offset = 0;\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction findTextInFragment(frag, text, from, to) {\n  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n    var child = frag.child(i++),\n        childStart = pos;\n    pos += child.nodeSize;\n    if (!child.isText) continue;\n    var str = child.text;\n\n    while (i < frag.childCount) {\n      var next = frag.child(i++);\n      pos += next.nodeSize;\n      if (!next.isText) break;\n      str += next.text;\n    }\n\n    if (pos >= from) {\n      var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n      if (found >= 0 && found + text.length + childStart >= from) return childStart + found;\n      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;\n    }\n  }\n\n  return -1;\n}\n\nfunction replaceNodes(nodes, from, to, view, replacement) {\n  var result = [];\n\n  for (var i = 0, off = 0; i < nodes.length; i++) {\n    var child = nodes[i],\n        start = off,\n        end = off += child.size;\n\n    if (start >= to || end <= from) {\n      result.push(child);\n    } else {\n      if (start < from) result.push(child.slice(0, from - start, view));\n\n      if (replacement) {\n        result.push(replacement);\n        replacement = undefined;\n      }\n\n      if (end > to) result.push(child.slice(to - start, child.size, view));\n    }\n  }\n\n  return result;\n}\n\nfunction selectionFromDOM(view) {\n  var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var domSel = view.domSelectionRange(),\n      doc = view.state.doc;\n  if (!domSel.focusNode) return null;\n  var nearestDesc = view.docView.nearestDesc(domSel.focusNode),\n      inWidget = nearestDesc && nearestDesc.size == 0;\n  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n  if (head < 0) return null;\n  var $head = doc.resolve(head),\n      $anchor,\n      selection;\n\n  if (selectionCollapsed(domSel)) {\n    $anchor = $head;\n\n    while (nearestDesc && !nearestDesc.node) {\n      nearestDesc = nearestDesc.parent;\n    }\n\n    var nearestDescNode = nearestDesc.node;\n\n    if (nearestDesc && nearestDescNode.isAtom && prosemirrorState.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n      var pos = nearestDesc.posBefore;\n      selection = new prosemirrorState.NodeSelection(head == pos ? $head : doc.resolve(pos));\n    }\n  } else {\n    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n    if (anchor < 0) return null;\n    $anchor = doc.resolve(anchor);\n  }\n\n  if (!selection) {\n    var bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n    selection = selectionBetween(view, $anchor, $head, bias);\n  }\n\n  return selection;\n}\n\nfunction editorOwnsSelection(view) {\n  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\n\nfunction selectionToDOM(view) {\n  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var sel = view.state.selection;\n  syncNodeSelection(view, sel);\n  if (!editorOwnsSelection(view)) return;\n\n  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n    var domSel = view.domSelectionRange(),\n        curSel = view.domObserver.currentSelection;\n\n    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n      view.input.mouseDown.delayedSelectionSync = true;\n      view.domObserver.setCurSelection();\n      return;\n    }\n  }\n\n  view.domObserver.disconnectSelection();\n\n  if (view.cursorWrapper) {\n    selectCursorWrapper(view);\n  } else {\n    var anchor = sel.anchor,\n        head = sel.head,\n        resetEditableFrom,\n        resetEditableTo;\n\n    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState.TextSelection)) {\n      if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);\n      if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);\n    }\n\n    view.docView.setSelection(anchor, head, view.root, force);\n\n    if (brokenSelectBetweenUneditable) {\n      if (resetEditableFrom) resetEditable(resetEditableFrom);\n      if (resetEditableTo) resetEditable(resetEditableTo);\n    }\n\n    if (sel.visible) {\n      view.dom.classList.remove(\"ProseMirror-hideselection\");\n    } else {\n      view.dom.classList.add(\"ProseMirror-hideselection\");\n      if (\"onselectionchange\" in document) removeClassOnSelectionChange(view);\n    }\n  }\n\n  view.domObserver.setCurSelection();\n  view.domObserver.connectSelection();\n}\n\nvar brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\n\nfunction temporarilyEditableNear(view, pos) {\n  var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0),\n      node = _view$docView$domFrom3.node,\n      offset = _view$docView$domFrom3.offset;\n\n  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n  var before = offset ? node.childNodes[offset - 1] : null;\n  if (safari && after && after.contentEditable == \"false\") return setEditable(after);\n\n  if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n    if (after) return setEditable(after);else if (before) return setEditable(before);\n  }\n}\n\nfunction setEditable(element) {\n  element.contentEditable = \"true\";\n\n  if (safari && element.draggable) {\n    element.draggable = false;\n    element.wasDraggable = true;\n  }\n\n  return element;\n}\n\nfunction resetEditable(element) {\n  element.contentEditable = \"false\";\n\n  if (element.wasDraggable) {\n    element.draggable = true;\n    element.wasDraggable = null;\n  }\n}\n\nfunction removeClassOnSelectionChange(view) {\n  var doc = view.dom.ownerDocument;\n  doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n  var domSel = view.domSelectionRange();\n  var node = domSel.anchorNode,\n      offset = domSel.anchorOffset;\n  doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = function () {\n    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n      doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n      setTimeout(function () {\n        if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove(\"ProseMirror-hideselection\");\n      }, 20);\n    }\n  });\n}\n\nfunction selectCursorWrapper(view) {\n  var domSel = view.domSelection(),\n      range = document.createRange();\n  var node = view.cursorWrapper.dom,\n      img = node.nodeName == \"IMG\";\n  if (img) range.setEnd(node.parentNode, domIndex(node) + 1);else range.setEnd(node, 0);\n  range.collapse(false);\n  domSel.removeAllRanges();\n  domSel.addRange(range);\n\n  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n    node.disabled = true;\n    node.disabled = false;\n  }\n}\n\nfunction syncNodeSelection(view, sel) {\n  if (sel instanceof prosemirrorState.NodeSelection) {\n    var desc = view.docView.descAt(sel.from);\n\n    if (desc != view.lastSelectedViewDesc) {\n      clearNodeSelection(view);\n      if (desc) desc.selectNode();\n      view.lastSelectedViewDesc = desc;\n    }\n  } else {\n    clearNodeSelection(view);\n  }\n}\n\nfunction clearNodeSelection(view) {\n  if (view.lastSelectedViewDesc) {\n    if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();\n    view.lastSelectedViewDesc = undefined;\n  }\n}\n\nfunction selectionBetween(view, $anchor, $head, bias) {\n  return view.someProp(\"createSelectionBetween\", function (f) {\n    return f(view, $anchor, $head);\n  }) || prosemirrorState.TextSelection.between($anchor, $head, bias);\n}\n\nfunction hasFocusAndSelection(view) {\n  if (view.editable && !view.hasFocus()) return false;\n  return hasSelection(view);\n}\n\nfunction hasSelection(view) {\n  var sel = view.domSelectionRange();\n  if (!sel.anchorNode) return false;\n\n  try {\n    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction anchorInRightPlace(view) {\n  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n  var domSel = view.domSelectionRange();\n  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\n\nfunction moveSelectionBlock(state, dir) {\n  var _state$selection = state.selection,\n      $anchor = _state$selection.$anchor,\n      $head = _state$selection.$head;\n  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n  return $start && prosemirrorState.Selection.findFrom($start, dir);\n}\n\nfunction apply(view, sel) {\n  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n  return true;\n}\n\nfunction selectHorizontally(view, dir, mods) {\n  var sel = view.state.selection;\n\n  if (sel instanceof prosemirrorState.TextSelection) {\n    if (!sel.empty || mods.indexOf(\"s\") > -1) {\n      return false;\n    } else if (view.endOfTextblock(dir > 0 ? \"right\" : \"left\")) {\n      var next = moveSelectionBlock(view.state, dir);\n      if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);\n      return false;\n    } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n      var $head = sel.$head,\n          node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter,\n          desc;\n      if (!node || node.isText) return false;\n      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;\n\n      if (prosemirrorState.NodeSelection.isSelectable(node)) {\n        return apply(view, new prosemirrorState.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n      } else if (webkit) {\n        return apply(view, new prosemirrorState.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n      } else {\n        return false;\n      }\n    }\n  } else if (sel instanceof prosemirrorState.NodeSelection && sel.node.isInline) {\n    return apply(view, new prosemirrorState.TextSelection(dir > 0 ? sel.$to : sel.$from));\n  } else {\n    var _next = moveSelectionBlock(view.state, dir);\n\n    if (_next) return apply(view, _next);\n    return false;\n  }\n}\n\nfunction nodeLen(node) {\n  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\n\nfunction isIgnorable(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != \"BR\");\n}\n\nfunction skipIgnoredNodesLeft(view) {\n  var sel = view.domSelectionRange();\n  var node = sel.focusNode,\n      offset = sel.focusOffset;\n  if (!node) return;\n  var moveNode,\n      moveOffset,\n      force = false;\n  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) force = true;\n\n  for (;;) {\n    if (offset > 0) {\n      if (node.nodeType != 1) {\n        break;\n      } else {\n        var before = node.childNodes[offset - 1];\n\n        if (isIgnorable(before)) {\n          moveNode = node;\n          moveOffset = --offset;\n        } else if (before.nodeType == 3) {\n          node = before;\n          offset = node.nodeValue.length;\n        } else break;\n      }\n    } else if (isBlockNode(node)) {\n      break;\n    } else {\n      var prev = node.previousSibling;\n\n      while (prev && isIgnorable(prev)) {\n        moveNode = node.parentNode;\n        moveOffset = domIndex(prev);\n        prev = prev.previousSibling;\n      }\n\n      if (!prev) {\n        node = node.parentNode;\n        if (node == view.dom) break;\n        offset = 0;\n      } else {\n        node = prev;\n        offset = nodeLen(node);\n      }\n    }\n  }\n\n  if (force) setSelFocus(view, node, offset);else if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\n\nfunction skipIgnoredNodesRight(view) {\n  var sel = view.domSelectionRange();\n  var node = sel.focusNode,\n      offset = sel.focusOffset;\n  if (!node) return;\n  var len = nodeLen(node);\n  var moveNode, moveOffset;\n\n  for (;;) {\n    if (offset < len) {\n      if (node.nodeType != 1) break;\n      var after = node.childNodes[offset];\n\n      if (isIgnorable(after)) {\n        moveNode = node;\n        moveOffset = ++offset;\n      } else break;\n    } else if (isBlockNode(node)) {\n      break;\n    } else {\n      var next = node.nextSibling;\n\n      while (next && isIgnorable(next)) {\n        moveNode = next.parentNode;\n        moveOffset = domIndex(next) + 1;\n        next = next.nextSibling;\n      }\n\n      if (!next) {\n        node = node.parentNode;\n        if (node == view.dom) break;\n        offset = len = 0;\n      } else {\n        node = next;\n        offset = 0;\n        len = nodeLen(node);\n      }\n    }\n  }\n\n  if (moveNode) setSelFocus(view, moveNode, moveOffset);\n}\n\nfunction isBlockNode(dom) {\n  var desc = dom.pmViewDesc;\n  return desc && desc.node && desc.node.isBlock;\n}\n\nfunction setSelFocus(view, node, offset) {\n  var sel = view.domSelection();\n\n  if (selectionCollapsed(sel)) {\n    var range = document.createRange();\n    range.setEnd(node, offset);\n    range.setStart(node, offset);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  } else if (sel.extend) {\n    sel.extend(node, offset);\n  }\n\n  view.domObserver.setCurSelection();\n  var state = view.state;\n  setTimeout(function () {\n    if (view.state == state) selectionToDOM(view);\n  }, 50);\n}\n\nfunction selectVertically(view, dir, mods) {\n  var sel = view.state.selection;\n  if (sel instanceof prosemirrorState.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1) return false;\n  if (mac && mods.indexOf(\"m\") > -1) return false;\n  var $from = sel.$from,\n      $to = sel.$to;\n\n  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n    var next = moveSelectionBlock(view.state, dir);\n    if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);\n  }\n\n  if (!$from.parent.inlineContent) {\n    var side = dir < 0 ? $from : $to;\n    var beyond = sel instanceof prosemirrorState.AllSelection ? prosemirrorState.Selection.near(side, dir) : prosemirrorState.Selection.findFrom(side, dir);\n    return beyond ? apply(view, beyond) : false;\n  }\n\n  return false;\n}\n\nfunction stopNativeHorizontalDelete(view, dir) {\n  if (!(view.state.selection instanceof prosemirrorState.TextSelection)) return true;\n  var _view$state$selection2 = view.state.selection,\n      $head = _view$state$selection2.$head,\n      $anchor = _view$state$selection2.$anchor,\n      empty = _view$state$selection2.empty;\n  if (!$head.sameParent($anchor)) return true;\n  if (!empty) return false;\n  if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) return true;\n  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n\n  if (nextNode && !nextNode.isText) {\n    var tr = view.state.tr;\n    if (dir < 0) tr[\"delete\"]($head.pos - nextNode.nodeSize, $head.pos);else tr[\"delete\"]($head.pos, $head.pos + nextNode.nodeSize);\n    view.dispatch(tr);\n    return true;\n  }\n\n  return false;\n}\n\nfunction switchEditable(view, node, state) {\n  view.domObserver.stop();\n  node.contentEditable = state;\n  view.domObserver.start();\n}\n\nfunction safariDownArrowBug(view) {\n  if (!safari || view.state.selection.$head.parentOffset > 0) return false;\n\n  var _view$domSelectionRan3 = view.domSelectionRange(),\n      focusNode = _view$domSelectionRan3.focusNode,\n      focusOffset = _view$domSelectionRan3.focusOffset;\n\n  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n    var child = focusNode.firstChild;\n    switchEditable(view, child, \"true\");\n    setTimeout(function () {\n      return switchEditable(view, child, \"false\");\n    }, 20);\n  }\n\n  return false;\n}\n\nfunction getMods(event) {\n  var result = \"\";\n  if (event.ctrlKey) result += \"c\";\n  if (event.metaKey) result += \"m\";\n  if (event.altKey) result += \"a\";\n  if (event.shiftKey) result += \"s\";\n  return result;\n}\n\nfunction captureKeyDown(view, event) {\n  var code = event.keyCode,\n      mods = getMods(event);\n\n  if (code == 8 || mac && code == 72 && mods == \"c\") {\n    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);\n  } else if (code == 46 || mac && code == 68 && mods == \"c\") {\n    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);\n  } else if (code == 13 || code == 27) {\n    return true;\n  } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);\n  } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);\n  } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);\n  } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);\n  } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction serializeForClipboard(view, slice) {\n  view.someProp(\"transformCopied\", function (f) {\n    slice = f(slice);\n  });\n  var context = [],\n      _slice = slice,\n      content = _slice.content,\n      openStart = _slice.openStart,\n      openEnd = _slice.openEnd;\n\n  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n    openStart--;\n    openEnd--;\n    var node = content.firstChild;\n    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n    content = node.content;\n  }\n\n  var serializer = view.someProp(\"clipboardSerializer\") || prosemirrorModel.DOMSerializer.fromSchema(view.state.schema);\n  var doc = detachedDoc(),\n      wrap = doc.createElement(\"div\");\n  wrap.appendChild(serializer.serializeFragment(content, {\n    document: doc\n  }));\n  var firstChild = wrap.firstChild,\n      needsWrap,\n      wrappers = 0;\n\n  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n    for (var i = needsWrap.length - 1; i >= 0; i--) {\n      var wrapper = doc.createElement(needsWrap[i]);\n\n      while (wrap.firstChild) {\n        wrapper.appendChild(wrap.firstChild);\n      }\n\n      wrap.appendChild(wrapper);\n      wrappers++;\n    }\n\n    firstChild = wrap.firstChild;\n  }\n\n  if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute(\"data-pm-slice\", \"\".concat(openStart, \" \").concat(openEnd).concat(wrappers ? \" -\".concat(wrappers) : \"\", \" \").concat(JSON.stringify(context)));\n  var text = view.someProp(\"clipboardTextSerializer\", function (f) {\n    return f(slice);\n  }) || slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n  return {\n    dom: wrap,\n    text: text\n  };\n}\n\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n  var inCode = $context.parent.type.spec.code;\n  var dom, slice;\n  if (!html && !text) return null;\n  var asText = text && (plainText || inCode || !html);\n\n  if (asText) {\n    view.someProp(\"transformPastedText\", function (f) {\n      text = f(text, inCode || plainText);\n    });\n    if (inCode) return text ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0) : prosemirrorModel.Slice.empty;\n    var parsed = view.someProp(\"clipboardTextParser\", function (f) {\n      return f(text, $context, plainText);\n    });\n\n    if (parsed) {\n      slice = parsed;\n    } else {\n      var marks = $context.marks();\n      var schema = view.state.schema,\n          serializer = prosemirrorModel.DOMSerializer.fromSchema(schema);\n      dom = document.createElement(\"div\");\n      text.split(/(?:\\r\\n?|\\n)+/).forEach(function (block) {\n        var p = dom.appendChild(document.createElement(\"p\"));\n        if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n      });\n    }\n  } else {\n    view.someProp(\"transformPastedHTML\", function (f) {\n      html = f(html);\n    });\n    dom = readHTML(html);\n    if (webkit) restoreReplacedSpaces(dom);\n  }\n\n  var contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n  var sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n  if (sliceData && sliceData[3]) for (var i = +sliceData[3]; i > 0 && dom.firstChild; i--) {\n    dom = dom.firstChild;\n  }\n\n  if (!slice) {\n    var parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);\n    slice = parser.parseSlice(dom, {\n      preserveWhitespace: !!(asText || sliceData),\n      context: $context,\n      ruleFromNode: function ruleFromNode(dom) {\n        if (dom.nodeName == \"BR\" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {\n          ignore: true\n        };\n        return null;\n      }\n    });\n  }\n\n  if (sliceData) {\n    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n  } else {\n    slice = prosemirrorModel.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n\n    if (slice.openStart || slice.openEnd) {\n      var openStart = 0,\n          openEnd = 0;\n\n      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {}\n\n      for (var _node = slice.content.lastChild; openEnd < slice.openEnd && !_node.type.spec.isolating; openEnd++, _node = _node.lastChild) {}\n\n      slice = closeSlice(slice, openStart, openEnd);\n    }\n  }\n\n  view.someProp(\"transformPasted\", function (f) {\n    slice = f(slice);\n  });\n  return slice;\n}\n\nvar inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n\nfunction normalizeSiblings(fragment, $context) {\n  if (fragment.childCount < 2) return fragment;\n\n  var _loop = function _loop(d) {\n    var parent = $context.node(d);\n    var match = parent.contentMatchAt($context.index(d));\n    var lastWrap = void 0,\n        result = [];\n    fragment.forEach(function (node) {\n      if (!result) return;\n      var wrap = match.findWrapping(node.type),\n          inLast;\n      if (!wrap) return result = null;\n\n      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n        result[result.length - 1] = inLast;\n      } else {\n        if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n        var wrapped = withWrappers(node, wrap);\n        result.push(wrapped);\n        match = match.matchType(wrapped.type);\n        lastWrap = wrap;\n      }\n    });\n    if (result) return {\n      v: prosemirrorModel.Fragment.from(result)\n    };\n  };\n\n  for (var d = $context.depth; d >= 0; d--) {\n    var _ret = _loop(d);\n\n    if (_typeof(_ret) === \"object\") return _ret.v;\n  }\n\n  return fragment;\n}\n\nfunction withWrappers(node, wrap) {\n  var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  for (var i = wrap.length - 1; i >= from; i--) {\n    node = wrap[i].create(null, prosemirrorModel.Fragment.from(node));\n  }\n\n  return node;\n}\n\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n    var match = sibling.contentMatchAt(sibling.childCount);\n    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirrorModel.Fragment.from(withWrappers(node, wrap, depth + 1))));\n  }\n}\n\nfunction closeRight(node, depth) {\n  if (depth == 0) return node;\n  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);\n  return node.copy(fragment.append(fill));\n}\n\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n  var node = side < 0 ? fragment.firstChild : fragment.lastChild,\n      inner = node.content;\n  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n  if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true));\n  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\n\nfunction closeSlice(slice, openStart, openEnd) {\n  if (openStart < slice.openStart) slice = new prosemirrorModel.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n  if (openEnd < slice.openEnd) slice = new prosemirrorModel.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n  return slice;\n}\n\nvar wrapMap = {\n  thead: [\"table\"],\n  tbody: [\"table\"],\n  tfoot: [\"table\"],\n  caption: [\"table\"],\n  colgroup: [\"table\"],\n  col: [\"table\", \"colgroup\"],\n  tr: [\"table\", \"tbody\"],\n  td: [\"table\", \"tbody\", \"tr\"],\n  th: [\"table\", \"tbody\", \"tr\"]\n};\nvar _detachedDoc = null;\n\nfunction detachedDoc() {\n  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\n\nfunction readHTML(html) {\n  var metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n  if (metas) html = html.slice(metas[0].length);\n  var elt = detachedDoc().createElement(\"div\");\n  var firstTag = /<([a-z][^>\\s]+)/i.exec(html),\n      wrap;\n  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map(function (n) {\n    return \"<\" + n + \">\";\n  }).join(\"\") + html + wrap.map(function (n) {\n    return \"</\" + n + \">\";\n  }).reverse().join(\"\");\n  elt.innerHTML = html;\n  if (wrap) for (var i = 0; i < wrap.length; i++) {\n    elt = elt.querySelector(wrap[i]) || elt;\n  }\n  return elt;\n}\n\nfunction restoreReplacedSpaces(dom) {\n  var nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (node.childNodes.length == 1 && node.textContent == \"\\xA0\" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n  }\n}\n\nfunction addContext(slice, context) {\n  if (!slice.size) return slice;\n  var schema = slice.content.firstChild.type.schema,\n      array;\n\n  try {\n    array = JSON.parse(context);\n  } catch (e) {\n    return slice;\n  }\n\n  var content = slice.content,\n      openStart = slice.openStart,\n      openEnd = slice.openEnd;\n\n  for (var i = array.length - 2; i >= 0; i -= 2) {\n    var type = schema.nodes[array[i]];\n    if (!type || type.hasRequiredAttrs()) break;\n    content = prosemirrorModel.Fragment.from(type.create(array[i + 1], content));\n    openStart++;\n    openEnd++;\n  }\n\n  return new prosemirrorModel.Slice(content, openStart, openEnd);\n}\n\nvar handlers = {};\nvar editHandlers = {};\nvar passiveHandlers = {\n  touchstart: true,\n  touchmove: true\n};\n\nvar InputState = _createClass(function InputState() {\n  _classCallCheck(this, InputState);\n\n  this.shiftKey = false;\n  this.mouseDown = null;\n  this.lastKeyCode = null;\n  this.lastKeyCodeTime = 0;\n  this.lastClick = {\n    time: 0,\n    x: 0,\n    y: 0,\n    type: \"\"\n  };\n  this.lastSelectionOrigin = null;\n  this.lastSelectionTime = 0;\n  this.lastIOSEnter = 0;\n  this.lastIOSEnterFallbackTimeout = -1;\n  this.lastFocus = 0;\n  this.lastTouch = 0;\n  this.lastAndroidDelete = 0;\n  this.composing = false;\n  this.composingTimeout = -1;\n  this.compositionNodes = [];\n  this.compositionEndedAt = -2e8;\n  this.domChangeCount = 0;\n  this.eventHandlers = Object.create(null);\n  this.hideSelectionGuard = null;\n});\n\nfunction initInput(view) {\n  var _loop2 = function _loop2(event) {\n    var handler = handlers[event];\n    view.dom.addEventListener(event, view.input.eventHandlers[event] = function (event) {\n      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);\n    }, passiveHandlers[event] ? {\n      passive: true\n    } : undefined);\n  };\n\n  for (var event in handlers) {\n    _loop2(event);\n  }\n\n  if (safari) view.dom.addEventListener(\"input\", function () {\n    return null;\n  });\n  ensureListeners(view);\n}\n\nfunction setSelectionOrigin(view, origin) {\n  view.input.lastSelectionOrigin = origin;\n  view.input.lastSelectionTime = Date.now();\n}\n\nfunction destroyInput(view) {\n  view.domObserver.stop();\n\n  for (var type in view.input.eventHandlers) {\n    view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n  }\n\n  clearTimeout(view.input.composingTimeout);\n  clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\n\nfunction ensureListeners(view) {\n  view.someProp(\"handleDOMEvents\", function (currentHandlers) {\n    for (var type in currentHandlers) {\n      if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = function (event) {\n        return runCustomHandler(view, event);\n      });\n    }\n  });\n}\n\nfunction runCustomHandler(view, event) {\n  return view.someProp(\"handleDOMEvents\", function (handlers) {\n    var handler = handlers[event.type];\n    return handler ? handler(view, event) || event.defaultPrevented : false;\n  });\n}\n\nfunction eventBelongsToView(view, event) {\n  if (!event.bubbles) return true;\n  if (event.defaultPrevented) return false;\n\n  for (var node = event.target; node != view.dom; node = node.parentNode) {\n    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;\n  }\n\n  return true;\n}\n\nfunction _dispatchEvent(view, event) {\n  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);\n}\n\neditHandlers.keydown = function (view, _event) {\n  var event = _event;\n  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n  if (inOrNearComposition(view, event)) return;\n  view.input.lastKeyCode = event.keyCode;\n  view.input.lastKeyCodeTime = Date.now();\n  if (android && chrome && event.keyCode == 13) return;\n  if (event.keyCode != 229) view.domObserver.forceFlush();\n\n  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n    var now = Date.now();\n    view.input.lastIOSEnter = now;\n    view.input.lastIOSEnterFallbackTimeout = setTimeout(function () {\n      if (view.input.lastIOSEnter == now) {\n        view.someProp(\"handleKeyDown\", function (f) {\n          return f(view, keyEvent(13, \"Enter\"));\n        });\n        view.input.lastIOSEnter = 0;\n      }\n    }, 200);\n  } else if (view.someProp(\"handleKeyDown\", function (f) {\n    return f(view, event);\n  }) || captureKeyDown(view, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"key\");\n  }\n};\n\neditHandlers.keyup = function (view, event) {\n  if (event.keyCode == 16) view.input.shiftKey = false;\n};\n\neditHandlers.keypress = function (view, _event) {\n  var event = _event;\n  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;\n\n  if (view.someProp(\"handleKeyPress\", function (f) {\n    return f(view, event);\n  })) {\n    event.preventDefault();\n    return;\n  }\n\n  var sel = view.state.selection;\n\n  if (!(sel instanceof prosemirrorState.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n    var text = String.fromCharCode(event.charCode);\n    if (!view.someProp(\"handleTextInput\", function (f) {\n      return f(view, sel.$from.pos, sel.$to.pos, text);\n    })) view.dispatch(view.state.tr.insertText(text).scrollIntoView());\n    event.preventDefault();\n  }\n};\n\nfunction eventCoords(event) {\n  return {\n    left: event.clientX,\n    top: event.clientY\n  };\n}\n\nfunction isNear(event, click) {\n  var dx = click.x - event.clientX,\n      dy = click.y - event.clientY;\n  return dx * dx + dy * dy < 100;\n}\n\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n  if (inside == -1) return false;\n  var $pos = view.state.doc.resolve(inside);\n\n  var _loop3 = function _loop3(i) {\n    if (view.someProp(propName, function (f) {\n      return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false);\n    })) return {\n      v: true\n    };\n  };\n\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var _ret2 = _loop3(i);\n\n    if (_typeof(_ret2) === \"object\") return _ret2.v;\n  }\n\n  return false;\n}\n\nfunction updateSelection(view, selection, origin) {\n  if (!view.focused) view.focus();\n  var tr = view.state.tr.setSelection(selection);\n  if (origin == \"pointer\") tr.setMeta(\"pointer\", true);\n  view.dispatch(tr);\n}\n\nfunction selectClickedLeaf(view, inside) {\n  if (inside == -1) return false;\n  var $pos = view.state.doc.resolve(inside),\n      node = $pos.nodeAfter;\n\n  if (node && node.isAtom && prosemirrorState.NodeSelection.isSelectable(node)) {\n    updateSelection(view, new prosemirrorState.NodeSelection($pos), \"pointer\");\n    return true;\n  }\n\n  return false;\n}\n\nfunction selectClickedNode(view, inside) {\n  if (inside == -1) return false;\n  var sel = view.state.selection,\n      selectedNode,\n      selectAt;\n  if (sel instanceof prosemirrorState.NodeSelection) selectedNode = sel.node;\n  var $pos = view.state.doc.resolve(inside);\n\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n\n    if (prosemirrorState.NodeSelection.isSelectable(node)) {\n      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);else selectAt = $pos.before(i);\n      break;\n    }\n  }\n\n  if (selectAt != null) {\n    updateSelection(view, prosemirrorState.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n  return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", function (f) {\n    return f(view, pos, event);\n  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\n\nfunction handleDoubleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", function (f) {\n    return f(view, pos, event);\n  });\n}\n\nfunction handleTripleClick(view, pos, inside, event) {\n  return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", function (f) {\n    return f(view, pos, event);\n  }) || defaultTripleClick(view, inside, event);\n}\n\nfunction defaultTripleClick(view, inside, event) {\n  if (event.button != 0) return false;\n  var doc = view.state.doc;\n\n  if (inside == -1) {\n    if (doc.inlineContent) {\n      updateSelection(view, prosemirrorState.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n      return true;\n    }\n\n    return false;\n  }\n\n  var $pos = doc.resolve(inside);\n\n  for (var i = $pos.depth + 1; i > 0; i--) {\n    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n    var nodePos = $pos.before(i);\n    if (node.inlineContent) updateSelection(view, prosemirrorState.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");else if (prosemirrorState.NodeSelection.isSelectable(node)) updateSelection(view, prosemirrorState.NodeSelection.create(doc, nodePos), \"pointer\");else continue;\n    return true;\n  }\n}\n\nfunction forceDOMFlush(view) {\n  return endComposition(view);\n}\n\nvar selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\n\nhandlers.mousedown = function (view, _event) {\n  var event = _event;\n  view.input.shiftKey = event.shiftKey;\n  var flushed = forceDOMFlush(view);\n  var now = Date.now(),\n      type = \"singleClick\";\n\n  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {\n    if (view.input.lastClick.type == \"singleClick\") type = \"doubleClick\";else if (view.input.lastClick.type == \"doubleClick\") type = \"tripleClick\";\n  }\n\n  view.input.lastClick = {\n    time: now,\n    x: event.clientX,\n    y: event.clientY,\n    type: type\n  };\n  var pos = view.posAtCoords(eventCoords(event));\n  if (!pos) return;\n\n  if (type == \"singleClick\") {\n    if (view.input.mouseDown) view.input.mouseDown.done();\n    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n  } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n    event.preventDefault();\n  } else {\n    setSelectionOrigin(view, \"pointer\");\n  }\n};\n\nvar MouseDown = function () {\n  function MouseDown(view, pos, event, flushed) {\n    var _this8 = this;\n\n    _classCallCheck(this, MouseDown);\n\n    this.view = view;\n    this.pos = pos;\n    this.event = event;\n    this.flushed = flushed;\n    this.delayedSelectionSync = false;\n    this.mightDrag = null;\n    this.startDoc = view.state.doc;\n    this.selectNode = !!event[selectNodeModifier];\n    this.allowDefault = event.shiftKey;\n    var targetNode, targetPos;\n\n    if (pos.inside > -1) {\n      targetNode = view.state.doc.nodeAt(pos.inside);\n      targetPos = pos.inside;\n    } else {\n      var $pos = view.state.doc.resolve(pos.pos);\n      targetNode = $pos.parent;\n      targetPos = $pos.depth ? $pos.before() : 0;\n    }\n\n    var target = flushed ? null : event.target;\n    var targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n    this.target = targetDesc ? targetDesc.dom : null;\n    var selection = view.state.selection;\n    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirrorState.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {\n      node: targetNode,\n      pos: targetPos,\n      addAttr: !!(this.target && !this.target.draggable),\n      setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n    };\n\n    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n      this.view.domObserver.stop();\n      if (this.mightDrag.addAttr) this.target.draggable = true;\n      if (this.mightDrag.setUneditable) setTimeout(function () {\n        if (_this8.view.input.mouseDown == _this8) _this8.target.setAttribute(\"contentEditable\", \"false\");\n      }, 20);\n      this.view.domObserver.start();\n    }\n\n    view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n    view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n    setSelectionOrigin(view, \"pointer\");\n  }\n\n  _createClass(MouseDown, [{\n    key: \"done\",\n    value: function done() {\n      var _this9 = this;\n\n      this.view.root.removeEventListener(\"mouseup\", this.up);\n      this.view.root.removeEventListener(\"mousemove\", this.move);\n\n      if (this.mightDrag && this.target) {\n        this.view.domObserver.stop();\n        if (this.mightDrag.addAttr) this.target.removeAttribute(\"draggable\");\n        if (this.mightDrag.setUneditable) this.target.removeAttribute(\"contentEditable\");\n        this.view.domObserver.start();\n      }\n\n      if (this.delayedSelectionSync) setTimeout(function () {\n        return selectionToDOM(_this9.view);\n      });\n      this.view.input.mouseDown = null;\n    }\n  }, {\n    key: \"up\",\n    value: function up(event) {\n      this.done();\n      if (!this.view.dom.contains(event.target)) return;\n      var pos = this.pos;\n      if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));\n      this.updateAllowDefault(event);\n\n      if (this.allowDefault || !pos) {\n        setSelectionOrigin(this.view, \"pointer\");\n      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n        event.preventDefault();\n      } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n        updateSelection(this.view, prosemirrorState.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n        event.preventDefault();\n      } else {\n        setSelectionOrigin(this.view, \"pointer\");\n      }\n    }\n  }, {\n    key: \"move\",\n    value: function move(event) {\n      this.updateAllowDefault(event);\n      setSelectionOrigin(this.view, \"pointer\");\n      if (event.buttons == 0) this.done();\n    }\n  }, {\n    key: \"updateAllowDefault\",\n    value: function updateAllowDefault(event) {\n      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;\n    }\n  }]);\n\n  return MouseDown;\n}();\n\nhandlers.touchstart = function (view) {\n  view.input.lastTouch = Date.now();\n  forceDOMFlush(view);\n  setSelectionOrigin(view, \"pointer\");\n};\n\nhandlers.touchmove = function (view) {\n  view.input.lastTouch = Date.now();\n  setSelectionOrigin(view, \"pointer\");\n};\n\nhandlers.contextmenu = function (view) {\n  return forceDOMFlush(view);\n};\n\nfunction inOrNearComposition(view, event) {\n  if (view.composing) return true;\n\n  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n    view.input.compositionEndedAt = -2e8;\n    return true;\n  }\n\n  return false;\n}\n\nvar timeoutComposition = android ? 5000 : -1;\n\neditHandlers.compositionstart = editHandlers.compositionupdate = function (view) {\n  if (!view.composing) {\n    view.domObserver.flush();\n    var state = view.state,\n        $pos = state.selection.$from;\n\n    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) {\n      return m.type.spec.inclusive === false;\n    }))) {\n      view.markCursor = view.state.storedMarks || $pos.marks();\n      endComposition(view, true);\n      view.markCursor = null;\n    } else {\n      endComposition(view);\n\n      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n        var sel = view.domSelectionRange();\n\n        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n          if (!before) break;\n\n          if (before.nodeType == 3) {\n            view.domSelection().collapse(before, before.nodeValue.length);\n            break;\n          } else {\n            node = before;\n            offset = -1;\n          }\n        }\n      }\n    }\n\n    view.input.composing = true;\n  }\n\n  scheduleComposeEnd(view, timeoutComposition);\n};\n\neditHandlers.compositionend = function (view, event) {\n  if (view.composing) {\n    view.input.composing = false;\n    view.input.compositionEndedAt = event.timeStamp;\n    scheduleComposeEnd(view, 20);\n  }\n};\n\nfunction scheduleComposeEnd(view, delay) {\n  clearTimeout(view.input.composingTimeout);\n  if (delay > -1) view.input.composingTimeout = setTimeout(function () {\n    return endComposition(view);\n  }, delay);\n}\n\nfunction clearComposition(view) {\n  if (view.composing) {\n    view.input.composing = false;\n    view.input.compositionEndedAt = timestampFromCustomEvent();\n  }\n\n  while (view.input.compositionNodes.length > 0) {\n    view.input.compositionNodes.pop().markParentsDirty();\n  }\n}\n\nfunction timestampFromCustomEvent() {\n  var event = document.createEvent(\"Event\");\n  event.initEvent(\"event\", true, true);\n  return event.timeStamp;\n}\n\nfunction endComposition(view) {\n  var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (android && view.domObserver.flushingSoon >= 0) return;\n  view.domObserver.forceFlush();\n  clearComposition(view);\n\n  if (forceUpdate || view.docView && view.docView.dirty) {\n    var sel = selectionFromDOM(view);\n    if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));else view.updateState(view.state);\n    return true;\n  }\n\n  return false;\n}\n\nfunction captureCopy(view, dom) {\n  if (!view.dom.parentNode) return;\n  var wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n  wrap.appendChild(dom);\n  wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  var sel = getSelection(),\n      range = document.createRange();\n  range.selectNodeContents(dom);\n  view.dom.blur();\n  sel.removeAllRanges();\n  sel.addRange(range);\n  setTimeout(function () {\n    if (wrap.parentNode) wrap.parentNode.removeChild(wrap);\n    view.focus();\n  }, 50);\n}\n\nvar brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\n\nhandlers.copy = editHandlers.cut = function (view, _event) {\n  var event = _event;\n  var sel = view.state.selection,\n      cut = event.type == \"cut\";\n  if (sel.empty) return;\n  var data = brokenClipboardAPI ? null : event.clipboardData;\n\n  var slice = sel.content(),\n      _serializeForClipboar = serializeForClipboard(view, slice),\n      dom = _serializeForClipboar.dom,\n      text = _serializeForClipboar.text;\n\n  if (data) {\n    event.preventDefault();\n    data.clearData();\n    data.setData(\"text/html\", dom.innerHTML);\n    data.setData(\"text/plain\", text);\n  } else {\n    captureCopy(view, dom);\n  }\n\n  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\n\nfunction sliceSingleNode(slice) {\n  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\n\nfunction capturePaste(view, event) {\n  if (!view.dom.parentNode) return;\n  var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n  if (!plainText) target.contentEditable = \"true\";\n  target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n  target.focus();\n  setTimeout(function () {\n    view.focus();\n    if (target.parentNode) target.parentNode.removeChild(target);\n    if (plainText) doPaste(view, target.value, null, event);else doPaste(view, target.textContent, target.innerHTML, event);\n  }, 50);\n}\n\nfunction doPaste(view, text, html, event) {\n  var slice = parseFromClipboard(view, text, html, view.input.shiftKey, view.state.selection.$from);\n  if (view.someProp(\"handlePaste\", function (f) {\n    return f(view, event, slice || prosemirrorModel.Slice.empty);\n  })) return true;\n  if (!slice) return false;\n  var singleNode = sliceSingleNode(slice);\n  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice);\n  view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n  return true;\n}\n\neditHandlers.paste = function (view, _event) {\n  var event = _event;\n  if (view.composing && !android) return;\n  var data = brokenClipboardAPI ? null : event.clipboardData;\n  if (data && doPaste(view, data.getData(\"text/plain\"), data.getData(\"text/html\"), event)) event.preventDefault();else capturePaste(view, event);\n};\n\nvar Dragging = _createClass(function Dragging(slice, move) {\n  _classCallCheck(this, Dragging);\n\n  this.slice = slice;\n  this.move = move;\n});\n\nvar dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\n\nhandlers.dragstart = function (view, _event) {\n  var event = _event;\n  var mouseDown = view.input.mouseDown;\n  if (mouseDown) mouseDown.done();\n  if (!event.dataTransfer) return;\n  var sel = view.state.selection;\n  var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState.NodeSelection ? sel.to - 1 : sel.to)) ;else if (mouseDown && mouseDown.mightDrag) {\n    view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));\n  } else if (event.target && event.target.nodeType == 1) {\n    var desc = view.docView.nearestDesc(event.target, true);\n    if (desc && desc.node.type.spec.draggable && desc != view.docView) view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, desc.posBefore)));\n  }\n\n  var slice = view.state.selection.content(),\n      _serializeForClipboar2 = serializeForClipboard(view, slice),\n      dom = _serializeForClipboar2.dom,\n      text = _serializeForClipboar2.text;\n\n  event.dataTransfer.clearData();\n  event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n  event.dataTransfer.effectAllowed = \"copyMove\";\n  if (!brokenClipboardAPI) event.dataTransfer.setData(\"text/plain\", text);\n  view.dragging = new Dragging(slice, !event[dragCopyModifier]);\n};\n\nhandlers.dragend = function (view) {\n  var dragging = view.dragging;\n  window.setTimeout(function () {\n    if (view.dragging == dragging) view.dragging = null;\n  }, 50);\n};\n\neditHandlers.dragover = editHandlers.dragenter = function (_, e) {\n  return e.preventDefault();\n};\n\neditHandlers.drop = function (view, _event) {\n  var event = _event;\n  var dragging = view.dragging;\n  view.dragging = null;\n  if (!event.dataTransfer) return;\n  var eventPos = view.posAtCoords(eventCoords(event));\n  if (!eventPos) return;\n  var $mouse = view.state.doc.resolve(eventPos.pos);\n  var slice = dragging && dragging.slice;\n\n  if (slice) {\n    view.someProp(\"transformPasted\", function (f) {\n      slice = f(slice);\n    });\n  } else {\n    slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? \"Text\" : \"text/plain\"), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n  }\n\n  var move = !!(dragging && !event[dragCopyModifier]);\n\n  if (view.someProp(\"handleDrop\", function (f) {\n    return f(view, event, slice || prosemirrorModel.Slice.empty, move);\n  })) {\n    event.preventDefault();\n    return;\n  }\n\n  if (!slice) return;\n  event.preventDefault();\n  var insertPos = slice ? prosemirrorTransform.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n  if (insertPos == null) insertPos = $mouse.pos;\n  var tr = view.state.tr;\n  if (move) tr.deleteSelection();\n  var pos = tr.mapping.map(insertPos);\n  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n  var beforeInsert = tr.doc;\n  if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);else tr.replaceRange(pos, pos, slice);\n  if (tr.doc.eq(beforeInsert)) return;\n  var $pos = tr.doc.resolve(pos);\n\n  if (isNode && prosemirrorState.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n    tr.setSelection(new prosemirrorState.NodeSelection($pos));\n  } else {\n    var end = tr.mapping.map(insertPos);\n    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) {\n      return end = newTo;\n    });\n    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n  }\n\n  view.focus();\n  view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\n\nhandlers.focus = function (view) {\n  view.input.lastFocus = Date.now();\n\n  if (!view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.add(\"ProseMirror-focused\");\n    view.domObserver.start();\n    view.focused = true;\n    setTimeout(function () {\n      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);\n    }, 20);\n  }\n};\n\nhandlers.blur = function (view, _event) {\n  var event = _event;\n\n  if (view.focused) {\n    view.domObserver.stop();\n    view.dom.classList.remove(\"ProseMirror-focused\");\n    view.domObserver.start();\n    if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();\n    view.focused = false;\n  }\n};\n\nhandlers.beforeinput = function (view, _event) {\n  var event = _event;\n\n  if (chrome && android && event.inputType == \"deleteContentBackward\") {\n    view.domObserver.flushSoon();\n    var domChangeCount = view.input.domChangeCount;\n    setTimeout(function () {\n      if (view.input.domChangeCount != domChangeCount) return;\n      view.dom.blur();\n      view.focus();\n      if (view.someProp(\"handleKeyDown\", function (f) {\n        return f(view, keyEvent(8, \"Backspace\"));\n      })) return;\n      var $cursor = view.state.selection.$cursor;\n      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr[\"delete\"]($cursor.pos - 1, $cursor.pos).scrollIntoView());\n    }, 50);\n  }\n};\n\nfor (var prop in editHandlers) {\n  handlers[prop] = editHandlers[prop];\n}\n\nfunction compareObjs(a, b) {\n  if (a == b) return true;\n\n  for (var p in a) {\n    if (a[p] !== b[p]) return false;\n  }\n\n  for (var _p in b) {\n    if (!(_p in a)) return false;\n  }\n\n  return true;\n}\n\nvar WidgetType = function () {\n  function WidgetType(toDOM, spec) {\n    _classCallCheck(this, WidgetType);\n\n    this.toDOM = toDOM;\n    this.spec = spec || noSpec;\n    this.side = this.spec.side || 0;\n  }\n\n  _createClass(WidgetType, [{\n    key: \"map\",\n    value: function map(mapping, span, offset, oldOffset) {\n      var _mapping$mapResult = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1),\n          pos = _mapping$mapResult.pos,\n          deleted = _mapping$mapResult.deleted;\n\n      return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n  }, {\n    key: \"valid\",\n    value: function valid() {\n      return true;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(node) {\n      if (this.spec.destroy) this.spec.destroy(node);\n    }\n  }]);\n\n  return WidgetType;\n}();\n\nvar InlineType = function () {\n  function InlineType(attrs, spec) {\n    _classCallCheck(this, InlineType);\n\n    this.attrs = attrs;\n    this.spec = spec || noSpec;\n  }\n\n  _createClass(InlineType, [{\n    key: \"map\",\n    value: function map(mapping, span, offset, oldOffset) {\n      var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n      return from >= to ? null : new Decoration(from, to, this);\n    }\n  }, {\n    key: \"valid\",\n    value: function valid(_, span) {\n      return span.from < span.to;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {}\n  }], [{\n    key: \"is\",\n    value: function is(span) {\n      return span.type instanceof InlineType;\n    }\n  }]);\n\n  return InlineType;\n}();\n\nvar NodeType = function () {\n  function NodeType(attrs, spec) {\n    _classCallCheck(this, NodeType);\n\n    this.attrs = attrs;\n    this.spec = spec || noSpec;\n  }\n\n  _createClass(NodeType, [{\n    key: \"map\",\n    value: function map(mapping, span, offset, oldOffset) {\n      var from = mapping.mapResult(span.from + oldOffset, 1);\n      if (from.deleted) return null;\n      var to = mapping.mapResult(span.to + oldOffset, -1);\n      if (to.deleted || to.pos <= from.pos) return null;\n      return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n  }, {\n    key: \"valid\",\n    value: function valid(node, span) {\n      var _node$content$findInd = node.content.findIndex(span.from),\n          index = _node$content$findInd.index,\n          offset = _node$content$findInd.offset,\n          child;\n\n      return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {}\n  }]);\n\n  return NodeType;\n}();\n\nvar Decoration = function () {\n  function Decoration(from, to, type) {\n    _classCallCheck(this, Decoration);\n\n    this.from = from;\n    this.to = to;\n    this.type = type;\n  }\n\n  _createClass(Decoration, [{\n    key: \"copy\",\n    value: function copy(from, to) {\n      return new Decoration(from, to, this.type);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping, offset, oldOffset) {\n      return this.type.map(mapping, this, offset, oldOffset);\n    }\n  }, {\n    key: \"spec\",\n    get: function get() {\n      return this.type.spec;\n    }\n  }, {\n    key: \"inline\",\n    get: function get() {\n      return this.type instanceof InlineType;\n    }\n  }], [{\n    key: \"widget\",\n    value: function widget(pos, toDOM, spec) {\n      return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n  }, {\n    key: \"inline\",\n    value: function inline(from, to, attrs, spec) {\n      return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n  }, {\n    key: \"node\",\n    value: function node(from, to, attrs, spec) {\n      return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n  }]);\n\n  return Decoration;\n}();\n\nvar none = [],\n    noSpec = {};\n\nvar DecorationSet = function () {\n  function DecorationSet(local, children) {\n    _classCallCheck(this, DecorationSet);\n\n    this.local = local.length ? local : none;\n    this.children = children.length ? children : none;\n  }\n\n  _createClass(DecorationSet, [{\n    key: \"find\",\n    value: function find(start, end, predicate) {\n      var result = [];\n      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n      return result;\n    }\n  }, {\n    key: \"findInner\",\n    value: function findInner(start, end, result, offset, predicate) {\n      for (var i = 0; i < this.local.length; i++) {\n        var span = this.local[i];\n        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));\n      }\n\n      for (var _i5 = 0; _i5 < this.children.length; _i5 += 3) {\n        if (this.children[_i5] < end && this.children[_i5 + 1] > start) {\n          var childOff = this.children[_i5] + 1;\n\n          this.children[_i5 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n        }\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map(mapping, doc, options) {\n      if (this == empty || mapping.maps.length == 0) return this;\n      return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n  }, {\n    key: \"mapInner\",\n    value: function mapInner(mapping, node, offset, oldOffset, options) {\n      var newLocal;\n\n      for (var i = 0; i < this.local.length; i++) {\n        var mapped = this.local[i].map(mapping, offset, oldOffset);\n        if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);else if (options.onRemove) options.onRemove(this.local[i].spec);\n      }\n\n      if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n  }, {\n    key: \"add\",\n    value: function add(doc, decorations) {\n      if (!decorations.length) return this;\n      if (this == empty) return DecorationSet.create(doc, decorations);\n      return this.addInner(doc, decorations, 0);\n    }\n  }, {\n    key: \"addInner\",\n    value: function addInner(doc, decorations, offset) {\n      var _this10 = this;\n\n      var children,\n          childIndex = 0;\n      doc.forEach(function (childNode, childOffset) {\n        var baseOffset = childOffset + offset,\n            found;\n        if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;\n        if (!children) children = _this10.children.slice();\n\n        while (childIndex < children.length && children[childIndex] < childOffset) {\n          childIndex += 3;\n        }\n\n        if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n        childIndex += 3;\n      });\n      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n\n      for (var i = 0; i < local.length; i++) {\n        if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);\n      }\n\n      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(decorations) {\n      if (decorations.length == 0 || this == empty) return this;\n      return this.removeInner(decorations, 0);\n    }\n  }, {\n    key: \"removeInner\",\n    value: function removeInner(decorations, offset) {\n      var children = this.children,\n          local = this.local;\n\n      for (var i = 0; i < children.length; i += 3) {\n        var found = void 0;\n        var from = children[i] + offset,\n            to = children[i + 1] + offset;\n\n        for (var j = 0, span; j < decorations.length; j++) {\n          if (span = decorations[j]) {\n            if (span.from > from && span.to < to) {\n              decorations[j] = null;\n              (found || (found = [])).push(span);\n            }\n          }\n        }\n\n        if (!found) continue;\n        if (children == this.children) children = this.children.slice();\n        var removed = children[i + 2].removeInner(found, from + 1);\n\n        if (removed != empty) {\n          children[i + 2] = removed;\n        } else {\n          children.splice(i, 3);\n          i -= 3;\n        }\n      }\n\n      if (local.length) for (var _i6 = 0, _span; _i6 < decorations.length; _i6++) {\n        if (_span = decorations[_i6]) {\n          for (var _j2 = 0; _j2 < local.length; _j2++) {\n            if (local[_j2].eq(_span, offset)) {\n              if (local == this.local) local = this.local.slice();\n              local.splice(_j2--, 1);\n            }\n          }\n        }\n      }\n      if (children == this.children && local == this.local) return this;\n      return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n  }, {\n    key: \"forChild\",\n    value: function forChild(offset, node) {\n      if (this == empty) return this;\n      if (node.isLeaf) return DecorationSet.empty;\n      var child, local;\n\n      for (var i = 0; i < this.children.length; i += 3) {\n        if (this.children[i] >= offset) {\n          if (this.children[i] == offset) child = this.children[i + 2];\n          break;\n        }\n      }\n\n      var start = offset + 1,\n          end = start + node.content.size;\n\n      for (var _i7 = 0; _i7 < this.local.length; _i7++) {\n        var dec = this.local[_i7];\n\n        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n          var from = Math.max(start, dec.from) - start,\n              to = Math.min(end, dec.to) - start;\n          if (from < to) (local || (local = [])).push(dec.copy(from, to));\n        }\n      }\n\n      if (local) {\n        var localSet = new DecorationSet(local.sort(byPos), none);\n        return child ? new DecorationGroup([localSet, child]) : localSet;\n      }\n\n      return child || empty;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (this == other) return true;\n      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;\n\n      for (var i = 0; i < this.local.length; i++) {\n        if (!this.local[i].eq(other.local[i])) return false;\n      }\n\n      for (var _i8 = 0; _i8 < this.children.length; _i8 += 3) {\n        if (this.children[_i8] != other.children[_i8] || this.children[_i8 + 1] != other.children[_i8 + 1] || !this.children[_i8 + 2].eq(other.children[_i8 + 2])) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"locals\",\n    value: function locals(node) {\n      return removeOverlap(this.localsInner(node));\n    }\n  }, {\n    key: \"localsInner\",\n    value: function localsInner(node) {\n      if (this == empty) return none;\n      if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;\n      var result = [];\n\n      for (var i = 0; i < this.local.length; i++) {\n        if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);\n      }\n\n      return result;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(doc, decorations) {\n      return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n  }]);\n\n  return DecorationSet;\n}();\n\nDecorationSet.empty = new DecorationSet([], []);\nDecorationSet.removeOverlap = removeOverlap;\nvar empty = DecorationSet.empty;\n\nvar DecorationGroup = function () {\n  function DecorationGroup(members) {\n    _classCallCheck(this, DecorationGroup);\n\n    this.members = members;\n  }\n\n  _createClass(DecorationGroup, [{\n    key: \"map\",\n    value: function map(mapping, doc) {\n      var mappedDecos = this.members.map(function (member) {\n        return member.map(mapping, doc, noSpec);\n      });\n      return DecorationGroup.from(mappedDecos);\n    }\n  }, {\n    key: \"forChild\",\n    value: function forChild(offset, child) {\n      if (child.isLeaf) return DecorationSet.empty;\n      var found = [];\n\n      for (var i = 0; i < this.members.length; i++) {\n        var result = this.members[i].forChild(offset, child);\n        if (result == empty) continue;\n        if (result instanceof DecorationGroup) found = found.concat(result.members);else found.push(result);\n      }\n\n      return DecorationGroup.from(found);\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(other) {\n      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;\n\n      for (var i = 0; i < this.members.length; i++) {\n        if (!this.members[i].eq(other.members[i])) return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"locals\",\n    value: function locals(node) {\n      var result,\n          sorted = true;\n\n      for (var i = 0; i < this.members.length; i++) {\n        var locals = this.members[i].localsInner(node);\n        if (!locals.length) continue;\n\n        if (!result) {\n          result = locals;\n        } else {\n          if (sorted) {\n            result = result.slice();\n            sorted = false;\n          }\n\n          for (var j = 0; j < locals.length; j++) {\n            result.push(locals[j]);\n          }\n        }\n      }\n\n      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n  }], [{\n    key: \"from\",\n    value: function from(members) {\n      switch (members.length) {\n        case 0:\n          return empty;\n\n        case 1:\n          return members[0];\n\n        default:\n          return new DecorationGroup(members);\n      }\n    }\n  }]);\n\n  return DecorationGroup;\n}();\n\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n  var children = oldChildren.slice();\n\n  var _loop4 = function _loop4(i, _baseOffset) {\n    var moved = 0;\n    mapping.maps[i].forEach(function (oldStart, oldEnd, newStart, newEnd) {\n      var dSize = newEnd - newStart - (oldEnd - oldStart);\n\n      for (var _i12 = 0; _i12 < children.length; _i12 += 3) {\n        var end = children[_i12 + 1];\n        if (end < 0 || oldStart > end + _baseOffset - moved) continue;\n        var start = children[_i12] + _baseOffset - moved;\n\n        if (oldEnd >= start) {\n          children[_i12 + 1] = oldStart <= start ? -2 : -1;\n        } else if (newStart >= offset && dSize) {\n          children[_i12] += dSize;\n          children[_i12 + 1] += dSize;\n        }\n      }\n\n      moved += dSize;\n    });\n    _baseOffset = mapping.maps[i].map(_baseOffset, -1);\n    baseOffset = _baseOffset;\n  };\n\n  for (var i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {\n    _loop4(i, baseOffset);\n  }\n\n  var mustRebuild = false;\n\n  for (var _i9 = 0; _i9 < children.length; _i9 += 3) {\n    if (children[_i9 + 1] < 0) {\n      if (children[_i9 + 1] == -2) {\n        mustRebuild = true;\n        children[_i9 + 1] = -1;\n        continue;\n      }\n\n      var from = mapping.map(oldChildren[_i9] + oldOffset),\n          fromLocal = from - offset;\n\n      if (fromLocal < 0 || fromLocal >= node.content.size) {\n        mustRebuild = true;\n        continue;\n      }\n\n      var to = mapping.map(oldChildren[_i9 + 1] + oldOffset, -1),\n          toLocal = to - offset;\n\n      var _node$content$findInd2 = node.content.findIndex(fromLocal),\n          index = _node$content$findInd2.index,\n          childOffset = _node$content$findInd2.offset;\n\n      var childNode = node.maybeChild(index);\n\n      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n        var mapped = children[_i9 + 2].mapInner(mapping, childNode, from + 1, oldChildren[_i9] + oldOffset + 1, options);\n\n        if (mapped != empty) {\n          children[_i9] = fromLocal;\n          children[_i9 + 1] = toLocal;\n          children[_i9 + 2] = mapped;\n        } else {\n          children[_i9 + 1] = -2;\n          mustRebuild = true;\n        }\n      } else {\n        mustRebuild = true;\n      }\n    }\n  }\n\n  if (mustRebuild) {\n    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n    var built = buildTree(decorations, node, 0, options);\n    newLocal = built.local;\n\n    for (var _i10 = 0; _i10 < children.length; _i10 += 3) {\n      if (children[_i10 + 1] < 0) {\n        children.splice(_i10, 3);\n        _i10 -= 3;\n      }\n    }\n\n    for (var _i11 = 0, j = 0; _i11 < built.children.length; _i11 += 3) {\n      var _from2 = built.children[_i11];\n\n      while (j < children.length && children[j] < _from2) {\n        j += 3;\n      }\n\n      children.splice(j, 0, built.children[_i11], built.children[_i11 + 1], built.children[_i11 + 2]);\n    }\n  }\n\n  return new DecorationSet(newLocal.sort(byPos), children);\n}\n\nfunction moveSpans(spans, offset) {\n  if (!offset || !spans.length) return spans;\n  var result = [];\n\n  for (var i = 0; i < spans.length; i++) {\n    var span = spans[i];\n    result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n  }\n\n  return result;\n}\n\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n  function gather(set, oldOffset) {\n    for (var i = 0; i < set.local.length; i++) {\n      var mapped = set.local[i].map(mapping, offset, oldOffset);\n      if (mapped) decorations.push(mapped);else if (options.onRemove) options.onRemove(set.local[i].spec);\n    }\n\n    for (var _i13 = 0; _i13 < set.children.length; _i13 += 3) {\n      gather(set.children[_i13 + 2], set.children[_i13] + oldOffset + 1);\n    }\n  }\n\n  for (var i = 0; i < children.length; i += 3) {\n    if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n  }\n\n  return decorations;\n}\n\nfunction takeSpansForNode(spans, node, offset) {\n  if (node.isLeaf) return null;\n  var end = offset + node.nodeSize,\n      found = null;\n\n  for (var i = 0, span; i < spans.length; i++) {\n    if ((span = spans[i]) && span.from > offset && span.to < end) {\n      (found || (found = [])).push(span);\n      spans[i] = null;\n    }\n  }\n\n  return found;\n}\n\nfunction withoutNulls(array) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] != null) result.push(array[i]);\n  }\n\n  return result;\n}\n\nfunction buildTree(spans, node, offset, options) {\n  var children = [],\n      hasNulls = false;\n  node.forEach(function (childNode, localStart) {\n    var found = takeSpansForNode(spans, childNode, localStart + offset);\n\n    if (found) {\n      hasNulls = true;\n      var subtree = buildTree(found, childNode, offset + localStart + 1, options);\n      if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);\n    }\n  });\n  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n\n  for (var i = 0; i < locals.length; i++) {\n    if (!locals[i].type.valid(node, locals[i])) {\n      if (options.onRemove) options.onRemove(locals[i].spec);\n      locals.splice(i--, 1);\n    }\n  }\n\n  return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n\nfunction byPos(a, b) {\n  return a.from - b.from || a.to - b.to;\n}\n\nfunction removeOverlap(spans) {\n  var working = spans;\n\n  for (var i = 0; i < working.length - 1; i++) {\n    var span = working[i];\n    if (span.from != span.to) for (var j = i + 1; j < working.length; j++) {\n      var next = working[j];\n\n      if (next.from == span.from) {\n        if (next.to != span.to) {\n          if (working == spans) working = spans.slice();\n          working[j] = next.copy(next.from, span.to);\n          insertAhead(working, j + 1, next.copy(span.to, next.to));\n        }\n\n        continue;\n      } else {\n        if (next.from < span.to) {\n          if (working == spans) working = spans.slice();\n          working[i] = span.copy(span.from, next.from);\n          insertAhead(working, j, span.copy(next.from, span.to));\n        }\n\n        break;\n      }\n    }\n  }\n\n  return working;\n}\n\nfunction insertAhead(array, i, deco) {\n  while (i < array.length && byPos(deco, array[i]) > 0) {\n    i++;\n  }\n\n  array.splice(i, 0, deco);\n}\n\nfunction viewDecorations(view) {\n  var found = [];\n  view.someProp(\"decorations\", function (f) {\n    var result = f(view.state);\n    if (result && result != empty) found.push(result);\n  });\n  if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n  return DecorationGroup.from(found);\n}\n\nvar observeOptions = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  attributes: true,\n  attributeOldValue: true,\n  subtree: true\n};\nvar useCharData = ie && ie_version <= 11;\n\nvar SelectionState = function () {\n  function SelectionState() {\n    _classCallCheck(this, SelectionState);\n\n    this.anchorNode = null;\n    this.anchorOffset = 0;\n    this.focusNode = null;\n    this.focusOffset = 0;\n  }\n\n  _createClass(SelectionState, [{\n    key: \"set\",\n    value: function set(sel) {\n      this.anchorNode = sel.anchorNode;\n      this.anchorOffset = sel.anchorOffset;\n      this.focusNode = sel.focusNode;\n      this.focusOffset = sel.focusOffset;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.anchorNode = this.focusNode = null;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(sel) {\n      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n  }]);\n\n  return SelectionState;\n}();\n\nvar DOMObserver = function () {\n  function DOMObserver(view, handleDOMChange) {\n    var _this11 = this;\n\n    _classCallCheck(this, DOMObserver);\n\n    this.view = view;\n    this.handleDOMChange = handleDOMChange;\n    this.queue = [];\n    this.flushingSoon = -1;\n    this.observer = null;\n    this.currentSelection = new SelectionState();\n    this.onCharData = null;\n    this.suppressingSelectionUpdates = false;\n    this.observer = window.MutationObserver && new window.MutationObserver(function (mutations) {\n      for (var i = 0; i < mutations.length; i++) {\n        _this11.queue.push(mutations[i]);\n      }\n\n      if (ie && ie_version <= 11 && mutations.some(function (m) {\n        return m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length;\n      })) _this11.flushSoon();else _this11.flush();\n    });\n\n    if (useCharData) {\n      this.onCharData = function (e) {\n        _this11.queue.push({\n          target: e.target,\n          type: \"characterData\",\n          oldValue: e.prevValue\n        });\n\n        _this11.flushSoon();\n      };\n    }\n\n    this.onSelectionChange = this.onSelectionChange.bind(this);\n  }\n\n  _createClass(DOMObserver, [{\n    key: \"flushSoon\",\n    value: function flushSoon() {\n      var _this12 = this;\n\n      if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(function () {\n        _this12.flushingSoon = -1;\n\n        _this12.flush();\n      }, 20);\n    }\n  }, {\n    key: \"forceFlush\",\n    value: function forceFlush() {\n      if (this.flushingSoon > -1) {\n        window.clearTimeout(this.flushingSoon);\n        this.flushingSoon = -1;\n        this.flush();\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this.observer) {\n        this.observer.takeRecords();\n        this.observer.observe(this.view.dom, observeOptions);\n      }\n\n      if (this.onCharData) this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n      this.connectSelection();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this13 = this;\n\n      if (this.observer) {\n        var take = this.observer.takeRecords();\n\n        if (take.length) {\n          for (var i = 0; i < take.length; i++) {\n            this.queue.push(take[i]);\n          }\n\n          window.setTimeout(function () {\n            return _this13.flush();\n          }, 20);\n        }\n\n        this.observer.disconnect();\n      }\n\n      if (this.onCharData) this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n      this.disconnectSelection();\n    }\n  }, {\n    key: \"connectSelection\",\n    value: function connectSelection() {\n      this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n  }, {\n    key: \"disconnectSelection\",\n    value: function disconnectSelection() {\n      this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n  }, {\n    key: \"suppressSelectionUpdates\",\n    value: function suppressSelectionUpdates() {\n      var _this14 = this;\n\n      this.suppressingSelectionUpdates = true;\n      setTimeout(function () {\n        return _this14.suppressingSelectionUpdates = false;\n      }, 50);\n    }\n  }, {\n    key: \"onSelectionChange\",\n    value: function onSelectionChange() {\n      if (!hasFocusAndSelection(this.view)) return;\n      if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);\n\n      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n        var sel = this.view.domSelectionRange();\n        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();\n      }\n\n      this.flush();\n    }\n  }, {\n    key: \"setCurSelection\",\n    value: function setCurSelection() {\n      this.currentSelection.set(this.view.domSelectionRange());\n    }\n  }, {\n    key: \"ignoreSelectionChange\",\n    value: function ignoreSelectionChange(sel) {\n      if (!sel.focusNode) return true;\n      var ancestors = new Set(),\n          container;\n\n      for (var scan = sel.focusNode; scan; scan = parentNode(scan)) {\n        ancestors.add(scan);\n      }\n\n      for (var _scan = sel.anchorNode; _scan; _scan = parentNode(_scan)) {\n        if (ancestors.has(_scan)) {\n          container = _scan;\n          break;\n        }\n      }\n\n      var desc = container && this.view.docView.nearestDesc(container);\n\n      if (desc && desc.ignoreMutation({\n        type: \"selection\",\n        target: container.nodeType == 3 ? container.parentNode : container\n      })) {\n        this.setCurSelection();\n        return true;\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var view = this.view;\n      if (!view.docView || this.flushingSoon > -1) return;\n      var mutations = this.observer ? this.observer.takeRecords() : [];\n\n      if (this.queue.length) {\n        mutations = this.queue.concat(mutations);\n        this.queue.length = 0;\n      }\n\n      var sel = view.domSelectionRange();\n      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n      var from = -1,\n          to = -1,\n          typeOver = false,\n          added = [];\n\n      if (view.editable) {\n        for (var i = 0; i < mutations.length; i++) {\n          var result = this.registerMutation(mutations[i], added);\n\n          if (result) {\n            from = from < 0 ? result.from : Math.min(result.from, from);\n            to = to < 0 ? result.to : Math.max(result.to, to);\n            if (result.typeOver) typeOver = true;\n          }\n        }\n      }\n\n      if (gecko && added.length > 1) {\n        var brs = added.filter(function (n) {\n          return n.nodeName == \"BR\";\n        });\n\n        if (brs.length == 2) {\n          var a = brs[0],\n              b = brs[1];\n          if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();else a.remove();\n        }\n      }\n\n      var readSel = null;\n\n      if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && view.input.lastTouch < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirrorState.Selection.near(view.state.doc.resolve(0), 1))) {\n        view.input.lastFocus = 0;\n        selectionToDOM(view);\n        this.currentSelection.set(sel);\n        view.scrollToSelection();\n      } else if (from > -1 || newSel) {\n        if (from > -1) {\n          view.docView.markDirty(from, to);\n          checkCSS(view);\n        }\n\n        this.handleDOMChange(from, to, typeOver, added);\n        if (view.docView && view.docView.dirty) view.updateState(view.state);else if (!this.currentSelection.eq(sel)) selectionToDOM(view);\n        this.currentSelection.set(sel);\n      }\n    }\n  }, {\n    key: \"registerMutation\",\n    value: function registerMutation(mut, added) {\n      if (added.indexOf(mut.target) > -1) return null;\n      var desc = this.view.docView.nearestDesc(mut.target);\n      if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))) return null;\n      if (!desc || desc.ignoreMutation(mut)) return null;\n\n      if (mut.type == \"childList\") {\n        for (var i = 0; i < mut.addedNodes.length; i++) {\n          added.push(mut.addedNodes[i]);\n        }\n\n        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {\n          from: desc.posBefore,\n          to: desc.posAfter\n        };\n        var prev = mut.previousSibling,\n            next = mut.nextSibling;\n\n        if (ie && ie_version <= 11 && mut.addedNodes.length) {\n          for (var _i14 = 0; _i14 < mut.addedNodes.length; _i14++) {\n            var _mut$addedNodes$_i = mut.addedNodes[_i14],\n                previousSibling = _mut$addedNodes$_i.previousSibling,\n                nextSibling = _mut$addedNodes$_i.nextSibling;\n            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;\n            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;\n          }\n        }\n\n        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n        var from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n        var to = desc.localPosFromDOM(mut.target, toOffset, 1);\n        return {\n          from: from,\n          to: to\n        };\n      } else if (mut.type == \"attributes\") {\n        return {\n          from: desc.posAtStart - desc.border,\n          to: desc.posAtEnd + desc.border\n        };\n      } else {\n        return {\n          from: desc.posAtStart,\n          to: desc.posAtEnd,\n          typeOver: mut.target.nodeValue == mut.oldValue\n        };\n      }\n    }\n  }]);\n\n  return DOMObserver;\n}();\n\nvar cssChecked = new WeakMap();\nvar cssCheckWarned = false;\n\nfunction checkCSS(view) {\n  if (cssChecked.has(view)) return;\n  cssChecked.set(view, null);\n\n  if (['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n    view.requiresGeckoHackNode = gecko;\n    if (cssCheckWarned) return;\n    console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n    cssCheckWarned = true;\n  }\n}\n\nfunction safariShadowSelectionRange(view) {\n  var found;\n\n  function read(event) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    found = event.getTargetRanges()[0];\n  }\n\n  view.dom.addEventListener(\"beforeinput\", read, true);\n  document.execCommand(\"indent\");\n  view.dom.removeEventListener(\"beforeinput\", read, true);\n  var anchorNode = found.startContainer,\n      anchorOffset = found.startOffset;\n  var focusNode = found.endContainer,\n      focusOffset = found.endOffset;\n  var currentAnchor = view.domAtPos(view.state.selection.anchor);\n\n  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) {\n    var _ref3 = [focusNode, focusOffset, anchorNode, anchorOffset];\n    anchorNode = _ref3[0];\n    anchorOffset = _ref3[1];\n    focusNode = _ref3[2];\n    focusOffset = _ref3[3];\n  }\n\n  return {\n    anchorNode: anchorNode,\n    anchorOffset: anchorOffset,\n    focusNode: focusNode,\n    focusOffset: focusOffset\n  };\n}\n\nfunction parseBetween(view, from_, to_) {\n  var _view$docView$parseRa = view.docView.parseRange(from_, to_),\n      parent = _view$docView$parseRa.node,\n      fromOffset = _view$docView$parseRa.fromOffset,\n      toOffset = _view$docView$parseRa.toOffset,\n      from = _view$docView$parseRa.from,\n      to = _view$docView$parseRa.to;\n\n  var domSel = view.domSelectionRange();\n  var find;\n  var anchor = domSel.anchorNode;\n\n  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n    find = [{\n      node: anchor,\n      offset: domSel.anchorOffset\n    }];\n    if (!selectionCollapsed(domSel)) find.push({\n      node: domSel.focusNode,\n      offset: domSel.focusOffset\n    });\n  }\n\n  if (chrome && view.input.lastKeyCode === 8) {\n    for (var off = toOffset; off > fromOffset; off--) {\n      var node = parent.childNodes[off - 1],\n          desc = node.pmViewDesc;\n\n      if (node.nodeName == \"BR\" && !desc) {\n        toOffset = off;\n        break;\n      }\n\n      if (!desc || desc.size) break;\n    }\n  }\n\n  var startDoc = view.state.doc;\n  var parser = view.someProp(\"domParser\") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);\n  var $from = startDoc.resolve(from);\n  var sel = null,\n      doc = parser.parse(parent, {\n    topNode: $from.parent,\n    topMatch: $from.parent.contentMatchAt($from.index()),\n    topOpen: true,\n    from: fromOffset,\n    to: toOffset,\n    preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n    findPositions: find,\n    ruleFromNode: ruleFromNode,\n    context: $from\n  });\n\n  if (find && find[0].pos != null) {\n    var _anchor = find[0].pos,\n        head = find[1] && find[1].pos;\n    if (head == null) head = _anchor;\n    sel = {\n      anchor: _anchor + from,\n      head: head + from\n    };\n  }\n\n  return {\n    doc: doc,\n    sel: sel,\n    from: from,\n    to: to\n  };\n}\n\nfunction ruleFromNode(dom) {\n  var desc = dom.pmViewDesc;\n\n  if (desc) {\n    return desc.parseRule();\n  } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n      var skip = document.createElement(\"div\");\n      skip.appendChild(document.createElement(\"li\"));\n      return {\n        skip: skip\n      };\n    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n      return {\n        ignore: true\n      };\n    }\n  } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n    return {\n      ignore: true\n    };\n  }\n\n  return null;\n}\n\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n  if (from < 0) {\n    var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n    var newSel = selectionFromDOM(view, origin);\n\n    if (newSel && !view.state.selection.eq(newSel)) {\n      var _tr = view.state.tr.setSelection(newSel);\n\n      if (origin == \"pointer\") _tr.setMeta(\"pointer\", true);else if (origin == \"key\") _tr.scrollIntoView();\n      view.dispatch(_tr);\n    }\n\n    return;\n  }\n\n  var $before = view.state.doc.resolve(from);\n  var shared = $before.sharedDepth(to);\n  from = $before.before(shared + 1);\n  to = view.state.doc.resolve(to).after(shared + 1);\n  var sel = view.state.selection;\n  var parse = parseBetween(view, from, to);\n  var doc = view.state.doc,\n      compare = doc.slice(parse.from, parse.to);\n  var preferredPos, preferredSide;\n\n  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n    preferredPos = view.state.selection.to;\n    preferredSide = \"end\";\n  } else {\n    preferredPos = view.state.selection.from;\n    preferredSide = \"start\";\n  }\n\n  view.input.lastKeyCode = null;\n  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n\n  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function (n) {\n    return n.nodeName == \"DIV\" || n.nodeName == \"P\";\n  }) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", function (f) {\n    return f(view, keyEvent(13, \"Enter\"));\n  })) {\n    view.input.lastIOSEnter = 0;\n    return;\n  }\n\n  if (!change) {\n    if (typeOver && sel instanceof prosemirrorState.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n      change = {\n        start: sel.from,\n        endA: sel.to,\n        endB: sel.to\n      };\n    } else {\n      if (parse.sel) {\n        var _sel = resolveSelection(view, view.state.doc, parse.sel);\n\n        if (_sel && !_sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(_sel));\n      }\n\n      return;\n    }\n  }\n\n  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {\n    var size = change.endB - change.start;\n    parse.sel = {\n      anchor: parse.sel.anchor + size,\n      head: parse.sel.anchor + size\n    };\n  }\n\n  view.input.domChangeCount++;\n\n  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirrorState.TextSelection) {\n    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n      change.start = view.state.selection.from;\n    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n      change.endB += view.state.selection.to - change.endA;\n      change.endA = view.state.selection.to;\n    }\n  }\n\n  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xA0\") {\n    change.start--;\n    change.endA--;\n    change.endB--;\n  }\n\n  var $from = parse.doc.resolveNoCache(change.start - parse.from);\n  var $to = parse.doc.resolveNoCache(change.endB - parse.from);\n  var $fromA = doc.resolve(change.start);\n  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n  var nextSel;\n\n  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function (n) {\n    return n.nodeName == \"DIV\" || n.nodeName == \"P\";\n  })) || !inlineChange && $from.pos < parse.doc.content.size && (nextSel = prosemirrorState.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp(\"handleKeyDown\", function (f) {\n    return f(view, keyEvent(13, \"Enter\"));\n  })) {\n    view.input.lastIOSEnter = 0;\n    return;\n  }\n\n  if (view.state.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", function (f) {\n    return f(view, keyEvent(8, \"Backspace\"));\n  })) {\n    if (android && chrome) view.domObserver.suppressSelectionUpdates();\n    return;\n  }\n\n  if (chrome && android && change.endB == change.start) view.input.lastAndroidDelete = Date.now();\n\n  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n    change.endB -= 2;\n    $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    setTimeout(function () {\n      view.someProp(\"handleKeyDown\", function (f) {\n        return f(view, keyEvent(13, \"Enter\"));\n      });\n    }, 20);\n  }\n\n  var chFrom = change.start,\n      chTo = change.endA;\n  var tr, storedMarks, markChange;\n\n  if (inlineChange) {\n    if ($from.pos == $to.pos) {\n      if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n        view.domObserver.suppressSelectionUpdates();\n        setTimeout(function () {\n          return selectionToDOM(view);\n        }, 20);\n      }\n\n      tr = view.state.tr[\"delete\"](chFrom, chTo);\n      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n      tr = view.state.tr;\n      if (markChange.type == \"add\") tr.addMark(chFrom, chTo, markChange.mark);else tr.removeMark(chFrom, chTo, markChange.mark);\n    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n      var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n      if (view.someProp(\"handleTextInput\", function (f) {\n        return f(view, chFrom, chTo, text);\n      })) return;\n      tr = view.state.tr.insertText(text, chFrom, chTo);\n    }\n  }\n\n  if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n\n  if (parse.sel) {\n    var _sel2 = resolveSelection(view, tr.doc, parse.sel);\n\n    if (_sel2 && !(chrome && android && view.composing && _sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (_sel2.head == chFrom || _sel2.head == tr.mapping.map(chTo) - 1) || ie && _sel2.empty && _sel2.head == chFrom)) tr.setSelection(_sel2);\n  }\n\n  if (storedMarks) tr.ensureMarks(storedMarks);\n  view.dispatch(tr.scrollIntoView());\n}\n\nfunction resolveSelection(view, doc, parsedSel) {\n  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;\n  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n\nfunction isMarkChange(cur, prev) {\n  var curMarks = cur.firstChild.marks,\n      prevMarks = prev.firstChild.marks;\n  var added = curMarks,\n      removed = prevMarks,\n      type,\n      mark,\n      update;\n\n  for (var i = 0; i < prevMarks.length; i++) {\n    added = prevMarks[i].removeFromSet(added);\n  }\n\n  for (var _i15 = 0; _i15 < curMarks.length; _i15++) {\n    removed = curMarks[_i15].removeFromSet(removed);\n  }\n\n  if (added.length == 1 && removed.length == 0) {\n    mark = added[0];\n    type = \"add\";\n\n    update = function update(node) {\n      return node.mark(mark.addToSet(node.marks));\n    };\n  } else if (added.length == 0 && removed.length == 1) {\n    mark = removed[0];\n    type = \"remove\";\n\n    update = function update(node) {\n      return node.mark(mark.removeFromSet(node.marks));\n    };\n  } else {\n    return null;\n  }\n\n  var updated = [];\n\n  for (var _i16 = 0; _i16 < prev.childCount; _i16++) {\n    updated.push(update(prev.child(_i16)));\n  }\n\n  if (prosemirrorModel.Fragment.from(updated).eq(cur)) return {\n    mark: mark,\n    type: type\n  };\n}\n\nfunction looksLikeJoin(old, start, end, $newStart, $newEnd) {\n  if (!$newStart.parent.isTextblock || end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;\n  var $start = old.resolve(start);\n  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;\n  var $next = old.resolve(skipClosingAndOpening($start, true, true));\n  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;\n  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\n\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n  var depth = $pos.depth,\n      end = fromEnd ? $pos.end() : $pos.pos;\n\n  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n    depth--;\n    end++;\n    fromEnd = false;\n  }\n\n  if (mayOpen) {\n    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n\n    while (next && !next.isLeaf) {\n      next = next.firstChild;\n      end++;\n    }\n  }\n\n  return end;\n}\n\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n  var start = a.findDiffStart(b, pos);\n  if (start == null) return null;\n\n  var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size),\n      endA = _a$findDiffEnd.a,\n      endB = _a$findDiffEnd.b;\n\n  if (preferredSide == \"end\") {\n    var adjust = Math.max(0, start - Math.min(endA, endB));\n    preferredPos -= endA + adjust - start;\n  }\n\n  if (endA < start && a.size < b.size) {\n    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n    start -= move;\n    endB = start + (endB - endA);\n    endA = start;\n  } else if (endB < start) {\n    var _move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n\n    start -= _move;\n    endA = start + (endA - endB);\n    endB = start;\n  }\n\n  return {\n    start: start,\n    endA: endA,\n    endB: endB\n  };\n}\n\nvar __serializeForClipboard = serializeForClipboard;\nvar __parseFromClipboard = parseFromClipboard;\nvar __endComposition = endComposition;\n\nvar EditorView = function () {\n  function EditorView(place, props) {\n    var _this15 = this;\n\n    _classCallCheck(this, EditorView);\n\n    this._root = null;\n    this.focused = false;\n    this.trackWrites = null;\n    this.mounted = false;\n    this.markCursor = null;\n    this.cursorWrapper = null;\n    this.lastSelectedViewDesc = undefined;\n    this.input = new InputState();\n    this.prevDirectPlugins = [];\n    this.pluginViews = [];\n    this.requiresGeckoHackNode = false;\n    this.dragging = null;\n    this._props = props;\n    this.state = props.state;\n    this.directPlugins = props.plugins || [];\n    this.directPlugins.forEach(checkStateComponent);\n    this.dispatch = this.dispatch.bind(this);\n    this.dom = place && place.mount || document.createElement(\"div\");\n\n    if (place) {\n      if (place.appendChild) place.appendChild(this.dom);else if (typeof place == \"function\") place(this.dom);else if (place.mount) this.mounted = true;\n    }\n\n    this.editable = getEditable(this);\n    updateCursorWrapper(this);\n    this.nodeViews = buildNodeViews(this);\n    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n    this.domObserver = new DOMObserver(this, function (from, to, typeOver, added) {\n      return readDOMChange(_this15, from, to, typeOver, added);\n    });\n    this.domObserver.start();\n    initInput(this);\n    this.updatePluginViews();\n  }\n\n  _createClass(EditorView, [{\n    key: \"composing\",\n    get: function get() {\n      return this.input.composing;\n    }\n  }, {\n    key: \"props\",\n    get: function get() {\n      if (this._props.state != this.state) {\n        var prev = this._props;\n        this._props = {};\n\n        for (var name in prev) {\n          this._props[name] = prev[name];\n        }\n\n        this._props.state = this.state;\n      }\n\n      return this._props;\n    }\n  }, {\n    key: \"update\",\n    value: function update(props) {\n      if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);\n      var prevProps = this._props;\n      this._props = props;\n\n      if (props.plugins) {\n        props.plugins.forEach(checkStateComponent);\n        this.directPlugins = props.plugins;\n      }\n\n      this.updateStateInner(props.state, prevProps);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      var updated = {};\n\n      for (var name in this._props) {\n        updated[name] = this._props[name];\n      }\n\n      updated.state = this.state;\n\n      for (var _name2 in props) {\n        updated[_name2] = props[_name2];\n      }\n\n      this.update(updated);\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(state) {\n      this.updateStateInner(state, this._props);\n    }\n  }, {\n    key: \"updateStateInner\",\n    value: function updateStateInner(state, prevProps) {\n      var prev = this.state,\n          redraw = false,\n          updateSel = false;\n\n      if (state.storedMarks && this.composing) {\n        clearComposition(this);\n        updateSel = true;\n      }\n\n      this.state = state;\n      var pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n\n      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n        var nodeViews = buildNodeViews(this);\n\n        if (changedNodeViews(nodeViews, this.nodeViews)) {\n          this.nodeViews = nodeViews;\n          redraw = true;\n        }\n      }\n\n      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n        ensureListeners(this);\n      }\n\n      this.editable = getEditable(this);\n      updateCursorWrapper(this);\n      var innerDeco = viewDecorations(this),\n          outerDeco = computeDocDeco(this);\n      var scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n      if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;\n      var oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n\n      if (updateSel) {\n        this.domObserver.stop();\n        var forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n\n        if (updateDoc) {\n          var chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n\n          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n            this.docView.updateOuterDeco([]);\n            this.docView.destroy();\n            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n          }\n\n          if (chromeKludge && !this.trackWrites) forceSelUpdate = true;\n        }\n\n        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n          selectionToDOM(this, forceSelUpdate);\n        } else {\n          syncNodeSelection(this, state.selection);\n          this.domObserver.setCurSelection();\n        }\n\n        this.domObserver.start();\n      }\n\n      this.updatePluginViews(prev);\n\n      if (scroll == \"reset\") {\n        this.dom.scrollTop = 0;\n      } else if (scroll == \"to selection\") {\n        this.scrollToSelection();\n      } else if (oldScrollPos) {\n        resetScrollPos(oldScrollPos);\n      }\n    }\n  }, {\n    key: \"scrollToSelection\",\n    value: function scrollToSelection() {\n      var _this16 = this;\n\n      var startDOM = this.domSelectionRange().focusNode;\n      if (this.someProp(\"handleScrollToSelection\", function (f) {\n        return f(_this16);\n      })) ;else if (this.state.selection instanceof prosemirrorState.NodeSelection) {\n        var target = this.docView.domAfterPos(this.state.selection.from);\n        if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n      } else {\n        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n      }\n    }\n  }, {\n    key: \"destroyPluginViews\",\n    value: function destroyPluginViews() {\n      var view;\n\n      while (view = this.pluginViews.pop()) {\n        if (view.destroy) view.destroy();\n      }\n    }\n  }, {\n    key: \"updatePluginViews\",\n    value: function updatePluginViews(prevState) {\n      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n        this.prevDirectPlugins = this.directPlugins;\n        this.destroyPluginViews();\n\n        for (var i = 0; i < this.directPlugins.length; i++) {\n          var plugin = this.directPlugins[i];\n          if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));\n        }\n\n        for (var _i17 = 0; _i17 < this.state.plugins.length; _i17++) {\n          var _plugin = this.state.plugins[_i17];\n          if (_plugin.spec.view) this.pluginViews.push(_plugin.spec.view(this));\n        }\n      } else {\n        for (var _i18 = 0; _i18 < this.pluginViews.length; _i18++) {\n          var pluginView = this.pluginViews[_i18];\n          if (pluginView.update) pluginView.update(this, prevState);\n        }\n      }\n    }\n  }, {\n    key: \"someProp\",\n    value: function someProp(propName, f) {\n      var prop = this._props && this._props[propName],\n          value;\n      if (prop != null && (value = f ? f(prop) : prop)) return value;\n\n      for (var i = 0; i < this.directPlugins.length; i++) {\n        var _prop = this.directPlugins[i].props[propName];\n        if (_prop != null && (value = f ? f(_prop) : _prop)) return value;\n      }\n\n      var plugins = this.state.plugins;\n      if (plugins) for (var _i19 = 0; _i19 < plugins.length; _i19++) {\n        var _prop2 = plugins[_i19].props[propName];\n        if (_prop2 != null && (value = f ? f(_prop2) : _prop2)) return value;\n      }\n    }\n  }, {\n    key: \"hasFocus\",\n    value: function hasFocus() {\n      if (ie) {\n        var node = this.root.activeElement;\n        if (node == this.dom) return true;\n        if (!node || !this.dom.contains(node)) return false;\n\n        while (node && this.dom != node && this.dom.contains(node)) {\n          if (node.contentEditable == 'false') return false;\n          node = node.parentElement;\n        }\n\n        return true;\n      }\n\n      return this.root.activeElement == this.dom;\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.domObserver.stop();\n      if (this.editable) focusPreventScroll(this.dom);\n      selectionToDOM(this);\n      this.domObserver.start();\n    }\n  }, {\n    key: \"root\",\n    get: function get() {\n      var _this17 = this;\n\n      var cached = this._root;\n\n      if (cached == null) {\n        var _loop5 = function _loop5(search) {\n          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n            if (!search.getSelection) Object.getPrototypeOf(search).getSelection = function () {\n              return search.ownerDocument.getSelection();\n            };\n            return {\n              v: _this17._root = search\n            };\n          }\n        };\n\n        for (var search = this.dom.parentNode; search; search = search.parentNode) {\n          var _ret3 = _loop5(search);\n\n          if (_typeof(_ret3) === \"object\") return _ret3.v;\n        }\n      }\n\n      return cached || document;\n    }\n  }, {\n    key: \"posAtCoords\",\n    value: function posAtCoords(coords) {\n      return _posAtCoords(this, coords);\n    }\n  }, {\n    key: \"coordsAtPos\",\n    value: function coordsAtPos(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      return _coordsAtPos(this, pos, side);\n    }\n  }, {\n    key: \"domAtPos\",\n    value: function domAtPos(pos) {\n      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.docView.domFromPos(pos, side);\n    }\n  }, {\n    key: \"nodeDOM\",\n    value: function nodeDOM(pos) {\n      var desc = this.docView.descAt(pos);\n      return desc ? desc.nodeDOM : null;\n    }\n  }, {\n    key: \"posAtDOM\",\n    value: function posAtDOM(node, offset) {\n      var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      var pos = this.docView.posFromDOM(node, offset, bias);\n      if (pos == null) throw new RangeError(\"DOM position not inside the editor\");\n      return pos;\n    }\n  }, {\n    key: \"endOfTextblock\",\n    value: function endOfTextblock(dir, state) {\n      return _endOfTextblock(this, state || this.state, dir);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (!this.docView) return;\n      destroyInput(this);\n      this.destroyPluginViews();\n\n      if (this.mounted) {\n        this.docView.update(this.state.doc, [], viewDecorations(this), this);\n        this.dom.textContent = \"\";\n      } else if (this.dom.parentNode) {\n        this.dom.parentNode.removeChild(this.dom);\n      }\n\n      this.docView.destroy();\n      this.docView = null;\n    }\n  }, {\n    key: \"isDestroyed\",\n    get: function get() {\n      return this.docView == null;\n    }\n  }, {\n    key: \"dispatchEvent\",\n    value: function dispatchEvent(event) {\n      return _dispatchEvent(this, event);\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(tr) {\n      var dispatchTransaction = this._props.dispatchTransaction;\n      if (dispatchTransaction) dispatchTransaction.call(this, tr);else this.updateState(this.state.apply(tr));\n    }\n  }, {\n    key: \"domSelectionRange\",\n    value: function domSelectionRange() {\n      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();\n    }\n  }, {\n    key: \"domSelection\",\n    value: function domSelection() {\n      return this.root.getSelection();\n    }\n  }]);\n\n  return EditorView;\n}();\n\nfunction computeDocDeco(view) {\n  var attrs = Object.create(null);\n  attrs[\"class\"] = \"ProseMirror\";\n  attrs.contenteditable = String(view.editable);\n  attrs.translate = \"no\";\n  view.someProp(\"attributes\", function (value) {\n    if (typeof value == \"function\") value = value(view.state);\n    if (value) for (var attr in value) {\n      if (attr == \"class\") attrs[\"class\"] += \" \" + value[attr];\n\n      if (attr == \"style\") {\n        attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n      } else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\") attrs[attr] = String(value[attr]);\n    }\n  });\n  return [Decoration.node(0, view.state.doc.content.size, attrs)];\n}\n\nfunction updateCursorWrapper(view) {\n  if (view.markCursor) {\n    var dom = document.createElement(\"img\");\n    dom.className = \"ProseMirror-separator\";\n    dom.setAttribute(\"mark-placeholder\", \"true\");\n    dom.setAttribute(\"alt\", \"\");\n    view.cursorWrapper = {\n      dom: dom,\n      deco: Decoration.widget(view.state.selection.head, dom, {\n        raw: true,\n        marks: view.markCursor\n      })\n    };\n  } else {\n    view.cursorWrapper = null;\n  }\n}\n\nfunction getEditable(view) {\n  return !view.someProp(\"editable\", function (value) {\n    return value(view.state) === false;\n  });\n}\n\nfunction selectionContextChanged(sel1, sel2) {\n  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\n\nfunction buildNodeViews(view) {\n  var result = Object.create(null);\n\n  function add(obj) {\n    for (var _prop3 in obj) {\n      if (!Object.prototype.hasOwnProperty.call(result, _prop3)) result[_prop3] = obj[_prop3];\n    }\n  }\n\n  view.someProp(\"nodeViews\", add);\n  view.someProp(\"markViews\", add);\n  return result;\n}\n\nfunction changedNodeViews(a, b) {\n  var nA = 0,\n      nB = 0;\n\n  for (var _prop4 in a) {\n    if (a[_prop4] != b[_prop4]) return true;\n    nA++;\n  }\n\n  for (var _ in b) {\n    nB++;\n  }\n\n  return nA != nB;\n}\n\nfunction checkStateComponent(plugin) {\n  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\nexports.Decoration = Decoration;\nexports.DecorationSet = DecorationSet;\nexports.EditorView = EditorView;\nexports.__endComposition = __endComposition;\nexports.__parseFromClipboard = __parseFromClipboard;\nexports.__serializeForClipboard = __serializeForClipboard;\n", "// Because working with row and column-spanning cells is not quite\n// trivial, this code builds up a descriptive structure for a given\n// table node. The structures are cached with the (persistent) table\n// nodes as key, so that they only have to be recomputed when the\n// content of the table changes.\n//\n// This does mean that they have to store table-relative, not\n// document-relative positions. So code that uses them will typically\n// compute the start position of the table and offset positions passed\n// to or gotten from this structure by that amount.\n\nlet readFromCache, addToCache;\n// Prefer using a weak map to cache table maps. Fall back on a\n// fixed-size cache if that's not supported.\nif (typeof WeakMap != 'undefined') {\n  // eslint-disable-next-line\n  let cache = new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  let cache = [],\n    cacheSize = 10,\n    cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key) return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize) cachePos = 0;\n    cache[cachePos++] = key;\n    return (cache[cachePos++] = value);\n  };\n}\n\nexport class Rect {\n  constructor(left, top, right, bottom) {\n    this.left = left;\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n  }\n}\n\n// ::- A table map describes the structore of a given table. To avoid\n// recomputing them all the time, they are cached per table node. To\n// be able to do that, positions saved in the map are relative to the\n// start of the table, rather than the start of the document.\nexport class TableMap {\n  constructor(width, height, map, problems) {\n    // :: number The width of the table\n    this.width = width;\n    // :: number The table's height\n    this.height = height;\n    // :: [number] A width * height array with the start position of\n    // the cell covering that part of the table in each slot\n    this.map = map;\n    // An optional array of problems (cell overlap or non-rectangular\n    // shape) for the table, used by the table normalizer.\n    this.problems = problems;\n  }\n\n  // :: (number) \u2192 Rect\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      let curPos = this.map[i];\n      if (curPos != pos) continue;\n      let left = i % this.width,\n        top = (i / this.width) | 0;\n      let right = left + 1,\n        bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++)\n        right++;\n      for (\n        let j = 1;\n        bottom < this.height && this.map[i + this.width * j] == curPos;\n        j++\n      )\n        bottom++;\n      return new Rect(left, top, right, bottom);\n    }\n    throw new RangeError('No cell with offset ' + pos + ' found');\n  }\n\n  // :: (number) \u2192 number\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++)\n      if (this.map[i] == pos) return i % this.width;\n    throw new RangeError('No cell with offset ' + pos + ' found');\n  }\n\n  // :: (number, string, number) \u2192 ?number\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    let { left, right, top, bottom } = this.findCell(pos);\n    if (axis == 'horiz') {\n      if (dir < 0 ? left == 0 : right == this.width) return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height) return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n\n  // :: (number, number) \u2192 Rect\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    let {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA,\n    } = this.findCell(a);\n    let {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB,\n    } = this.findCell(b);\n    return new Rect(\n      Math.min(leftA, leftB),\n      Math.min(topA, topB),\n      Math.max(rightA, rightB),\n      Math.max(bottomA, bottomB),\n    );\n  }\n\n  // :: (Rect) \u2192 [number]\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    let result = [],\n      seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let index = row * this.width + col,\n          pos = this.map[index];\n        if (seen[pos]) continue;\n        seen[pos] = true;\n        if (\n          (col != rect.left || !col || this.map[index - 1] != pos) &&\n          (row != rect.top || !row || this.map[index - this.width] != pos)\n        )\n          result.push(pos);\n      }\n    }\n    return result;\n  }\n\n  // :: (number, number, Node) \u2192 number\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      let rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width,\n          rowEndIndex = (row + 1) * this.width;\n        // Skip past cells from previous rows (via rowspan)\n        while (index < rowEndIndex && this.map[index] < rowStart) index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n\n  // :: (Node) \u2192 TableMap\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n}\n\n// Compute a table map.\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != 'table')\n    throw new RangeError('Not a table node: ' + table.type.name);\n  let width = findWidth(table),\n    height = table.childCount;\n  let map = [],\n    mapPos = 0,\n    problems = null,\n    colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++) map[i] = 0;\n\n  for (let row = 0, pos = 0; row < height; row++) {\n    let rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0) mapPos++;\n      if (i == rowNode.childCount) break;\n      let cellNode = rowNode.child(i),\n        { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: 'overlong_rowspan',\n            pos,\n            n: rowspan - h,\n          });\n          break;\n        }\n        let start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0) map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: 'collision',\n              row,\n              pos,\n              n: colspan - w,\n            });\n          let colW = colwidth && colwidth[w];\n          if (colW) {\n            let widthIndex = ((start + w) % width) * 2,\n              prev = colWidths[widthIndex];\n            if (\n              prev == null ||\n              (prev != colW && colWidths[widthIndex + 1] == 1)\n            ) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    let expectedPos = (row + 1) * width,\n      missing = 0;\n    while (mapPos < expectedPos) if (map[mapPos++] == 0) missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: 'missing', row, n: missing });\n    pos++;\n  }\n\n  let tableMap = new TableMap(width, height, map, problems),\n    badWidths = false;\n\n  // For columns that have defined widths, but whose widths disagree\n  // between rows, fix up the cells whose width doesn't match the\n  // computed one.\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;\n  if (badWidths) findBadColWidths(tableMap, colWidths, table);\n\n  return tableMap;\n}\n\nfunction findWidth(table) {\n  let width = -1,\n    hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    let rowNode = table.child(row),\n      rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        let prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          let cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      let cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1) hasRowSpan = true;\n    }\n    if (width == -1) width = rowWidth;\n    else if (width != rowWidth) width = Math.max(width, rowWidth);\n  }\n  return width;\n}\n\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems) map.problems = [];\n  for (let i = 0, seen = {}; i < map.map.length; i++) {\n    let pos = map.map[i];\n    if (seen[pos]) continue;\n    seen[pos] = true;\n    let node = table.nodeAt(pos),\n      updated = null;\n    for (let j = 0; j < node.attrs.colspan; j++) {\n      let col = (i + j) % map.width,\n        colWidth = colWidths[col * 2];\n      if (\n        colWidth != null &&\n        (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth)\n      )\n        (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: 'colwidth mismatch',\n        pos,\n        colwidth: updated,\n      });\n  }\n}\n\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth) return attrs.colwidth.slice();\n  let result = [];\n  for (let i = 0; i < attrs.colspan; i++) result.push(0);\n  return result;\n}\n", "// Helper for creating a schema that supports tables.\n\nfunction getCellAttrs(dom, extraAttrs) {\n  let widthAttr = dom.getAttribute('data-colwidth');\n  let widths =\n    widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr)\n      ? widthAttr.split(',').map((s) => Number(s))\n      : null;\n  let colspan = Number(dom.getAttribute('colspan') || 1);\n  let result = {\n    colspan,\n    rowspan: Number(dom.getAttribute('rowspan') || 1),\n    colwidth: widths && widths.length == colspan ? widths : null,\n  };\n  for (let prop in extraAttrs) {\n    let getter = extraAttrs[prop].getFromDOM;\n    let value = getter && getter(dom);\n    if (value != null) result[prop] = value;\n  }\n  return result;\n}\n\nfunction setCellAttrs(node, extraAttrs) {\n  let attrs = {};\n  if (node.attrs.colspan != 1) attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1) attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs['data-colwidth'] = node.attrs.colwidth.join(',');\n  for (let prop in extraAttrs) {\n    let setter = extraAttrs[prop].setDOMAttr;\n    if (setter) setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\n\n// :: (Object) \u2192 Object\n//\n// This function creates a set of [node\n// specs](http://prosemirror.net/docs/ref/#model.SchemaSpec.nodes) for\n// `table`, `table_row`, and `table_cell` nodes types as used by this\n// module. The result can then be added to the set of nodes when\n// creating a a schema.\n//\n//   options::- The following options are understood:\n//\n//     tableGroup:: ?string\n//     A group name (something like `\"block\"`) to add to the table\n//     node type.\n//\n//     cellContent:: string\n//     The content expression for table cells.\n//\n//     cellAttributes:: ?Object\n//     Additional attributes to add to cells. Maps attribute names to\n//     objects with the following properties:\n//\n//       default:: any\n//       The attribute's default value.\n//\n//       getFromDOM:: ?(dom.Node) \u2192 any\n//       A function to read the attribute's value from a DOM node.\n//\n//       setDOMAttr:: ?(value: any, attrs: Object)\n//       A function to add the attribute's value to an attribute\n//       object that's used to render the cell's DOM.\nexport function tableNodes(options) {\n  let extraAttrs = options.cellAttributes || {};\n  let cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null },\n  };\n  for (let prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n\n  return {\n    table: {\n      content: 'table_row+',\n      tableRole: 'table',\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: 'table' }],\n      toDOM() {\n        return ['table', ['tbody', 0]];\n      },\n    },\n    table_row: {\n      content: '(table_cell | table_header)*',\n      tableRole: 'row',\n      parseDOM: [{ tag: 'tr' }],\n      toDOM() {\n        return ['tr', 0];\n      },\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'cell',\n      isolating: true,\n      parseDOM: [\n        { tag: 'td', getAttrs: (dom) => getCellAttrs(dom, extraAttrs) },\n      ],\n      toDOM(node) {\n        return ['td', setCellAttrs(node, extraAttrs), 0];\n      },\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: 'header_cell',\n      isolating: true,\n      parseDOM: [\n        { tag: 'th', getAttrs: (dom) => getCellAttrs(dom, extraAttrs) },\n      ],\n      toDOM(node) {\n        return ['th', setCellAttrs(node, extraAttrs), 0];\n      },\n    },\n  };\n}\n\nexport function tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (let name in schema.nodes) {\n      let type = schema.nodes[name],\n        role = type.spec.tableRole;\n      if (role) result[role] = type;\n    }\n  }\n  return result;\n}\n", "// Various helper function for working with tables\n\nimport { PluginKey } from 'prosemirror-state';\n\nimport { TableMap } from './tablemap';\nimport { tableNodeTypes } from './schema';\n\nexport const key = new PluginKey('selectingCells');\n\nexport function cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == 'row')\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\n\nexport function cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    // Sometimes the cell can be in the same depth.\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === 'cell' || role === 'header_cell') return $pos.node(d);\n  }\n  return null;\n}\n\nexport function isInTable(state) {\n  let $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == 'row') return true;\n  return false;\n}\n\nexport function selectionCell(state) {\n  let sel = state.selection;\n  if (sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos\n      ? sel.$anchorCell\n      : sel.$headCell;\n  } else if (sel.node && sel.node.type.spec.tableRole == 'cell') {\n    return sel.$anchor;\n  }\n  return cellAround(sel.$head) || cellNear(sel.$head);\n}\n\nfunction cellNear($pos) {\n  for (\n    let after = $pos.nodeAfter, pos = $pos.pos;\n    after;\n    after = after.firstChild, pos++\n  ) {\n    let role = after.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell') return $pos.doc.resolve(pos);\n  }\n  for (\n    let before = $pos.nodeBefore, pos = $pos.pos;\n    before;\n    before = before.lastChild, pos--\n  ) {\n    let role = before.type.spec.tableRole;\n    if (role == 'cell' || role == 'header_cell')\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\n\nexport function pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == 'row' && $pos.nodeAfter;\n}\n\nexport function moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\n\nexport function inSameTable($a, $b) {\n  return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);\n}\n\nexport function findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\n\nexport function colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\n\nexport function nextCell($pos, axis, dir) {\n  let start = $pos.start(-1),\n    map = TableMap.get($pos.node(-1));\n  let moved = map.nextCell($pos.pos - start, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(start + moved);\n}\n\nexport function setAttr(attrs, name, value) {\n  let result = {};\n  for (let prop in attrs) result[prop] = attrs[prop];\n  result[name] = value;\n  return result;\n}\n\nexport function removeColSpan(attrs, pos, n = 1) {\n  let result = setAttr(attrs, 'colspan', attrs.colspan - n);\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;\n  }\n  return result;\n}\n\nexport function addColSpan(attrs, pos, n = 1) {\n  let result = setAttr(attrs, 'colspan', attrs.colspan + n);\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\n\nexport function columnIsHeader(map, table, col) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n", "// This file defines a ProseMirror selection subclass that models\n// table cell selections. The table plugin needs to be active to wire\n// in the user interaction part of table selections (so that you\n// actually get such selections when you select across cells).\n\nimport {\n  Selection,\n  TextSelection,\n  NodeSelection,\n  SelectionRange,\n} from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { Fragment, Slice } from 'prosemirror-model';\n\nimport { inSameTable, pointsAtCell, setAttr, removeColSpan } from './util';\nimport { TableMap } from './tablemap';\n\n// ::- A [`Selection`](http://prosemirror.net/docs/ref/#state.Selection)\n// subclass that represents a cell selection spanning part of a table.\n// With the plugin enabled, these will be created when the user\n// selects across cells, and will be drawn by giving selected cells a\n// `selectedCell` CSS class.\nexport class CellSelection extends Selection {\n  // :: (ResolvedPos, ?ResolvedPos)\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    let table = $anchorCell.node(-1),\n      map = TableMap.get(table),\n      start = $anchorCell.start(-1);\n    let rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);\n    let doc = $anchorCell.node(0);\n    let cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - start);\n    // Make the head cell the first range, so that it counts as the\n    // primary part of the selection\n    cells.unshift($headCell.pos - start);\n    let ranges = cells.map((pos) => {\n      let cell = table.nodeAt(pos),\n        from = pos + start + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size),\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    // :: ResolvedPos\n    // A resolved position pointing _in front of_ the anchor cell (the one\n    // that doesn't move when extending the selection).\n    this.$anchorCell = $anchorCell;\n    // :: ResolvedPos\n    // A resolved position pointing in front of the head cell (the one\n    // moves when extending the selection).\n    this.$headCell = $headCell;\n  }\n\n  map(doc, mapping) {\n    let $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    let $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (\n      pointsAtCell($anchorCell) &&\n      pointsAtCell($headCell) &&\n      inSameTable($anchorCell, $headCell)\n    ) {\n      let tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return CellSelection.colSelection($anchorCell, $headCell);\n      else return new CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n\n  // :: () \u2192 Slice\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    let table = this.$anchorCell.node(-1),\n      map = TableMap.get(table),\n      start = this.$anchorCell.start(-1);\n    let rect = map.rectBetween(\n      this.$anchorCell.pos - start,\n      this.$headCell.pos - start,\n    );\n    let seen = {},\n      rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      let rowContent = [];\n      for (\n        let index = row * map.width + rect.left, col = rect.left;\n        col < rect.right;\n        col++, index++\n      ) {\n        let pos = map.map[index];\n        if (!seen[pos]) {\n          seen[pos] = true;\n          let cellRect = map.findCell(pos),\n            cell = table.nodeAt(pos);\n          let extraLeft = rect.left - cellRect.left,\n            extraRight = cellRect.right - rect.right;\n          if (extraLeft > 0 || extraRight > 0) {\n            let attrs = cell.attrs;\n            if (extraLeft > 0) attrs = removeColSpan(attrs, 0, extraLeft);\n            if (extraRight > 0)\n              attrs = removeColSpan(\n                attrs,\n                attrs.colspan - extraRight,\n                extraRight,\n              );\n            if (cellRect.left < rect.left)\n              cell = cell.type.createAndFill(attrs);\n            else cell = cell.type.create(attrs, cell.content);\n          }\n          if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n            let attrs = setAttr(\n              cell.attrs,\n              'rowspan',\n              Math.min(cellRect.bottom, rect.bottom) -\n                Math.max(cellRect.top, rect.top),\n            );\n            if (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs);\n            else cell = cell.type.create(attrs, cell.content);\n          }\n          rowContent.push(cell);\n        }\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n\n    const fragment =\n      this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n\n  replace(tr, content = Slice.empty) {\n    let mapFrom = tr.steps.length,\n      ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      let { $from, $to } = ranges[i],\n        mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content,\n      );\n    }\n    let sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1,\n    );\n    if (sel) tr.setSelection(sel);\n  }\n\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n\n  forEachCell(f) {\n    let table = this.$anchorCell.node(-1),\n      map = TableMap.get(table),\n      start = this.$anchorCell.start(-1);\n    let cells = map.cellsInRect(\n      map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start),\n    );\n    for (let i = 0; i < cells.length; i++)\n      f(table.nodeAt(cells[i]), start + cells[i]);\n  }\n\n  // :: () \u2192 bool\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    let anchorTop = this.$anchorCell.index(-1),\n      headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0) return false;\n    let anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan,\n      headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;\n  }\n\n  // :: (ResolvedPos, ?ResolvedPos) \u2192 CellSelection\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)),\n      start = $anchorCell.start(-1);\n    let anchorRect = map.findCell($anchorCell.pos - start),\n      headRect = map.findCell($headCell.pos - start);\n    let doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(start + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          start + map.map[map.width * (map.height - 1) + headRect.right - 1],\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(start + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          start + map.map[map.width * (map.height - 1) + anchorRect.right - 1],\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  // :: () \u2192 bool\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    let map = TableMap.get(this.$anchorCell.node(-1)),\n      start = this.$anchorCell.start(-1);\n    let anchorLeft = map.colCount(this.$anchorCell.pos - start),\n      headLeft = map.colCount(this.$headCell.pos - start);\n    if (Math.min(anchorLeft, headLeft) > 0) return false;\n    let anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan,\n      headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n\n  eq(other) {\n    return (\n      other instanceof CellSelection &&\n      other.$anchorCell.pos == this.$anchorCell.pos &&\n      other.$headCell.pos == this.$headCell.pos\n    );\n  }\n\n  // :: (ResolvedPos, ?ResolvedPos) \u2192 CellSelection\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    let map = TableMap.get($anchorCell.node(-1)),\n      start = $anchorCell.start(-1);\n    let anchorRect = map.findCell($anchorCell.pos - start),\n      headRect = map.findCell($headCell.pos - start);\n    let doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]);\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          start + map.map[map.width * (headRect.top + 1) - 1],\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(start + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          start + map.map[map.width * (anchorRect.top + 1) - 1],\n        );\n    }\n    return new CellSelection($anchorCell, $headCell);\n  }\n\n  toJSON() {\n    return {\n      type: 'cell',\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos,\n    };\n  }\n\n  static fromJSON(doc, json) {\n    return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n\n  // :: (Node, number, ?number) \u2192 CellSelection\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n}\n\nCellSelection.prototype.visible = false;\n\nSelection.jsonID('cell', CellSelection);\n\nclass CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    let $anchorCell = doc.resolve(this.anchor),\n      $headCell = doc.resolve(this.head);\n    if (\n      $anchorCell.parent.type.spec.tableRole == 'row' &&\n      $headCell.parent.type.spec.tableRole == 'row' &&\n      $anchorCell.index() < $anchorCell.parent.childCount &&\n      $headCell.index() < $headCell.parent.childCount &&\n      inSameTable($anchorCell, $headCell)\n    )\n      return new CellSelection($anchorCell, $headCell);\n    else return Selection.near($headCell, 1);\n  }\n}\n\nexport function drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection)) return null;\n  let cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: 'selectedCell' }),\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\n\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6) return false; // Cheap elimination\n  let afterFrom = $from.pos,\n    beforeTo = $to.pos,\n    depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth)) break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d)) break;\n  return (\n    afterFrom == beforeTo &&\n    /row|table/.test($from.node(depth).type.spec.tableRole)\n  );\n}\n\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n\n  for (let i = $from.depth; i > 0; i--) {\n    let node = $from.node(i);\n    if (\n      node.type.spec.tableRole === 'cell' ||\n      node.type.spec.tableRole === 'header_cell'\n    ) {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  for (let i = $to.depth; i > 0; i--) {\n    let node = $to.node(i);\n    if (\n      node.type.spec.tableRole === 'cell' ||\n      node.type.spec.tableRole === 'header_cell'\n    ) {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\n\nexport function normalizeSelection(state, tr, allowTableNodeSelection) {\n  let sel = (tr || state).selection,\n    doc = (tr || state).doc,\n    normalize,\n    role;\n  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {\n    if (role == 'cell' || role == 'header_cell') {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == 'row') {\n      let $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      let map = TableMap.get(sel.node),\n        start = sel.from + 1;\n      let lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize) (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n", "// Utilities used for copy/paste handling.\n//\n// This module handles pasting cell content into tables, or pasting\n// anything into a cell selection, as replacing a block of cells with\n// the content of the selection. When pasting cells into a cell, that\n// involves placing the block of pasted content so that its top left\n// aligns with the selection cell, optionally extending the table to\n// the right or bottom to make sure it is large enough. Pasting into a\n// cell selection is different, here the cells in the selection are\n// clipped to the selection's rectangle, optionally repeating the\n// pasted cells when they are smaller than the selection.\n\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { Transform } from 'prosemirror-transform';\n\nimport { setAttr, removeColSpan } from './util';\nimport { TableMap } from './tablemap';\nimport { CellSelection } from './cellselection';\nimport { tableNodeTypes } from './schema';\n\n// Utilities to help with copying and pasting table cells\n\n// : (Slice) \u2192 ?{width: number, height: number, rows: [Fragment]}\n// Get a rectangular area of cells from a slice, or null if the outer\n// nodes of the slice aren't table cells or rows.\nexport function pastedCells(slice) {\n  if (!slice.size) return null;\n  let { content, openStart, openEnd } = slice;\n  while (\n    content.childCount == 1 &&\n    ((openStart > 0 && openEnd > 0) ||\n      content.firstChild.type.spec.tableRole == 'table')\n  ) {\n    openStart--;\n    openEnd--;\n    content = content.firstChild.content;\n  }\n  let first = content.firstChild,\n    role = first.type.spec.tableRole;\n  let schema = first.type.schema,\n    rows = [];\n  if (role == 'row') {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      let left = i ? 0 : Math.max(0, openStart - 1);\n      let right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice(cells, left, right),\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == 'cell' || role == 'header_cell') {\n    rows.push(\n      openStart || openEnd\n        ? fitSlice(\n            tableNodeTypes(schema).row,\n            new Slice(content, openStart, openEnd),\n          ).content\n        : content,\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\n\n// : (Schema, [Fragment]) \u2192 {width: number, height: number, rows: [Fragment]}\n// Compute the width and height of a set of cells, and make sure each\n// row has the same number of cells.\nfunction ensureRectangular(schema, rows) {\n  let widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    let row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      let { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++) width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length) rows.push(Fragment.empty);\n    if (widths[r] < width) {\n      let empty = tableNodeTypes(schema).cell.createAndFill(),\n        cells = [];\n      for (let i = widths[r]; i < width; i++) cells.push(empty);\n      rows[r] = rows[r].append(Fragment.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\n\nexport function fitSlice(nodeType, slice) {\n  let node = nodeType.createAndFill();\n  let tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\n\n// : ({width: number, height: number, rows: [Fragment]}, number, number) \u2192 {width: number, height: number, rows: [Fragment]}\n// Clip or extend (repeat) the given set of cells to cover the given\n// width and height. Will clip rowspan/colspan cells at the edges when\n// they stick out.\nexport function clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    let added = [],\n      newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      let frag = rows[row],\n        cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.create(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth,\n            ),\n            cell.content,\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n\n  if (height != newHeight) {\n    let newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      let cells = [],\n        source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            setAttr(\n              cell.attrs,\n              'rowspan',\n              Math.max(1, newHeight - cell.attrs.rowspan),\n            ),\n            cell.content,\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n\n  return { width, height, rows };\n}\n\n// Make sure a table has at least the given width and height. Return\n// true if something was changed.\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  let schema = tr.doc.type.schema,\n    types = tableNodeTypes(schema),\n    empty,\n    emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      let rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      let cells = [],\n        add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++) cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    let cells = [];\n    for (\n      let i = 0, start = (map.height - 1) * map.width;\n      i < Math.max(map.width, width);\n      i++\n    ) {\n      let header =\n        i >= map.width\n          ? false\n          : table.nodeAt(map.map[start + i]).type == types.header_cell;\n      cells.push(\n        header\n          ? emptyHead || (emptyHead = types.header_cell.createAndFill())\n          : empty || (empty = types.cell.createAndFill()),\n      );\n    }\n\n    let emptyRow = types.row.create(null, Fragment.from(cells)),\n      rows = [];\n    for (let i = map.height; i < height; i++) rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\n\n// Make sure the given line (left, top) to (right, top) doesn't cross\n// any rowspan cells by splitting cells that cross it. Return true if\n// something changed.\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height) return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    let index = top * map.width + col,\n      pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      let cell = table.nodeAt(pos);\n      let { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapFrom).map(pos + start),\n        null,\n        setAttr(cell.attrs, 'rowspan', top - cellTop),\n      );\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill(\n          setAttr(cell.attrs, 'rowspan', cellTop + cell.attrs.rowspan - top),\n        ),\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\n\n// Make sure the given line (left, top) to (left, bottom) doesn't\n// cross any colspan cells by splitting cells that cross it. Return\n// true if something changed.\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width) return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    let index = row * map.width + left,\n      pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      let cell = table.nodeAt(pos),\n        cellLeft = map.colCount(pos);\n      let updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft),\n        ),\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft)),\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\n\n// Insert the given set of cells (as returned by `pastedCells`) into a\n// table, at the position pointed at by rect.\nexport function insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc,\n    map = TableMap.get(table);\n  let { top, left } = rect;\n  let right = left + cells.width,\n    bottom = top + cells.height;\n  let tr = state.tr,\n    mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  // Prepare the table to be large enough and not have any cells\n  // crossing the boundaries of the rectangle that we want to\n  // insert into. If anything about it changes, recompute the table\n  // map so that subsequent operations can see the current shape.\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom)) recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (\n    isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom)\n  )\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n\n  for (let row = top; row < bottom; row++) {\n    let from = map.positionAt(row, left, table),\n      to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice(cells.rows[row - top], 0, 0),\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table)),\n    ),\n  );\n  dispatch(tr);\n}\n", "// This file defines a number of helpers for wiring up user input to\n// table-related functionality.\n\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { Selection, TextSelection } from 'prosemirror-state';\nimport { keydownHandler } from 'prosemirror-keymap';\n\nimport {\n  key,\n  nextCell,\n  cellAround,\n  inSameTable,\n  isInTable,\n  selectionCell,\n} from './util';\nimport { CellSelection } from './cellselection';\nimport { TableMap } from './tablemap';\nimport { pastedCells, fitSlice, clipCells, insertCells } from './copypaste';\nimport { tableNodeTypes } from './schema';\n\nexport const handleKeyDown = keydownHandler({\n  ArrowLeft: arrow('horiz', -1),\n  ArrowRight: arrow('horiz', 1),\n  ArrowUp: arrow('vert', -1),\n  ArrowDown: arrow('vert', 1),\n\n  'Shift-ArrowLeft': shiftArrow('horiz', -1),\n  'Shift-ArrowRight': shiftArrow('horiz', 1),\n  'Shift-ArrowUp': shiftArrow('vert', -1),\n  'Shift-ArrowDown': shiftArrow('vert', 1),\n\n  Backspace: deleteCellSelection,\n  'Mod-Backspace': deleteCellSelection,\n  Delete: deleteCellSelection,\n  'Mod-Delete': deleteCellSelection,\n});\n\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection)) return false;\n  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\n\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection.near(sel.$headCell, dir),\n      );\n    }\n    if (axis != 'horiz' && !sel.empty) return false;\n    let end = atEndOfCell(view, axis, dir);\n    if (end == null) return false;\n    if (axis == 'horiz') {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection.near(state.doc.resolve(sel.head + dir), dir),\n      );\n    } else {\n      let $cell = state.doc.resolve(end),\n        $next = nextCell($cell, axis, dir),\n        newSel;\n      if ($next) newSel = Selection.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);\n      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\n\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    let sel = state.selection;\n    if (!(sel instanceof CellSelection)) {\n      let end = atEndOfCell(view, axis, dir);\n      if (end == null) return false;\n      sel = new CellSelection(state.doc.resolve(end));\n    }\n    let $head = nextCell(sel.$headCell, axis, dir);\n    if (!$head) return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(sel.$anchorCell, $head),\n    );\n  };\n}\n\nfunction deleteCellSelection(state, dispatch) {\n  let sel = state.selection;\n  if (!(sel instanceof CellSelection)) return false;\n  if (dispatch) {\n    let tr = state.tr,\n      baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice(baseContent, 0, 0),\n        );\n    });\n    if (tr.docChanged) dispatch(tr);\n  }\n  return true;\n}\n\nexport function handleTripleClick(view, pos) {\n  let doc = view.state.doc,\n    $cell = cellAround(doc.resolve(pos));\n  if (!$cell) return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\n\nexport function handlePaste(view, _, slice) {\n  if (!isInTable(view.state)) return false;\n  let cells = pastedCells(slice),\n    sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice),\n          ),\n        ],\n      };\n    let table = sel.$anchorCell.node(-1),\n      start = sel.$anchorCell.start(-1);\n    let rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start,\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    let $cell = selectionCell(view.state),\n      start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells,\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\n\nexport function handleMouseDown(view, startEvent) {\n  if (startEvent.ctrlKey || startEvent.metaKey) return;\n\n  let startDOMCell = domInCell(view, startEvent.target),\n    $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    // Adding to an existing cell selection\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (\n    startEvent.shiftKey &&\n    startDOMCell &&\n    ($anchor = cellAround(view.state.selection.$anchor)) != null &&\n    cellUnderMouse(view, startEvent).pos != $anchor.pos\n  ) {\n    // Adding to a selection that starts in another cell (causing a\n    // cell selection to be created).\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    // Not in a cell, let the default behavior happen.\n    return;\n  }\n\n  // Create and dispatch a cell selection between the given anchor and\n  // the position under the mouse.\n  function setCellSelection($anchor, event) {\n    let $head = cellUnderMouse(view, event);\n    let starting = key.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor, $head)) {\n      if (starting) $head = $anchor;\n      else return;\n    }\n    let selection = new CellSelection($anchor, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      let tr = view.state.tr.setSelection(selection);\n      if (starting) tr.setMeta(key, $anchor.pos);\n      view.dispatch(tr);\n    }\n  }\n\n  // Stop listening to mouse motion events.\n  function stop() {\n    view.root.removeEventListener('mouseup', stop);\n    view.root.removeEventListener('dragstart', stop);\n    view.root.removeEventListener('mousemove', move);\n    if (key.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(key, -1));\n  }\n\n  function move(event) {\n    let anchor = key.getState(view.state),\n      $anchor;\n    if (anchor != null) {\n      // Continuing an existing cross-cell selection\n      $anchor = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      // Moving out of the initial cell -- start a new cell selection\n      $anchor = cellUnderMouse(view, startEvent);\n      if (!$anchor) return stop();\n    }\n    if ($anchor) setCellSelection($anchor, event);\n  }\n  view.root.addEventListener('mouseup', stop);\n  view.root.addEventListener('dragstart', stop);\n  view.root.addEventListener('mousemove', move);\n}\n\n// Check whether the cursor is at the end of a cell (so that further\n// motion would move out of the cell)\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection)) return null;\n  let { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    let parent = $head.node(d),\n      index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount)) return null;\n    if (\n      parent.type.spec.tableRole == 'cell' ||\n      parent.type.spec.tableRole == 'header_cell'\n    ) {\n      let cellPos = $head.before(d);\n      let dirStr =\n        axis == 'vert' ? (dir > 0 ? 'down' : 'up') : dir > 0 ? 'right' : 'left';\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\n\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode)\n    if (dom.nodeName == 'TD' || dom.nodeName == 'TH') return dom;\n}\n\nfunction cellUnderMouse(view, event) {\n  let mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n  if (!mousePos) return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n", "// This file defines helpers for normalizing tables, making sure no\n// cells overlap (which can happen, if you have the wrong col- and\n// rowspans) and that each row has the same width. Uses the problems\n// reported by `TableMap`.\n\nimport { PluginKey } from 'prosemirror-state';\nimport { TableMap } from './tablemap';\nimport { setAttr, removeColSpan } from './util';\nimport { tableNodeTypes } from './schema';\n\nexport const fixTablesKey = new PluginKey('fix-tables');\n\n// Helper for iterating through the nodes in a document that changed\n// compared to the given previous document. Useful for avoiding\n// duplicate work on each transaction.\nfunction changedDescendants(old, cur, offset, f) {\n  let oldSize = old.childCount,\n    curSize = cur.childCount;\n  outer: for (let i = 0, j = 0; i < curSize; i++) {\n    let child = cur.child(i);\n    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n      if (old.child(scan) == child) {\n        j = scan + 1;\n        offset += child.nodeSize;\n        continue outer;\n      }\n    }\n    f(child, offset);\n    if (j < oldSize && old.child(j).sameMarkup(child))\n      changedDescendants(old.child(j), child, offset + 1, f);\n    else child.nodesBetween(0, child.content.size, f, offset + 1);\n    offset += child.nodeSize;\n  }\n}\n\n// :: (EditorState, ?EditorState) \u2192 ?Transaction\n// Inspect all tables in the given state's document and return a\n// transaction that fixes them, if necessary. If `oldState` was\n// provided, that is assumed to hold a previous, known-good state,\n// which will be used to avoid re-scanning unchanged parts of the\n// document.\nexport function fixTables(state, oldState) {\n  let tr,\n    check = (node, pos) => {\n      if (node.type.spec.tableRole == 'table')\n        tr = fixTable(state, node, pos, tr);\n    };\n  if (!oldState) state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\n\n// : (EditorState, Node, number, ?Transaction) \u2192 ?Transaction\n// Fix the given table, if necessary. Will append to the transaction\n// it was given, if non-null, or create a new one if necessary.\nexport function fixTable(state, table, tablePos, tr) {\n  let map = TableMap.get(table);\n  if (!map.problems) return tr;\n  if (!tr) tr = state.tr;\n\n  // Track which rows we must add cells to, so that we can adjust that\n  // when fixing collisions.\n  let mustAdd = [];\n  for (let i = 0; i < map.height; i++) mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    let prob = map.problems[i];\n    if (prob.type == 'collision') {\n      let cell = table.nodeAt(prob.pos);\n      for (let j = 0; j < cell.attrs.rowspan; j++)\n        mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n),\n      );\n    } else if (prob.type == 'missing') {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == 'overlong_rowspan') {\n      let cell = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        setAttr(cell.attrs, 'rowspan', cell.attrs.rowspan - prob.n),\n      );\n    } else if (prob.type == 'colwidth mismatch') {\n      let cell = table.nodeAt(prob.pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        setAttr(cell.attrs, 'colwidth', prob.colwidth),\n      );\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null) first = i;\n      last = i;\n    }\n  // Add the necessary cells, using a heuristic for whether to add the\n  // cells at the start or end of the rows (if it looks like a 'bite'\n  // was taken out of the table, add cells at the start of the row\n  // after the bite. Otherwise add them at the end).\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    let row = table.child(i);\n    let end = pos + row.nodeSize;\n    let add = mustAdd[i];\n    if (add > 0) {\n      let tableNodeType = 'cell';\n      if (row.firstChild) {\n        tableNodeType = row.firstChild.type.spec.tableRole;\n      }\n      let nodes = [];\n      for (let j = 0; j < add; j++)\n        nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());\n      let side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n", "// This file defines a number of table-related commands.\n\nimport { TextSelection } from 'prosemirror-state';\nimport { Fragment } from 'prosemirror-model';\n\nimport { Rect, TableMap } from './tablemap';\nimport { CellSelection } from './cellselection';\nimport {\n  addColSpan,\n  cellAround,\n  cellWrapping,\n  columnIsHeader,\n  isInTable,\n  moveCellForward,\n  removeColSpan,\n  selectionCell,\n  setAttr,\n} from './util';\nimport { tableNodeTypes } from './schema';\n\n// Helper to get the selected rectangle in a table, if any. Adds table\n// map, table node, and table start offset to the object for\n// convenience.\nexport function selectedRect(state) {\n  let sel = state.selection,\n    $pos = selectionCell(state);\n  let table = $pos.node(-1),\n    tableStart = $pos.start(-1),\n    map = TableMap.get(table);\n  let rect;\n  if (sel instanceof CellSelection)\n    rect = map.rectBetween(\n      sel.$anchorCell.pos - tableStart,\n      sel.$headCell.pos - tableStart,\n    );\n  else rect = map.findCell($pos.pos - tableStart);\n  rect.tableStart = tableStart;\n  rect.map = map;\n  rect.table = table;\n  return rect;\n}\n\n// Add a column at the given position in a table.\nexport function addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn))\n    refColumn = col == 0 || col == map.width ? null : 0;\n\n  for (let row = 0; row < map.height; row++) {\n    let index = row * map.width + col;\n    // If this position falls inside a col-spanning cell\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      let pos = map.map[index],\n        cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos)),\n      );\n      // Skip ahead if rowspan > 1\n      row += cell.attrs.rowspan - 1;\n    } else {\n      let type =\n        refColumn == null\n          ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refColumn]).type;\n      let pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Command to add a column before the column with the selection.\nexport function addColumnBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Command to add a column after the column with the selection.\nexport function addColumnAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\n\nexport function removeColumn(tr, { map, table, tableStart }, col) {\n  let mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    let index = row * map.width + col,\n      pos = map.map[index],\n      cell = table.nodeAt(pos);\n    // If this is part of a col-spanning cell\n    if (\n      (col > 0 && map.map[index - 1] == pos) ||\n      (col < map.width - 1 && map.map[index + 1] == pos)\n    ) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(cell.attrs, col - map.colCount(pos)),\n      );\n    } else {\n      let start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += cell.attrs.rowspan;\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Command function that removes the selected columns from a table.\nexport function deleteColumn(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width) return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left) break;\n      rect.table = rect.tableStart\n        ? tr.doc.nodeAt(rect.tableStart - 1)\n        : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\n\nexport function rowIsHeader(map, table, row) {\n  let headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\nexport function addRow(tr, { map, tableStart, table }, row) {\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  let cells = [],\n    refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    // Covered by a rowspan cell\n    if (\n      row > 0 &&\n      row < map.height &&\n      map.map[index] == map.map[index - map.width]\n    ) {\n      let pos = map.map[index],\n        attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(\n        tableStart + pos,\n        null,\n        setAttr(attrs, 'rowspan', attrs.rowspan + 1),\n      );\n      col += attrs.colspan - 1;\n    } else {\n      let type =\n        refRow == null\n          ? tableNodeTypes(table.type.schema).cell\n          : table.nodeAt(map.map[index + refRow * map.width]).type;\n      cells.push(type.createAndFill());\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Add a table row before the selection.\nexport function addRowBefore(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Add a table row after the selection.\nexport function addRowAfter(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\n\nexport function removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;\n  let nextRow = rowPos + table.child(row).nodeSize;\n\n  let mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    let pos = map.map[index];\n    if (row > 0 && pos == map.map[index - map.width]) {\n      // If this cell starts in the row above, simply reduce its rowspan\n      let attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapFrom).map(pos + tableStart),\n        null,\n        setAttr(attrs, 'rowspan', attrs.rowspan - 1),\n      );\n      col += attrs.colspan - 1;\n    } else if (row < map.width && pos == map.map[index + map.width]) {\n      // Else, if it continues in the row below, it has to be moved down\n      let cell = table.nodeAt(pos);\n      let copy = cell.type.create(\n        setAttr(cell.attrs, 'rowspan', cell.attrs.rowspan - 1),\n        cell.content,\n      );\n      let newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += cell.attrs.colspan - 1;\n    }\n  }\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Remove the selected rows from a table.\nexport function deleteRow(state, dispatch) {\n  if (!isInTable(state)) return false;\n  if (dispatch) {\n    let rect = selectedRect(state),\n      tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height) return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top) break;\n      rect.table = rect.tableStart\n        ? tr.doc.nodeAt(rect.tableStart - 1)\n        : tr.doc;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\n\nfunction isEmpty(cell) {\n  let c = cell.content;\n  return (\n    c.childCount == 1 &&\n    c.firstChild.isTextblock &&\n    c.firstChild.childCount == 0\n  );\n}\n\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left,\n    indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left,\n    indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (\n      (rect.left > 0 && map[indexLeft] == map[indexLeft - 1]) ||\n      (rect.right < width && map[indexRight] == map[indexRight + 1])\n    )\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (\n      (rect.top > 0 && map[indexTop] == map[indexTop - width]) ||\n      (rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n    )\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Merge the selected cells into a single cell. Only available when\n// the selected cells' outline forms a rectangle.\nexport function mergeCells(state, dispatch) {\n  let sel = state.selection;\n  if (\n    !(sel instanceof CellSelection) ||\n    sel.$anchorCell.pos == sel.$headCell.pos\n  )\n    return false;\n  let rect = selectedRect(state),\n    { map } = rect;\n  if (cellsOverlapRectangle(map, rect)) return false;\n  if (dispatch) {\n    let tr = state.tr,\n      seen = {},\n      content = Fragment.empty,\n      mergedPos,\n      mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        let cellPos = map.map[row * map.width + col],\n          cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos]) continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell)) content = content.append(cell.content);\n          let mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    tr.setNodeMarkup(\n      mergedPos + rect.tableStart,\n      null,\n      setAttr(\n        addColSpan(\n          mergedCell.attrs,\n          mergedCell.attrs.colspan,\n          rect.right - rect.left - mergedCell.attrs.colspan,\n        ),\n        'rowspan',\n        rect.bottom - rect.top,\n      ),\n    );\n    if (content.size) {\n      let end = mergedPos + 1 + mergedCell.content.size;\n      let start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)),\n    );\n    dispatch(tr);\n  }\n  return true;\n}\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells. Use the first cell type for the new cells.\nexport function splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\n\n// :: (getCellType: ({ row: number, col: number, node: Node}) \u2192 NodeType) \u2192 (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Split a selected cell, whose rowpan or colspan is greater than one,\n// into smaller cells with the cell type (th, td) returned by getType function.\nexport function splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    let sel = state.selection;\n    let cellNode, cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode) return false;\n      cellPos = cellAround(sel.$from).pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs,\n        attrs = [],\n        colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1) baseAttrs = setAttr(baseAttrs, 'rowspan', 1);\n      if (baseAttrs.colspan > 1) baseAttrs = setAttr(baseAttrs, 'colspan', 1);\n      let rect = selectedRect(state),\n        tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth\n            ? setAttr(\n                baseAttrs,\n                'colwidth',\n                colwidth && colwidth[i] ? [colwidth[i]] : null,\n              )\n            : baseAttrs,\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top) pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top) continue;\n          tr.insert(\n            (lastCell = tr.mapping.map(pos + rect.tableStart, 1)),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i]),\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0],\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell && tr.doc.resolve(lastCell),\n          ),\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n// :: (string, any) \u2192 (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Returns a command that sets the given attribute to the given value,\n// and is only available when the currently selected cell doesn't\n// already have that attribute set to that value.\nexport function setCellAttr(name, value) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    let $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value) return false;\n    if (dispatch) {\n      let tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value));\n        });\n      else\n        tr.setNodeMarkup(\n          $cell.pos,\n          null,\n          setAttr($cell.nodeAfter.attrs, name, value),\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\nfunction deprecated_toggleHeader(type) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema);\n      let rect = selectedRect(state),\n        tr = state.tr;\n      let cells = rect.map.cellsInRect(\n        type == 'column'\n          ? new Rect(rect.left, 0, rect.right, rect.map.height)\n          : type == 'row'\n          ? new Rect(0, rect.top, rect.map.width, rect.bottom)\n          : rect,\n      );\n      let nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (\n        let i = 0;\n        i < cells.length;\n        i++ // Remove headers, if any\n      )\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs,\n          );\n      if (tr.steps.length == 0)\n        for (\n          let i = 0;\n          i < cells.length;\n          i++ // No headers removed, add instead\n        )\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs,\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\nfunction isHeaderEnabledByType(type, rect, types) {\n  // Get cell positions for first row or first column\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == 'row' ? rect.map.width : 1,\n    bottom: type == 'column' ? rect.map.height : 1,\n  });\n\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// :: (string, ?{ useDeprecatedLogic: bool }) \u2192 (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Toggles between row/column header and normal cells (Only applies to first row/column).\n// For deprecated behavior pass `useDeprecatedLogic` in options with true.\nexport function toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n\n  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);\n\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    if (dispatch) {\n      let types = tableNodeTypes(state.schema);\n      let rect = selectedRect(state),\n        tr = state.tr;\n\n      let isHeaderRowEnabled = isHeaderEnabledByType('row', rect, types);\n      let isHeaderColumnEnabled = isHeaderEnabledByType('column', rect, types);\n\n      let isHeaderEnabled =\n        type === 'column'\n          ? isHeaderRowEnabled\n          : type === 'row'\n          ? isHeaderColumnEnabled\n          : false;\n\n      let selectionStartsAt = isHeaderEnabled ? 1 : 0;\n\n      let cellsRect =\n        type == 'column'\n          ? new Rect(0, selectionStartsAt, 1, rect.map.height)\n          : type == 'row'\n          ? new Rect(selectionStartsAt, 0, rect.map.width, 1)\n          : rect;\n\n      let newType =\n        type == 'column'\n          ? isHeaderColumnEnabled\n            ? types.cell\n            : types.header_cell\n          : type == 'row'\n          ? isHeaderRowEnabled\n            ? types.cell\n            : types.header_cell\n          : types.cell;\n\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Toggles whether the selected row contains header cells.\nexport let toggleHeaderRow = toggleHeader('row', { useDeprecatedLogic: true });\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Toggles whether the selected column contains header cells.\nexport let toggleHeaderColumn = toggleHeader('column', {\n  useDeprecatedLogic: true,\n});\n\n// :: (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Toggles whether the selected cells are header cells.\nexport let toggleHeaderCell = toggleHeader('cell', {\n  useDeprecatedLogic: true,\n});\n\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    let before = $cell.nodeBefore;\n    if (before) return $cell.pos - before.nodeSize;\n    for (\n      let row = $cell.index(-1) - 1, rowEnd = $cell.before();\n      row >= 0;\n      row--\n    ) {\n      let rowNode = $cell.node(-1).child(row);\n      if (rowNode.childCount) return rowEnd - 1 - rowNode.lastChild.nodeSize;\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1)\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    let table = $cell.node(-1);\n    for (\n      let row = $cell.indexAfter(-1), rowStart = $cell.after();\n      row < table.childCount;\n      row++\n    ) {\n      let rowNode = table.child(row);\n      if (rowNode.childCount) return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n}\n\n// :: (number) \u2192 (EditorState, dispatch: ?(tr: Transaction)) \u2192 bool\n// Returns a command for selecting the next (direction=1) or previous\n// (direction=-1) cell in a table.\nexport function goToNextCell(direction) {\n  return function (state, dispatch) {\n    if (!isInTable(state)) return false;\n    let cell = findNextCell(selectionCell(state), direction);\n    if (cell == null) return;\n    if (dispatch) {\n      let $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr\n          .setSelection(TextSelection.between($cell, moveCellForward($cell)))\n          .scrollIntoView(),\n      );\n    }\n    return true;\n  };\n}\n\n// :: (EditorState, ?(tr: Transaction)) \u2192 bool\n// Deletes the table around the selection, if any.\nexport function deleteTable(state, dispatch) {\n  let $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    let node = $pos.node(d);\n    if (node.type.spec.tableRole == 'table') {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView(),\n        );\n      return true;\n    }\n  }\n  return false;\n}\n", "export class TableView {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement('div');\n    this.dom.className = 'tableWrapper';\n    this.table = this.dom.appendChild(document.createElement('table'));\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n    updateColumns(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n  }\n\n  update(node) {\n    if (node.type != this.node.type) return false;\n    this.node = node;\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n\n  ignoreMutation(record) {\n    return (\n      record.type == 'attributes' &&\n      (record.target == this.table || this.colgroup.contains(record.target))\n    );\n  }\n}\n\nexport function updateColumns(\n  node,\n  colgroup,\n  table,\n  cellMinWidth,\n  overrideCol,\n  overrideValue,\n) {\n  let totalWidth = 0,\n    fixedWidth = true;\n  let nextDOM = colgroup.firstChild,\n    row = node.firstChild;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    let { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      let hasWidth =\n        overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      let cssWidth = hasWidth ? hasWidth + 'px' : '';\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth) fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement('col')).style.width =\n          cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n\n  while (nextDOM) {\n    let after = nextDOM.nextSibling;\n    nextDOM.parentNode.removeChild(nextDOM);\n    nextDOM = after;\n  }\n\n  if (fixedWidth) {\n    table.style.width = totalWidth + 'px';\n    table.style.minWidth = '';\n  } else {\n    table.style.width = '';\n    table.style.minWidth = totalWidth + 'px';\n  }\n}\n", "import { Plugin, PluginKey } from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { cellAround, pointsAtCell, setAttr } from './util';\nimport { TableMap } from './tablemap';\nimport { TableView, updateColumns } from './tableview';\nimport { tableNodeTypes } from './schema';\n\nexport const key = new PluginKey('tableColumnResizing');\n\nexport function columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true,\n} = {}) {\n  let plugin = new Plugin({\n    key,\n    state: {\n      init(_, state) {\n        this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (\n          node,\n          view,\n        ) => new View(node, cellMinWidth, view);\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      },\n    },\n    props: {\n      attributes(state) {\n        let pluginState = key.getState(state);\n        return pluginState.activeHandle > -1\n          ? { class: 'resize-cursor' }\n          : null;\n      },\n\n      handleDOMEvents: {\n        mousemove(view, event) {\n          handleMouseMove(\n            view,\n            event,\n            handleWidth,\n            cellMinWidth,\n            lastColumnResizable,\n          );\n        },\n        mouseleave(view) {\n          handleMouseLeave(view);\n        },\n        mousedown(view, event) {\n          handleMouseDown(view, event, cellMinWidth);\n        },\n      },\n\n      decorations(state) {\n        let pluginState = key.getState(state);\n        if (pluginState.activeHandle > -1)\n          return handleDecorations(state, pluginState.activeHandle);\n      },\n\n      nodeViews: {},\n    },\n  });\n  return plugin;\n}\n\nclass ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n\n  apply(tr) {\n    let state = this,\n      action = tr.getMeta(key);\n    if (action && action.setHandle != null)\n      return new ResizeState(action.setHandle, null);\n    if (action && action.setDragging !== undefined)\n      return new ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) handle = null;\n      state = new ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n}\n\nfunction handleMouseMove(\n  view,\n  event,\n  handleWidth,\n  cellMinWidth,\n  lastColumnResizable,\n) {\n  let pluginState = key.getState(view.state);\n\n  if (!pluginState.dragging) {\n    let target = domCellAround(event.target),\n      cell = -1;\n    if (target) {\n      let { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, 'left');\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, 'right');\n    }\n\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        let $cell = view.state.doc.resolve(cell);\n        let table = $cell.node(-1),\n          map = TableMap.get(table),\n          start = $cell.start(-1);\n        let col =\n          map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n\n      updateHandle(view, cell);\n    }\n  }\n}\n\nfunction handleMouseLeave(view) {\n  let pluginState = key.getState(view.state);\n  if (pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\n\nfunction handleMouseDown(view, event, cellMinWidth) {\n  let pluginState = key.getState(view.state);\n  if (pluginState.activeHandle == -1 || pluginState.dragging) return false;\n\n  let cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  let width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(key, {\n      setDragging: { startX: event.clientX, startWidth: width },\n    }),\n  );\n\n  function finish(event) {\n    window.removeEventListener('mouseup', finish);\n    window.removeEventListener('mousemove', move);\n    let pluginState = key.getState(view.state);\n    if (pluginState.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState.activeHandle,\n        draggedWidth(pluginState.dragging, event, cellMinWidth),\n      );\n      view.dispatch(view.state.tr.setMeta(key, { setDragging: null }));\n    }\n  }\n  function move(event) {\n    if (!event.which) return finish(event);\n    let pluginState = key.getState(view.state);\n    let dragged = draggedWidth(pluginState.dragging, event, cellMinWidth);\n    displayColumnWidth(view, pluginState.activeHandle, dragged, cellMinWidth);\n  }\n\n  window.addEventListener('mouseup', finish);\n  window.addEventListener('mousemove', move);\n  event.preventDefault();\n  return true;\n}\n\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  let width = colwidth && colwidth[colwidth.length - 1];\n  if (width) return width;\n  let dom = view.domAtPos(cellPos);\n  let node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth,\n    parts = colspan;\n  if (colwidth)\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  return domWidth / parts;\n}\n\nfunction domCellAround(target) {\n  while (target && target.nodeName != 'TD' && target.nodeName != 'TH')\n    target =\n      target.classList && target.classList.contains('ProseMirror')\n        ? null\n        : target.parentNode;\n  return target;\n}\n\nfunction edgeCell(view, event, side) {\n  let found = view.posAtCoords({ left: event.clientX, top: event.clientY });\n  if (!found) return -1;\n  let { pos } = found;\n  let $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell) return -1;\n  if (side == 'right') return $cell.pos;\n  let map = TableMap.get($cell.node(-1)),\n    start = $cell.start(-1);\n  let index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\n\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  let offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\n\nfunction updateHandle(view, value) {\n  view.dispatch(view.state.tr.setMeta(key, { setHandle: value }));\n}\n\nfunction updateColumnWidth(view, cell, width) {\n  let $cell = view.state.doc.resolve(cell);\n  let table = $cell.node(-1),\n    map = TableMap.get(table),\n    start = $cell.start(-1);\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    let mapIndex = row * map.width + col;\n    // Rowspanning cell that has already been handled\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width]) continue;\n    let pos = map.map[mapIndex],\n      { attrs } = table.nodeAt(pos);\n    let index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width) continue;\n    let colwidth = attrs.colwidth\n      ? attrs.colwidth.slice()\n      : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, setAttr(attrs, 'colwidth', colwidth));\n  }\n  if (tr.docChanged) view.dispatch(tr);\n}\n\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  let $cell = view.state.doc.resolve(cell);\n  let table = $cell.node(-1),\n    start = $cell.start(-1);\n  let col =\n    TableMap.get(table).colCount($cell.pos - start) +\n    $cell.nodeAfter.attrs.colspan -\n    1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom.nodeName != 'TABLE') dom = dom.parentNode;\n  updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);\n}\n\nfunction zeroes(n) {\n  let result = [];\n  for (let i = 0; i < n; i++) result.push(0);\n  return result;\n}\n\nexport function handleDecorations(state, cell) {\n  let decorations = [];\n  let $cell = state.doc.resolve(cell);\n  let table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet.empty;\n  }\n  let map = TableMap.get(table);\n  let start = $cell.start(-1);\n  let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;\n  for (let row = 0; row < map.height; row++) {\n    let index = col + row * map.width - 1;\n    // For positions that are have either a different cell or the end\n    // of the table to their right, and either the top of the table or\n    // a different cell above them, add a decoration\n    if (\n      (col == map.width || map.map[index] != map.map[index + 1]) &&\n      (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])\n    ) {\n      let cellPos = map.map[index];\n      let pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      let dom = document.createElement('div');\n      dom.className = 'column-resize-handle';\n      decorations.push(Decoration.widget(pos, dom));\n    }\n  }\n  return DecorationSet.create(state.doc, decorations);\n}\n", "// This file defines a plugin that handles the drawing of cell\n// selections and the basic user interactions for creating and working\n// with such selections. It also makes sure that, after each\n// transaction, the shapes of tables are normalized to be rectangular\n// and not contain overlapping cells.\n\nimport { Plugin } from 'prosemirror-state';\n\nimport {\n  handleTripleClick,\n  handleKeyDown,\n  handlePaste,\n  handleMouseDown,\n} from './input';\nimport { key as tableEditingKey } from './util';\nimport { drawCellSelection, normalizeSelection } from './cellselection';\nimport { fixTables, fixTablesKey } from './fixtables';\n\n// :: () \u2192 Plugin\n//\n// Creates a [plugin](http://prosemirror.net/docs/ref/#state.Plugin)\n// that, when added to an editor, enables cell-selection, handles\n// cell-based copy/paste, and makes sure tables stay well-formed (each\n// row has the same width, and cells don't overlap).\n//\n// You should probably put this plugin near the end of your array of\n// plugins, since it handles mouse and arrow key events in tables\n// rather broadly, and other plugins, like the gap cursor or the\n// column-width dragging plugin, might want to get a turn first to\n// perform more specific behavior.\nexport function tableEditing({ allowTableNodeSelection = false } = {}) {\n  return new Plugin({\n    key: tableEditingKey,\n\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        let set = tr.getMeta(tableEditingKey);\n        if (set != null) return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged) return cur;\n        let { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      },\n    },\n\n    props: {\n      decorations: drawCellSelection,\n\n      handleDOMEvents: {\n        mousedown: handleMouseDown,\n      },\n\n      createSelectionBetween(view) {\n        if (tableEditingKey.getState(view.state) != null)\n          return view.state.selection;\n      },\n\n      handleTripleClick,\n\n      handleKeyDown,\n\n      handlePaste,\n    },\n\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection,\n      );\n    },\n  });\n}\n\nexport { fixTables, handlePaste, fixTablesKey };\nexport {\n  cellAround,\n  isInTable,\n  selectionCell,\n  moveCellForward,\n  inSameTable,\n  findCell,\n  colCount,\n  nextCell,\n  setAttr,\n  pointsAtCell,\n  removeColSpan,\n  addColSpan,\n  columnIsHeader,\n} from './util';\nexport { tableNodes, tableNodeTypes } from './schema';\nexport { CellSelection } from './cellselection';\nexport { TableMap } from './tablemap';\nexport { tableEditingKey };\nexport * from './commands';\nexport {\n  columnResizing,\n  key as columnResizingPluginKey,\n} from './columnresizing';\nexport { updateColumns as updateColumnsOnResize, TableView } from './tableview';\nexport {\n  pastedCells as __pastedCells,\n  insertCells as __insertCells,\n  clipCells as __clipCells,\n} from './copypaste';\n", "import { NodeSelection, Selection } from 'prosemirror-state';\nimport { Fragment } from 'prosemirror-model';\nimport { findParentNodeOfType, findPositionOfNodeBefore } from './selection';\nimport {\n  cloneTr,\n  isNodeSelection,\n  replaceNodeAtPos,\n  removeNodeAtPos,\n  canInsert,\n  isEmptyParagraph\n} from './helpers';\n\n// :: (nodeType: union<NodeType, [NodeType]>) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes a node of a given `nodeType`. It will return an original transaction if parent node hasn't been found.\n//\n// ```javascript\n// dispatch(\n//   removeParentNodeOfType(schema.nodes.table)(tr)\n// );\n// ```\nexport const removeParentNodeOfType = nodeType => tr => {\n  const parent = findParentNodeOfType(nodeType)(tr.selection);\n  if (parent) {\n    return removeNodeAtPos(parent.pos)(tr);\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, content: union<ProseMirrorNode, Fragment>) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that replaces parent node of a given `nodeType` with the given `content`. It will return an original transaction if either parent node hasn't been found or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n//\n// dispatch(\n//  replaceParentNodeOfType(schema.nodes.table, node)(tr)\n// );\n// ```\nexport const replaceParentNodeOfType = (nodeType, content) => tr => {\n  if (!Array.isArray(nodeType)) {\n    nodeType = [nodeType];\n  }\n  for (let i = 0, count = nodeType.length; i < count; i++) {\n    const parent = findParentNodeOfType(nodeType[i])(tr.selection);\n    if (parent) {\n      const newTr = replaceNodeAtPos(parent.pos, content)(tr);\n      if (newTr !== tr) {\n        return newTr;\n      }\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes selected node. It will return an original transaction if current selection is not a `NodeSelection`.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedNode(tr)\n// );\n// ```\nexport const removeSelectedNode = tr => {\n  if (isNodeSelection(tr.selection)) {\n    const from = tr.selection.$from.pos;\n    const to = tr.selection.$to.pos;\n    return cloneTr(tr.delete(from, to));\n  }\n  return tr;\n};\n\n// :: (content: union<ProseMirrorNode, ProseMirrorFragment>) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that replaces selected node with a given `node`, keeping NodeSelection on the new `node`.\n// It will return the original transaction if either current selection is not a NodeSelection or replacing is not possible.\n//\n// ```javascript\n// const node = schema.nodes.paragraph.createChecked({}, schema.text('new'));\n// dispatch(\n//   replaceSelectedNode(node)(tr)\n// );\n// ```\nexport const replaceSelectedNode = content => tr => {\n  if (isNodeSelection(tr.selection)) {\n    const { $from, $to } = tr.selection;\n    if (\n      (content instanceof Fragment &&\n        $from.parent.canReplace($from.index(), $from.indexAfter(), content)) ||\n      $from.parent.canReplaceWith(\n        $from.index(),\n        $from.indexAfter(),\n        content.type\n      )\n    ) {\n      return cloneTr(\n        tr\n          .replaceWith($from.pos, $to.pos, content)\n          // restore node selection\n          .setSelection(new NodeSelection(tr.doc.resolve($from.pos)))\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (position: number, dir: ?number) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that tries to find a valid cursor selection starting at the given `position`\n// and searching back if `dir` is negative, and forward if positive.\n// If a valid cursor position hasn't been found, it will return the original transaction.\n//\n// ```javascript\n// dispatch(\n//   setTextSelection(5)(tr)\n// );\n// ```\nexport const setTextSelection = (position, dir = 1) => tr => {\n  const nextSelection = Selection.findFrom(tr.doc.resolve(position), dir, true);\n  if (nextSelection) {\n    return tr.setSelection(nextSelection);\n  }\n  return tr;\n};\n\nconst isSelectableNode = node => node.type && node.type.spec.selectable;\nconst shouldSelectNode = node => isSelectableNode(node) && node.type.isLeaf;\n\nconst setSelection = (node, pos, tr) => {\n  if (shouldSelectNode(node)) {\n    return tr.setSelection(new NodeSelection(tr.doc.resolve(pos)));\n  }\n  return setTextSelection(pos)(tr);\n};\n\n// :: (content: union<ProseMirrorNode, Fragment>, position: ?number, tryToReplace?: boolean) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that inserts a given `content` at the current cursor position, or at a given `position`, if it is allowed by schema. If schema restricts such nesting, it will try to find an appropriate place for a given node in the document, looping through parent nodes up until the root document node.\n// If `tryToReplace` is true and current selection is a NodeSelection, it will replace selected node with inserted content if its allowed by schema.\n// If cursor is inside of an empty paragraph, it will try to replace that paragraph with the given content. If insertion is successful and inserted node has content, it will set cursor inside of that content.\n// It will return an original transaction if the place for insertion hasn't been found.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   safeInsert(node)(tr)\n// );\n// ```\nexport const safeInsert = (content, position, tryToReplace) => tr => {\n  const hasPosition = typeof position === 'number';\n  const { $from } = tr.selection;\n  const $insertPos = hasPosition\n    ? tr.doc.resolve(position)\n    : isNodeSelection(tr.selection)\n    ? tr.doc.resolve($from.pos + 1)\n    : $from;\n  const { parent } = $insertPos;\n\n  // try to replace selected node\n  if (isNodeSelection(tr.selection) && tryToReplace) {\n    const oldTr = tr;\n    tr = replaceSelectedNode(content)(tr);\n    if (oldTr !== tr) {\n      return tr;\n    }\n  }\n\n  // try to replace an empty paragraph\n  if (isEmptyParagraph(parent)) {\n    const oldTr = tr;\n    tr = replaceParentNodeOfType(parent.type, content)(tr);\n    if (oldTr !== tr) {\n      const pos = isSelectableNode(content)\n        ? // for selectable node, selection position would be the position of the replaced parent\n          $insertPos.before($insertPos.depth)\n        : $insertPos.pos;\n      return setSelection(content, pos, tr);\n    }\n  }\n\n  // given node is allowed at the current cursor position\n  if (canInsert($insertPos, content)) {\n    tr.insert($insertPos.pos, content);\n    const pos = hasPosition\n      ? $insertPos.pos\n      : isSelectableNode(content)\n      ? // for atom nodes selection position after insertion is the previous pos\n        tr.selection.$anchor.pos - 1\n      : tr.selection.$anchor.pos;\n    return cloneTr(setSelection(content, pos, tr));\n  }\n\n  // looking for a place in the doc where the node is allowed\n  for (let i = $insertPos.depth; i > 0; i--) {\n    const pos = $insertPos.after(i);\n    const $pos = tr.doc.resolve(pos);\n    if (canInsert($pos, content)) {\n      tr.insert(pos, content);\n      return cloneTr(setSelection(content, pos, tr));\n    }\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, type: ?union<NodeType, null>, attrs: ?union<Object, null>, marks?: [Mark]) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a transaction that changes the type, attributes, and/or marks of the parent node of a given `nodeType`.\n//\n// ```javascript\n// const node = schema.nodes.extension.createChecked({});\n// dispatch(\n//   setParentNodeMarkup(schema.nodes.panel, null, { panelType })(tr);\n// );\n// ```\nexport const setParentNodeMarkup = (nodeType, type, attrs, marks) => tr => {\n  const parent = findParentNodeOfType(nodeType)(tr.selection);\n  if (parent) {\n    return cloneTr(\n      tr.setNodeMarkup(\n        parent.pos,\n        type,\n        Object.assign({}, parent.node.attrs, attrs),\n        marks\n      )\n    );\n  }\n  return tr;\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that sets a `NodeSelection` on a parent node of a `given\u00A0nodeType`.\n//\n// ```javascript\n// dispatch(\n//   selectParentNodeOfType([tableCell, tableHeader])(state.tr)\n// );\n// ```\nexport const selectParentNodeOfType = nodeType => tr => {\n  if (!isNodeSelection(tr.selection)) {\n    const parent = findParentNodeOfType(nodeType)(tr.selection);\n    if (parent) {\n      return cloneTr(tr.setSelection(NodeSelection.create(tr.doc, parent.pos)));\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that deletes previous node.\n//\n// ```javascript\n// dispatch(\n//   removeNodeBefore(state.tr)\n// );\n// ```\nexport const removeNodeBefore = tr => {\n  const position = findPositionOfNodeBefore(tr.selection);\n  if (typeof position === 'number') {\n    return removeNodeAtPos(position)(tr);\n  }\n  return tr;\n};\n", "import { NodeSelection } from 'prosemirror-state';\nimport { Fragment, Node as PMNode } from 'prosemirror-model';\nimport { TableMap } from 'prosemirror-tables';\nimport { setTextSelection } from './transforms';\nimport { findParentNodeClosestToPos } from './selection';\n\n// :: (selection: Selection) \u2192 boolean\n// Checks if current selection is a `NodeSelection`.\n//\n// ```javascript\n// if (isNodeSelection(tr.selection)) {\n//   // ...\n// }\n// ```\nexport const isNodeSelection = selection => {\n  return selection instanceof NodeSelection;\n};\n\n// (nodeType: union<NodeType, [NodeType]>) \u2192 boolean\n// Checks if the type a given `node` equals to a given `nodeType`.\nexport const equalNodeType = (nodeType, node) => {\n  return (\n    (Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1) ||\n    node.type === nodeType\n  );\n};\n\n// (tr: Transaction) \u2192 Transaction\n// Creates a new transaction object from a given transaction\nexport const cloneTr = tr => {\n  return Object.assign(Object.create(tr), tr).setTime(Date.now());\n};\n\n// (position: number, content: union<ProseMirrorNode, Fragment>) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a `replace` transaction that replaces a node at a given position with the given `content`.\n// It will return the original transaction if replacing is not possible.\n// `position` should point at the position immediately before the node.\nexport const replaceNodeAtPos = (position, content) => tr => {\n  const node = tr.doc.nodeAt(position);\n  const $pos = tr.doc.resolve(position);\n  if (canReplace($pos, content)) {\n    tr = tr.replaceWith(position, position + node.nodeSize, content);\n    const start = tr.selection.$from.pos - 1;\n    // put cursor inside of the inserted node\n    tr = setTextSelection(Math.max(start, 0), -1)(tr);\n    // move cursor to the start of the node\n    tr = setTextSelection(tr.selection.$from.start())(tr);\n    return cloneTr(tr);\n  }\n  return tr;\n};\n\n// ($pos: ResolvedPos, doc: ProseMirrorNode, content: union<ProseMirrorNode, Fragment>, ) \u2192 boolean\n// Checks if replacing a node at a given `$pos` inside of the `doc` node with the given `content` is possible.\nexport const canReplace = ($pos, content) => {\n  const node = $pos.node($pos.depth);\n  return (\n    node &&\n    node.type.validContent(\n      content instanceof Fragment ? content : Fragment.from(content)\n    )\n  );\n};\n\n// (position: number) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a `delete` transaction that removes a node at a given position with the given `node`.\n// `position` should point at the position immediately before the node.\nexport const removeNodeAtPos = position => tr => {\n  const node = tr.doc.nodeAt(position);\n  return cloneTr(tr.delete(position, position + node.nodeSize));\n};\n\n// (schema: Schema) \u2192 {[key: string]: NodeType}\n// Returns a map where keys are tableRoles and values are NodeTypes.\nexport const tableNodeTypes = schema => {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes;\n  }\n  const roles = {};\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type];\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType;\n    }\n  });\n  schema.cached.tableNodeTypes = roles;\n  return roles;\n};\n\n// :: ($pos: ResolvedPos, content: union<ProseMirrorNode, Fragment>) \u2192 boolean\n// Checks if a given `content` can be inserted at the given `$pos`\n//\n// ```javascript\n// const { selection: { $from } } = state;\n// const node = state.schema.nodes.atom.createChecked();\n// if (canInsert($from, node)) {\n//   // ...\n// }\n// ```\nexport const canInsert = ($pos, content) => {\n  const index = $pos.index();\n\n  if (content instanceof Fragment) {\n    return $pos.parent.canReplace(index, index, content);\n  } else if (content instanceof PMNode) {\n    return $pos.parent.canReplaceWith(index, index, content.type);\n  }\n  return false;\n};\n\n// (node: ProseMirrorNode) \u2192 boolean\n// Checks if a given `node` is an empty paragraph\nexport const isEmptyParagraph = node => {\n  return !node || (node.type.name === 'paragraph' && node.nodeSize === 2);\n};\n\n// ($pos: ResolvedPos) \u2192 ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning a table node closest to a given `$pos`.\n//\n// ```javascript\n// const table = findTableClosestToPos(state.doc.resolve(10));\n// ```\nexport const findTableClosestToPos = $pos => {\n  const predicate = node =>\n    node.type.spec.tableRole && /table/i.test(node.type.spec.tableRole);\n  return findParentNodeClosestToPos($pos, predicate);\n};\n\nexport const createCell = (cellType, cellContent = null) => {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent);\n  }\n\n  return cellType.createAndFill();\n};\n\n// (rect: {left: number, right: number, top: number, bottom: number}) \u2192 (selection: Selection) \u2192 boolean\n// Checks if a given CellSelection rect is selected\nexport const isRectSelected = rect => selection => {\n  const map = TableMap.get(selection.$anchorCell.node(-1));\n  const start = selection.$anchorCell.start(-1);\n  const cells = map.cellsInRect(rect);\n  const selectedCells = map.cellsInRect(\n    map.rectBetween(\n      selection.$anchorCell.pos - start,\n      selection.$headCell.pos - start\n    )\n  );\n\n  for (let i = 0, count = cells.length; i < count; i++) {\n    if (selectedCells.indexOf(cells[i]) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n// This function transposes an array of array flipping the columns for rows,\n// transposition is a familiar algebra concept;\n// you can get more details here:\n// https://en.wikipedia.org/wiki/Transpose\n//\n// ```javascript\n//\n//  const arr = [\n//    ['a1', 'a2', 'a3'],\n//    ['b1', 'b2', 'b3'],\n//    ['c1', 'c2', 'c3'],\n//    ['d1', 'd2', 'd3'],\n//  ];\n//\n//  const result = transpose(arr);\n//\n//  result === [\n//    ['a1', 'b1', 'c1', 'd1'],\n//    ['a2', 'b2', 'c2', 'd2'],\n//    ['a3', 'b3', 'c3', 'd3'],\n//  ]\n// ```\nexport const transpose = array => {\n  return array[0].map((_, i) => {\n    return array.map(column => column[i]);\n  });\n};\n\n// :: (tableNode: Node) -> Array<Node>\n// This function will transform the table node\n// into a matrix of rows and columns respecting merged cells,\n// for example this table will be convert to the below:\n//\n// ```\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\n//\n// ```javascript\n// array = [\n//   [A1, B1, C1, null],\n//   [A2, B2, null, D1],\n//   [A3. B3, C2, null],\n// ]\n// ```\nexport const convertTableNodeToArrayOfRows = tableNode => {\n  const map = TableMap.get(tableNode);\n  const rows = [];\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const rowCells = [];\n    const seen = {};\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      const cellPos = map.map[rowIndex * map.width + colIndex];\n      const cell = tableNode.nodeAt(cellPos);\n      const rect = map.findCell(cellPos);\n      if (seen[cellPos] || rect.top !== rowIndex) {\n        rowCells.push(null);\n        continue;\n      }\n      seen[cellPos] = true;\n\n      rowCells.push(cell);\n    }\n\n    rows.push(rowCells);\n  }\n\n  return rows;\n};\n\n// :: (tableNode: Node, tableArray: Array<Node>) -> Node\n// This function will transform a matrix of nodes\n// into table node respecting merged cells and rows configurations,\n// for example this array will be convert to the table below:\n//\n// ```javascript\n// array = [\n//   [A1, B1, C1, null],\n//   [A2, B2, null, D1],\n//   [A3. B3, C2, null],\n// ]\n// ```\n//\n// ```\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\nexport const convertArrayOfRowsToTableNode = (tableNode, arrayOfNodes) => {\n  const rowsPM = [];\n  const map = TableMap.get(tableNode);\n  for (let rowIndex = 0; rowIndex < map.height; rowIndex++) {\n    const row = tableNode.child(rowIndex);\n    const rowCells = [];\n\n    for (let colIndex = 0; colIndex < map.width; colIndex++) {\n      if (!arrayOfNodes[rowIndex][colIndex]) {\n        continue;\n      }\n      const cellPos = map.map[rowIndex * map.width + colIndex];\n\n      const cell = arrayOfNodes[rowIndex][colIndex];\n      const oldCell = tableNode.nodeAt(cellPos);\n      const newCell = oldCell.type.createChecked(\n        Object.assign({}, cell.attrs),\n        cell.content,\n        cell.marks\n      );\n      rowCells.push(newCell);\n    }\n\n    rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks));\n  }\n\n  const newTable = tableNode.type.createChecked(\n    tableNode.attrs,\n    rowsPM,\n    tableNode.marks\n  );\n\n  return newTable;\n};\n\nexport const moveTableColumn = (\n  table,\n  indexesOrigin,\n  indexesTarget,\n  direction\n) => {\n  let rows = transpose(convertTableNodeToArrayOfRows(table.node));\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n  rows = transpose(rows);\n\n  return convertArrayOfRowsToTableNode(table.node, rows);\n};\n\nexport const moveTableRow = (\n  table,\n  indexesOrigin,\n  indexesTarget,\n  direction\n) => {\n  let rows = convertTableNodeToArrayOfRows(table.node);\n\n  rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);\n\n  return convertArrayOfRowsToTableNode(table.node, rows);\n};\n\nconst moveRowInArrayOfRows = (\n  rows,\n  indexesOrigin,\n  indexesTarget,\n  directionOverride\n) => {\n  let direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;\n\n  const rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);\n  const positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;\n  let target;\n\n  if (directionOverride === -1 && direction === 1) {\n    target = indexesTarget[0] - 1;\n  } else if (directionOverride === 1 && direction === -1) {\n    target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;\n  } else {\n    target =\n      direction === -1\n        ? indexesTarget[0]\n        : indexesTarget[indexesTarget.length - 1] - positionOffset;\n  }\n\n  rows.splice.apply(rows, [target, 0].concat(rowsExtracted));\n  return rows;\n};\n\nexport const checkInvalidMovements = (\n  originIndex,\n  targetIndex,\n  targets,\n  type\n) => {\n  const direction = originIndex > targetIndex ? -1 : 1;\n  const errorMessage = `Target position is invalid, you can't move the ${type} ${originIndex} to ${targetIndex}, the target can't be split. You could use tryToFit option.`;\n\n  if (direction === 1) {\n    if (targets.slice(0, targets.length - 1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  } else {\n    if (targets.slice(1).indexOf(targetIndex) !== -1) {\n      throw new Error(errorMessage);\n    }\n  }\n\n  return true;\n};\n", "import { Selection } from 'prosemirror-state';\nimport { equalNodeType, isNodeSelection } from './helpers';\n\n// :: (predicate: (node: ProseMirrorNode) \u2192 boolean) \u2192 (selection: Selection) \u2192 ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNode(predicate)(selection);\n// ```\nexport const findParentNode = predicate => ({ $from }) =>\n  findParentNodeClosestToPos($from, predicate);\n\n// :: ($pos: ResolvedPos, predicate: (node: ProseMirrorNode) \u2192 boolean) \u2192 ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning the closest node and its start position `predicate` returns truthy for. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const predicate = node => node.type === schema.nodes.blockquote;\n// const parent = findParentNodeClosestToPos(state.doc.resolve(5), predicate);\n// ```\nexport const findParentNodeClosestToPos = ($pos, predicate) => {\n  for (let i = $pos.depth; i > 0; i--) {\n    const node = $pos.node(i);\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node\n      };\n    }\n  }\n};\n\n// :: (predicate: (node: ProseMirrorNode) \u2192 boolean, domAtPos: (pos: number) \u2192 {node: dom.Node, offset: number}) \u2192 (selection: Selection) \u2192 ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node `predicate` returns truthy for.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const predicate = node => node.type === schema.nodes.table;\n// const parent = findParentDomRef(predicate, domAtPos)(selection); // <table>\n// ```\nexport const findParentDomRef = (predicate, domAtPos) => selection => {\n  const parent = findParentNode(predicate)(selection);\n  if (parent) {\n    return findDomRefAtPos(parent.pos, domAtPos);\n  }\n};\n\n// :: (predicate: (node: ProseMirrorNode) \u2192 boolean) \u2192 (selection: Selection) \u2192 boolean\n// Checks if there's a parent node `predicate` returns truthy for.\n//\n// ```javascript\n// if (hasParentNode(node => node.type === schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNode = predicate => selection => {\n  return !!findParentNode(predicate)(selection);\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) \u2192 (selection: Selection) \u2192 ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfType(schema.nodes.paragraph)(selection);\n// ```\nexport const findParentNodeOfType = nodeType => selection => {\n  return findParentNode(node => equalNodeType(nodeType, node))(selection);\n};\n\n// :: ($pos: ResolvedPos, nodeType: union<NodeType, [NodeType]>) \u2192 ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Iterates over parent nodes starting from the given `$pos`, returning closest node of a given `nodeType`. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const parent = findParentNodeOfTypeClosestToPos(state.doc.resolve(10), schema.nodes.paragraph);\n// ```\nexport const findParentNodeOfTypeClosestToPos = ($pos, nodeType) => {\n  return findParentNodeClosestToPos($pos, node =>\n    equalNodeType(nodeType, node)\n  );\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) \u2192 (selection: Selection) \u2192 boolean\n// Checks if there's a parent node of a given `nodeType`.\n//\n// ```javascript\n// if (hasParentNodeOfType(schema.nodes.table)(selection)) {\n//   // ....\n// }\n// ```\nexport const hasParentNodeOfType = nodeType => selection => {\n  return hasParentNode(node => equalNodeType(nodeType, node))(selection);\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>, domAtPos: (pos: number) \u2192 {node: dom.Node, offset: number}) \u2192 (selection: Selection) \u2192 ?dom.Node\n// Iterates over parent nodes, returning DOM reference of the closest node of a given `nodeType`.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const parent = findParentDomRefOfType(schema.nodes.codeBlock, domAtPos)(selection); // <pre>\n// ```\nexport const findParentDomRefOfType = (nodeType, domAtPos) => selection => {\n  return findParentDomRef(node => equalNodeType(nodeType, node), domAtPos)(\n    selection\n  );\n};\n\n// :: (nodeType: union<NodeType, [NodeType]>) \u2192 (selection: Selection) \u2192 ?{pos: number, start: number, depth: number, node: ProseMirrorNode}\n// Returns a node of a given `nodeType` if it is selected. `start` points to the start position of the node, `pos` points directly before the node.\n//\n// ```javascript\n// const { extension, inlineExtension, bodiedExtension } = schema.nodes;\n// const selectedNode = findSelectedNodeOfType([\n//   extension,\n//   inlineExtension,\n//   bodiedExtension,\n// ])(selection);\n// ```\nexport const findSelectedNodeOfType = nodeType => selection => {\n  if (isNodeSelection(selection)) {\n    const { node, $from } = selection;\n    if (equalNodeType(nodeType, node)) {\n      return { node, pos: $from.pos, depth: $from.depth };\n    }\n  }\n};\n\n// :: (selection: Selection) \u2192 ?number\n// Returns position of the previous node.\n//\n// ```javascript\n// const pos = findPositionOfNodeBefore(tr.selection);\n// ```\nexport const findPositionOfNodeBefore = selection => {\n  const { nodeBefore } = selection.$from;\n  const maybeSelection = Selection.findFrom(selection.$from, -1);\n  if (maybeSelection && nodeBefore) {\n    // leaf node\n    const parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);\n    if (parent) {\n      return parent.pos;\n    }\n    return maybeSelection.$from.pos;\n  }\n};\n\n// :: (position: number, domAtPos: (pos: number) \u2192 {node: dom.Node, offset: number}) \u2192 dom.Node\n// Returns DOM reference of a node at a given `position`. If the node type is of type `TEXT_NODE` it will return the reference of the parent node.\n//\n// ```javascript\n// const domAtPos = view.domAtPos.bind(view);\n// const ref = findDomRefAtPos($from.pos, domAtPos);\n// ```\nexport const findDomRefAtPos = (position, domAtPos) => {\n  const dom = domAtPos(position);\n  const node = dom.node.childNodes[dom.offset];\n\n  if (dom.node.nodeType === Node.TEXT_NODE) {\n    return dom.node.parentNode;\n  }\n\n  if (!node || node.nodeType === Node.TEXT_NODE) {\n    return dom.node;\n  }\n\n  return node;\n};\n", "// :: (node: ProseMirrorNode, descend: ?boolean) \u2192 [{ node: ProseMirrorNode, pos: number }]\n// Flattens descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const children = flatten(node);\n// ```\nexport const flatten = (node, descend = true) => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  }\n  const result = [];\n  node.descendants((child, pos) => {\n    result.push({ node: child, pos });\n    if (!descend) {\n      return false;\n    }\n  });\n  return result;\n};\n\n// :: (node: ProseMirrorNode, predicate: (node: ProseMirrorNode) \u2192 boolean, descend: ?boolean) \u2192 [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findChildren(node, child => child.isText, false);\n// ```\nexport const findChildren = (node, predicate, descend) => {\n  if (!node) {\n    throw new Error('Invalid \"node\" parameter');\n  } else if (!predicate) {\n    throw new Error('Invalid \"predicate\" parameter');\n  }\n  return flatten(node, descend).filter(child => predicate(child.node));\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) \u2192 [{ node: ProseMirrorNode, pos: number }]\n// Returns text nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const textNodes = findTextNodes(node);\n// ```\nexport const findTextNodes = (node, descend) => {\n  return findChildren(node, child => child.isText, descend);\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) \u2192 [{ node: ProseMirrorNode, pos: number }]\n// Returns inline nodes of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const inlineNodes = findInlineNodes(node);\n// ```\nexport const findInlineNodes = (node, descend) => {\n  return findChildren(node, child => child.isInline, descend);\n};\n\n// :: (node: ProseMirrorNode, descend: ?boolean) \u2192 [{ node: ProseMirrorNode, pos: number }]\n// Returns block descendants of a given `node`. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const blockNodes = findBlockNodes(node);\n// ```\nexport const findBlockNodes = (node, descend) => {\n  return findChildren(node, child => child.isBlock, descend);\n};\n\n// :: (node: ProseMirrorNode, predicate: (attrs: ?Object) \u2192 boolean, descend: ?boolean) \u2192 [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes predicate returns truthy for. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const mergedCells = findChildrenByAttr(table, attrs => attrs.colspan === 2);\n// ```\nexport const findChildrenByAttr = (node, predicate, descend) => {\n  return findChildren(node, child => !!predicate(child.attrs), descend);\n};\n\n// :: (node: ProseMirrorNode, nodeType: NodeType, descend: ?boolean) \u2192 [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes of a given nodeType. It doesn't descend into a node when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const cells = findChildrenByType(table, schema.nodes.tableCell);\n// ```\nexport const findChildrenByType = (node, nodeType, descend) => {\n  return findChildren(node, child => child.type === nodeType, descend);\n};\n\n// :: (node: ProseMirrorNode, markType: markType, descend: ?boolean) \u2192 [{ node: ProseMirrorNode, pos: number }]\n// Iterates over descendants of a given `node`, returning child nodes that have a mark of a given markType. It doesn't descend into a `node` when descend argument is `false` (defaults to `true`).\n//\n// ```javascript\n// const nodes = findChildrenByMark(state.doc, schema.marks.strong);\n// ```\nexport const findChildrenByMark = (node, markType, descend) => {\n  return findChildren(node, child => markType.isInSet(child.marks), descend);\n};\n\n// :: (node: ProseMirrorNode, nodeType: NodeType) \u2192 boolean\n// Returns `true` if a given node contains nodes of a given `nodeType`\n//\n// ```javascript\n// if (contains(panel, schema.nodes.listItem)) {\n//   // ...\n// }\n// ```\nexport const contains = (node, nodeType) => {\n  return !!findChildrenByType(node, nodeType).length;\n};\n", "import {\n  CellSelection,\n  TableMap,\n  addColumn,\n  addRow,\n  removeColumn,\n  removeRow\n} from 'prosemirror-tables';\nimport { Selection } from 'prosemirror-state';\nimport { findParentNode, findParentNodeClosestToPos } from './selection';\nimport { setTextSelection, safeInsert } from './transforms';\nimport {\n  cloneTr,\n  tableNodeTypes,\n  findTableClosestToPos,\n  createCell,\n  isRectSelected,\n  moveTableRow,\n  moveTableColumn,\n  checkInvalidMovements\n} from './helpers';\n\n// :: (selection: Selection) \u2192 ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning the closest table node.\n//\n// ```javascript\n// const table = findTable(selection);\n// ```\nexport const findTable = selection =>\n  findParentNode(\n    node => node.type.spec.tableRole && node.type.spec.tableRole === 'table'\n  )(selection);\n\n// :: (selection: Selection) \u2192 boolean\n// Checks if current selection is a `CellSelection`.\n//\n// ```javascript\n// if (isCellSelection(selection)) {\n//   // ...\n// }\n// ```\nexport const isCellSelection = selection => {\n  return selection instanceof CellSelection;\n};\n\n// :: (selection: Selection) \u2192 ?{left: number, right: number, top: number, bottom: number}\n// Get the selection rectangle. Returns `undefined` if selection is not a CellSelection.\n//\n// ```javascript\n// const rect = getSelectionRect(selection);\n// ```\nexport const getSelectionRect = selection => {\n  if (!isCellSelection(selection)) {\n    return;\n  }\n  const start = selection.$anchorCell.start(-1);\n  const map = TableMap.get(selection.$anchorCell.node(-1));\n  return map.rectBetween(\n    selection.$anchorCell.pos - start,\n    selection.$headCell.pos - start\n  );\n};\n\n// :: (columnIndex: number) \u2192 (selection: Selection) \u2192 boolean\n// Checks if entire column at index `columnIndex` is selected.\n//\n// ```javascript\n// const className = isColumnSelected(i)(selection) ? 'selected' : '';\n// ```\nexport const isColumnSelected = columnIndex => selection => {\n  if (isCellSelection(selection)) {\n    const map = TableMap.get(selection.$anchorCell.node(-1));\n    return isRectSelected({\n      left: columnIndex,\n      right: columnIndex + 1,\n      top: 0,\n      bottom: map.height\n    })(selection);\n  }\n\n  return false;\n};\n\n// :: (rowIndex: number) \u2192 (selection: Selection) \u2192 boolean\n// Checks if entire row at index `rowIndex` is selected.\n//\n// ```javascript\n// const className = isRowSelected(i)(selection) ? 'selected' : '';\n// ```\nexport const isRowSelected = rowIndex => selection => {\n  if (isCellSelection(selection)) {\n    const map = TableMap.get(selection.$anchorCell.node(-1));\n    return isRectSelected({\n      left: 0,\n      right: map.width,\n      top: rowIndex,\n      bottom: rowIndex + 1\n    })(selection);\n  }\n\n  return false;\n};\n\n// :: (selection: Selection) \u2192 boolean\n// Checks if entire table is selected\n//\n// ```javascript\n// const className = isTableSelected(selection) ? 'selected' : '';\n// ```\nexport const isTableSelected = selection => {\n  if (isCellSelection(selection)) {\n    const map = TableMap.get(selection.$anchorCell.node(-1));\n    return isRectSelected({\n      left: 0,\n      right: map.width,\n      top: 0,\n      bottom: map.height\n    })(selection);\n  }\n\n  return false;\n};\n\n// :: (columnIndex: union<number, [number]>) \u2192 (selection: Selection) \u2192 ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of cells in a column(s), where `columnIndex` could be a column index or an array of column indexes.\n//\n// ```javascript\n// const cells = getCellsInColumn(i)(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInColumn = columnIndex => selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const indexes = Array.isArray(columnIndex)\n      ? columnIndex\n      : Array.from([columnIndex]);\n    return indexes.reduce((acc, index) => {\n      if (index >= 0 && index <= map.width - 1) {\n        const cells = map.cellsInRect({\n          left: index,\n          right: index + 1,\n          top: 0,\n          bottom: map.height\n        });\n        return acc.concat(\n          cells.map(nodePos => {\n            const node = table.node.nodeAt(nodePos);\n            const pos = nodePos + table.start;\n            return { pos, start: pos + 1, node };\n          })\n        );\n      }\n    }, []);\n  }\n};\n\n// :: (rowIndex: union<number, [number]>) \u2192 (selection: Selection) \u2192 ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of cells in a row(s), where `rowIndex` could be a row index or an array of row indexes.\n//\n// ```javascript\n// const cells = getCellsInRow(i)(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInRow = rowIndex => selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const indexes = Array.isArray(rowIndex) ? rowIndex : Array.from([rowIndex]);\n    return indexes.reduce((acc, index) => {\n      if (index >= 0 && index <= map.height - 1) {\n        const cells = map.cellsInRect({\n          left: 0,\n          right: map.width,\n          top: index,\n          bottom: index + 1\n        });\n        return acc.concat(\n          cells.map(nodePos => {\n            const node = table.node.nodeAt(nodePos);\n            const pos = nodePos + table.start;\n            return { pos, start: pos + 1, node };\n          })\n        );\n      }\n    }, []);\n  }\n};\n\n// :: (selection: Selection) \u2192 ?[{pos: number, start: number, node: ProseMirrorNode}]\n// Returns an array of all cells in a table.\n//\n// ```javascript\n// const cells = getCellsInTable(selection); // [{node, pos}, {node, pos}]\n// ```\nexport const getCellsInTable = selection => {\n  const table = findTable(selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const cells = map.cellsInRect({\n      left: 0,\n      right: map.width,\n      top: 0,\n      bottom: map.height\n    });\n    return cells.map(nodePos => {\n      const node = table.node.nodeAt(nodePos);\n      const pos = nodePos + table.start;\n      return { pos, start: pos + 1, node };\n    });\n  }\n};\n\nconst select = type => (index, expand) => tr => {\n  const table = findTable(tr.selection);\n  const isRowSelection = type === 'row';\n  if (table) {\n    const map = TableMap.get(table.node);\n\n    // Check if the index is valid\n    if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {\n      let left = isRowSelection ? 0 : index;\n      let top = isRowSelection ? index : 0;\n      let right = isRowSelection ? map.width : index + 1;\n      let bottom = isRowSelection ? index + 1 : map.height;\n\n      if (expand) {\n        const cell = findCellClosestToPos(tr.selection.$from);\n        if (!cell) {\n          return tr;\n        }\n\n        const selRect = map.findCell(cell.pos - table.start);\n        if (isRowSelection) {\n          top = Math.min(top, selRect.top);\n          bottom = Math.max(bottom, selRect.bottom);\n        } else {\n          left = Math.min(left, selRect.left);\n          right = Math.max(right, selRect.right);\n        }\n      }\n\n      const cellsInFirstRow = map.cellsInRect({\n        left,\n        top,\n        right: isRowSelection ? right : left + 1,\n        bottom: isRowSelection ? top + 1 : bottom\n      });\n\n      const cellsInLastRow =\n        bottom - top === 1\n          ? cellsInFirstRow\n          : map.cellsInRect({\n              left: isRowSelection ? left : right - 1,\n              top: isRowSelection ? bottom - 1 : top,\n              right,\n              bottom\n            });\n\n      const head = table.start + cellsInFirstRow[0];\n      const anchor = table.start + cellsInLastRow[cellsInLastRow.length - 1];\n      const $head = tr.doc.resolve(head);\n      const $anchor = tr.doc.resolve(anchor);\n\n      return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));\n    }\n  }\n  return tr;\n};\n\n// :: (columnIndex: number, expand: ?boolean) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that creates a `CellSelection` on a column at index `columnIndex`.\n// Use the optional `expand` param to extend from current selection.\n//\n// ```javascript\n// dispatch(\n//   selectColumn(i)(state.tr)\n// );\n// ```\nexport const selectColumn = select('column');\n\n// :: (rowIndex: number, expand: ?boolean) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that creates a `CellSelection` on a column at index `rowIndex`.\n// Use the optional `expand` param to extend from current selection.\n//\n// ```javascript\n// dispatch(\n//   selectRow(i)(state.tr)\n// );\n// ```\nexport const selectRow = select('row');\n\n// :: (selection: Selection) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that creates a `CellSelection` on the entire table.\n//\n// ```javascript\n// dispatch(\n//   selectTable(i)(state.tr)\n// );\n// ```\nexport const selectTable = tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const { map } = TableMap.get(table.node);\n    if (map && map.length) {\n      const head = table.start + map[0];\n      const anchor = table.start + map[map.length - 1];\n      const $head = tr.doc.resolve(head);\n      const $anchor = tr.doc.resolve(anchor);\n\n      return cloneTr(tr.setSelection(new CellSelection($anchor, $head)));\n    }\n  }\n  return tr;\n};\n\n// :: (cell: {pos: number, node: ProseMirrorNode}, schema: Schema) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that clears the content of a given `cell`.\n//\n// ```javascript\n// const $pos = state.doc.resolve(13);\n// dispatch(\n//   emptyCell(findCellClosestToPos($pos), state.schema)(state.tr)\n// );\n// ```\nexport const emptyCell = (cell, schema) => tr => {\n  if (cell) {\n    const { content } = tableNodeTypes(schema).cell.createAndFill();\n    if (!cell.node.content.eq(content)) {\n      tr.replaceWith(cell.pos + 1, cell.pos + cell.node.nodeSize, content);\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (columnIndex: number) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that adds a new column at index `columnIndex`.\n//\n// ```javascript\n// dispatch(\n//   addColumnAt(i)(state.tr)\n// );\n// ```\nexport const addColumnAt = columnIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (columnIndex >= 0 && columnIndex <= map.width) {\n      return cloneTr(\n        addColumn(\n          tr,\n          {\n            map,\n            tableStart: table.start,\n            table: table.node\n          },\n          columnIndex\n        )\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (originRowIndex: number, targetRowIndex: targetColumnIndex, options?: MovementOptions) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that moves the origin row to the target index;\n//\n// by default \"tryToFit\" is false, that means if you try to move a row to a place\n// where we will need to split a row with merged cells it'll throw an exception, for example:\n//\n// ```\n//      ____________________________\n//     |      |      |             |\n//  0  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  1  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  2  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n// ```\n//\n// if you try to move the row 0 to the row index 1 with tryToFit false,\n// it'll throw an exception since you can't split the row 1;\n// but if \"tryToFit\" is true, it'll move the row using the current direction.\n//\n// We defined current direction using the target and origin values\n// if the origin is greater than the target, that means the course is `bottom-to-top`,\n// so the `tryToFit` logic will use this direction to determine\n// if we should move the column to the right or the left.\n//\n// for example, if you call the function using `moveRow(0, 1, { tryToFit: true })`\n// the result will be:\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  2  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n// since we could put the row zero on index one,\n// we pushed to the best place to fit the row index 0,\n// in this case, row index 2.\n//\n//\n// -------- HOW TO OVERRIDE DIRECTION --------\n//\n// If you set \"tryToFit\" to \"true\", it will try to figure out the best direction\n// place to fit using the origin and target index, for example:\n//\n//\n// ```\n//      ____________________________\n//     |      |      |             |\n//  0  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  1  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  2  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  3  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  4  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n// ```\n//\n//\n// If you try to move the row 0 to row index 4 with \"tryToFit\" enabled, by default,\n// the code will put it on after the merged rows,\n// but you can override it using the \"direction\" option.\n//\n// -1: Always put the origin before the target\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  2  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n//     |      |             |      |\n//  3  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  4  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n// ```\n//\n//  0: Automatically decide the best place to fit\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  2  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  3  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  4  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n//  1: Always put the origin after the target\n// ```\n//      ____________________________\n//     |      |             |      |\n//  0  |  A2  |     B2      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D1  |\n//  1  |  A3  |  B3  |  C2  |      |\n//     |______|______|______|______|\n//     |      |             |      |\n//  2  |  A4  |     B4      |      |\n//     |______|______ ______|      |\n//     |      |      |      |  D2  |\n//  3  |  A5  |  B5  |  C3  |      |\n//     |______|______|______|______|\n//     |      |      |             |\n//  4  |  A1  |  B1  |     C1      |\n//     |______|______|______ ______|\n// ```\n//\n// ```javascript\n// dispatch(\n//   moveRow(x, y, options)(state.tr)\n// );\n// ```\nexport const moveRow = (originRowIndex, targetRowIndex, opts) => tr => {\n  const defaultOptions = { tryToFit: false, direction: 0 };\n  const options = Object.assign(defaultOptions, opts);\n  const table = findTable(tr.selection);\n  if (!table) {\n    return tr;\n  }\n\n  const { indexes: indexesOriginRow } = getSelectionRangeInRow(originRowIndex)(\n    tr\n  );\n  const { indexes: indexesTargetRow } = getSelectionRangeInRow(targetRowIndex)(\n    tr\n  );\n\n  if (indexesOriginRow.indexOf(targetRowIndex) > -1) {\n    return tr;\n  }\n\n  if (!options.tryToFit && indexesTargetRow.length > 1) {\n    checkInvalidMovements(\n      originRowIndex,\n      targetRowIndex,\n      indexesTargetRow,\n      'row'\n    );\n  }\n\n  const newTable = moveTableRow(\n    table,\n    indexesOriginRow,\n    indexesTargetRow,\n    options.direction\n  );\n\n  return cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable\n  );\n};\n\n// :: (originColumnIndex: number, targetColumnIndex: targetColumnIndex, options?: MovementOptions) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that moves the origin column to the target index;\n//\n// by default \"tryToFit\" is false, that means if you try to move a column to a place\n// where we will need to split a column with merged cells it'll throw an exception, for example:\n//\n// ```\n//    0      1         2\n//  ____________________________\n// |      |      |             |\n// |  A1  |  B1  |     C1      |\n// |______|______|______ ______|\n// |      |             |      |\n// |  A2  |     B2      |      |\n// |______|______ ______|      |\n// |      |      |      |  D1  |\n// |  A3  |  B3  |  C2  |      |\n// |______|______|______|______|\n// ```\n//\n//\n// if you try to move the column 0 to the column index 1 with tryToFit false,\n// it'll throw an exception since you can't split the column 1;\n// but if \"tryToFit\" is true, it'll move the column using the current direction.\n//\n// We defined current direction using the target and origin values\n// if the origin is greater than the target, that means the course is `right-to-left`,\n// so the `tryToFit` logic will use this direction to determine\n// if we should move the column to the right or the left.\n//\n// for example, if you call the function using `moveColumn(0, 1, { tryToFit: true })`\n// the result will be:\n//\n// ```\n//    0       1             2\n// _____________________ _______\n// |      |             |      |\n// |  B1  |     C1      |  A1  |\n// |______|______ ______|______|\n// |             |      |      |\n// |     B2      |      |  A2  |\n// |______ ______|      |______|\n// |      |      |  D1  |      |\n// |  B3  |  C2  |      |  A3  |\n// |______|______|______|______|\n// ```\n//\n// since we could put the column zero on index one,\n// we pushed to the best place to fit the column 0, in this case, column index 2.\n//\n// -------- HOW TO OVERRIDE DIRECTION --------\n//\n// If you set \"tryToFit\" to \"true\", it will try to figure out the best direction\n// place to fit using the origin and target index, for example:\n//\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |      |             |      |             |\n//  |  A1  |  B1  |     C1      |  E1  |     F1      |\n//  |______|______|______ ______|______|______ ______|\n//  |      |             |      |             |      |\n//  |  A2  |     B2      |      |     E2      |      |\n//  |______|______ ______|      |______ ______|      |\n//  |      |      |      |  D1  |      |      |  G2  |\n//  |  A3  |  B3  |  C3  |      |  E3  |  F3  |      |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//\n// If you try to move the column 0 to column index 5 with \"tryToFit\" enabled, by default,\n// the code will put it on after the merged columns,\n// but you can override it using the \"direction\" option.\n//\n// -1: Always put the origin before the target\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |      |             |\n//  |  B1  |     C1      |  A1  |  E1  |     F1      |\n//  |______|______ ______|______|______|______ ______|\n//  |             |      |      |             |      |\n//  |     B2      |      |  A2  |     E2      |      |\n//  |______ ______|      |______|______ ______|      |\n//  |      |      |  D1  |      |      |      |  G2  |\n//  |  B3  |  C3  |      |  A3  |  E3  |  F3  |      |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//  0: Automatically decide the best place to fit\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |             |      |\n//  |  B1  |     C1      |  E1  |     F1      |  A1  |\n//  |______|______ ______|______|______ ______|______|\n//  |             |      |             |      |      |\n//  |     B2      |      |     E2      |      |  A2  |\n//  |______ ______|      |______ ______|      |______|\n//  |      |      |  D1  |      |      |  G2  |      |\n//  |  B3  |  C3  |      |  E3  |  F3  |      |  A3  |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n//  1: Always put the origin after the target\n//\n// ```\n//     0      1       2     3      4      5       6\n//   _________________________________________________\n//  |      |             |      |             |      |\n//  |  B1  |     C1      |  E1  |     F1      |  A1  |\n//  |______|______ ______|______|______ ______|______|\n//  |             |      |             |      |      |\n//  |     B2      |      |     E2      |      |  A2  |\n//  |______ ______|      |______ ______|      |______|\n//  |      |      |  D1  |      |      |  G2  |      |\n//  |  B3  |  C3  |      |  E3  |  F3  |      |  A3  |\n//  |______|______|______|______|______|______|______|\n// ```\n//\n// ```javascript\n// dispatch(\n//   moveColumn(x, y, options)(state.tr)\n// );\n// ```\nexport const moveColumn = (\n  originColumnIndex,\n  targetColumnIndex,\n  opts\n) => tr => {\n  const defaultOptions = { tryToFit: false, direction: 0 };\n  const options = Object.assign(defaultOptions, opts);\n  const table = findTable(tr.selection);\n  if (!table) {\n    return tr;\n  }\n\n  const { indexes: indexesOriginColumn } = getSelectionRangeInColumn(\n    originColumnIndex\n  )(tr);\n  const { indexes: indexesTargetColumn } = getSelectionRangeInColumn(\n    targetColumnIndex\n  )(tr);\n\n  if (indexesOriginColumn.indexOf(targetColumnIndex) > -1) {\n    return tr;\n  }\n\n  if (!options.tryToFit && indexesTargetColumn.length > 1) {\n    checkInvalidMovements(\n      originColumnIndex,\n      targetColumnIndex,\n      indexesTargetColumn,\n      'column'\n    );\n  }\n\n  const newTable = moveTableColumn(\n    table,\n    indexesOriginColumn,\n    indexesTargetColumn,\n    options.direction\n  );\n\n  return cloneTr(tr).replaceWith(\n    table.pos,\n    table.pos + table.node.nodeSize,\n    newTable\n  );\n};\n\n// :: (rowIndex: number, clonePreviousRow?: boolean) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that adds a new row at index `rowIndex`. Optionally clone the previous row.\n//\n// ```javascript\n// dispatch(\n//   addRowAt(i)(state.tr)\n// );\n// ```\n//\n// ```javascript\n// dispatch(\n//   addRowAt(i, true)(state.tr)\n// );\n// ```\nexport const addRowAt = (rowIndex, clonePreviousRow) => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    const cloneRowIndex = rowIndex - 1;\n\n    if (clonePreviousRow && cloneRowIndex >= 0) {\n      return cloneTr(cloneRowAt(cloneRowIndex)(tr));\n    }\n\n    if (rowIndex >= 0 && rowIndex <= map.height) {\n      return cloneTr(\n        addRow(\n          tr,\n          {\n            map,\n            tableStart: table.start,\n            table: table.node\n          },\n          rowIndex\n        )\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (cloneRowIndex: number) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that adds a new row after `cloneRowIndex`, cloning the row attributes at `cloneRowIndex`.\n//\n// ```javascript\n// dispatch(\n//   cloneRowAt(i)(state.tr)\n// );\n// ```\nexport const cloneRowAt = rowIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n\n    if (rowIndex >= 0 && rowIndex <= map.height) {\n      const tableNode = table.node;\n      const tableNodes = tableNodeTypes(tableNode.type.schema);\n\n      let rowPos = table.start;\n      for (let i = 0; i < rowIndex + 1; i++) {\n        rowPos += tableNode.child(i).nodeSize;\n      }\n\n      const cloneRow = tableNode.child(rowIndex);\n      // Re-create the same nodes with same attrs, dropping the node content.\n      let cells = [];\n      let rowWidth = 0;\n      cloneRow.forEach(cell => {\n        // If we're copying a row with rowspan somewhere, we dont want to copy that cell\n        // We'll increment its span below.\n        if (cell.attrs.rowspan === 1) {\n          rowWidth += cell.attrs.colspan;\n          cells.push(\n            tableNodes[cell.type.spec.tableRole].createAndFill(\n              cell.attrs,\n              cell.marks\n            )\n          );\n        }\n      });\n\n      // If a higher row spans past our clone row, bump the higher row to cover this new row too.\n      if (rowWidth < map.width) {\n        let rowSpanCells = [];\n        for (let i = rowIndex; i >= 0; i--) {\n          let foundCells = filterCellsInRow(i, (cell, tr) => {\n            const rowspan = cell.node.attrs.rowspan;\n            const spanRange = i + rowspan;\n            return rowspan > 1 && spanRange > rowIndex;\n          })(tr);\n          rowSpanCells.push(...foundCells);\n        }\n\n        if (rowSpanCells.length) {\n          rowSpanCells.forEach(cell => {\n            tr = setCellAttrs(cell, {\n              rowspan: cell.node.attrs.rowspan + 1\n            })(tr);\n          });\n        }\n      }\n\n      return safeInsert(tableNodes.row.create(cloneRow.attrs, cells), rowPos)(\n        tr\n      );\n    }\n  }\n  return tr;\n};\n\n// :: (columnIndex: number) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes a column at index `columnIndex`. If there is only one column left, it will remove the entire table.\n//\n// ```javascript\n// dispatch(\n//   removeColumnAt(i)(state.tr)\n// );\n// ```\nexport const removeColumnAt = columnIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (columnIndex === 0 && map.width === 1) {\n      return removeTable(tr);\n    } else if (columnIndex >= 0 && columnIndex <= map.width) {\n      removeColumn(\n        tr,\n        {\n          map,\n          tableStart: table.start,\n          table: table.node\n        },\n        columnIndex\n      );\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (rowIndex: number) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes a row at index `rowIndex`. If there is only one row left, it will remove the entire table.\n//\n// ```javascript\n// dispatch(\n//   removeRowAt(i)(state.tr)\n// );\n// ```\nexport const removeRowAt = rowIndex => tr => {\n  const table = findTable(tr.selection);\n  if (table) {\n    const map = TableMap.get(table.node);\n    if (rowIndex === 0 && map.height === 1) {\n      return removeTable(tr);\n    } else if (rowIndex >= 0 && rowIndex <= map.height) {\n      removeRow(\n        tr,\n        {\n          map,\n          tableStart: table.start,\n          table: table.node\n        },\n        rowIndex\n      );\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes a table node if the cursor is inside of it.\n//\n// ```javascript\n// dispatch(\n//   removeTable(state.tr)\n// );\n// ```\nexport const removeTable = tr => {\n  const { $from } = tr.selection;\n  for (let depth = $from.depth; depth > 0; depth--) {\n    let node = $from.node(depth);\n    if (node.type.spec.tableRole === 'table') {\n      return cloneTr(tr.delete($from.before(depth), $from.after(depth)));\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes selected columns.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedColumns(state.tr)\n// );\n// ```\nexport const removeSelectedColumns = tr => {\n  const { selection } = tr;\n  if (isTableSelected(selection)) {\n    return removeTable(tr);\n  }\n  if (isCellSelection(selection)) {\n    const table = findTable(selection);\n    if (table) {\n      const map = TableMap.get(table.node);\n      const rect = map.rectBetween(\n        selection.$anchorCell.pos - table.start,\n        selection.$headCell.pos - table.start\n      );\n\n      if (rect.left == 0 && rect.right == map.width) {\n        return false;\n      }\n\n      const pmTableRect = Object.assign({}, rect, {\n        map,\n        table: table.node,\n        tableStart: table.start\n      });\n\n      for (let i = pmTableRect.right - 1; ; i--) {\n        removeColumn(tr, pmTableRect, i);\n        if (i === pmTableRect.left) {\n          break;\n        }\n        pmTableRect.table = pmTableRect.tableStart\n          ? tr.doc.nodeAt(pmTableRect.tableStart - 1)\n          : tr.doc;\n        pmTableRect.map = TableMap.get(pmTableRect.table);\n      }\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes selected rows.\n//\n// ```javascript\n// dispatch(\n//   removeSelectedRows(state.tr)\n// );\n// ```\nexport const removeSelectedRows = tr => {\n  const { selection } = tr;\n  if (isTableSelected(selection)) {\n    return removeTable(tr);\n  }\n  if (isCellSelection(selection)) {\n    const table = findTable(selection);\n    if (table) {\n      const map = TableMap.get(table.node);\n      const rect = map.rectBetween(\n        selection.$anchorCell.pos - table.start,\n        selection.$headCell.pos - table.start\n      );\n\n      if (rect.top == 0 && rect.bottom == map.height) {\n        return false;\n      }\n\n      const pmTableRect = Object.assign({}, rect, {\n        map,\n        table: table.node,\n        tableStart: table.start\n      });\n\n      for (let i = pmTableRect.bottom - 1; ; i--) {\n        removeRow(tr, pmTableRect, i);\n        if (i === pmTableRect.top) {\n          break;\n        }\n        pmTableRect.table = pmTableRect.tableStart\n          ? tr.doc.nodeAt(pmTableRect.tableStart - 1)\n          : tr.doc;\n        pmTableRect.map = TableMap.get(pmTableRect.table);\n      }\n\n      return cloneTr(tr);\n    }\n  }\n  return tr;\n};\n\n// :: ($pos: ResolvedPos) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes a column closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   removeColumnClosestToPos(state.doc.resolve(3))(state.tr)\n// );\n// ```\nexport const removeColumnClosestToPos = $pos => tr => {\n  const rect = findCellRectClosestToPos($pos);\n  if (rect) {\n    return removeColumnAt(rect.left)(setTextSelection($pos.pos)(tr));\n  }\n  return tr;\n};\n\n// :: ($pos: ResolvedPos) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that removes a row closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   removeRowClosestToPos(state.doc.resolve(3))(state.tr)\n// );\n// ```\nexport const removeRowClosestToPos = $pos => tr => {\n  const rect = findCellRectClosestToPos($pos);\n  if (rect) {\n    return removeRowAt(rect.top)(setTextSelection($pos.pos)(tr));\n  }\n  return tr;\n};\n\n// :: (columnIndex: number, cellTransform: (cell: {pos: number, start: number, node: ProseMirrorNode}, tr: Transaction) \u2192 Transaction, setCursorToLastCell: ?boolean) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that maps a given `cellTransform` function to each cell in a column at a given `columnIndex`.\n// It will set the selection into the last cell of the column if `setCursorToLastCell` param is set to `true`.\n//\n// ```javascript\n// dispatch(\n//   forEachCellInColumn(0, (cell, tr) => emptyCell(cell, state.schema)(tr))(state.tr)\n// );\n// ```\nexport const forEachCellInColumn = (\n  columnIndex,\n  cellTransform,\n  setCursorToLastCell\n) => tr => {\n  const cells = getCellsInColumn(columnIndex)(tr.selection);\n  if (cells) {\n    for (let i = cells.length - 1; i >= 0; i--) {\n      tr = cellTransform(cells[i], tr);\n    }\n    if (setCursorToLastCell) {\n      const $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));\n      tr.setSelection(Selection.near($pos));\n    }\n    return cloneTr(tr);\n  }\n  return tr;\n};\n\n// :: (rowIndex: number, cellTransform: (cell: {pos: number, start: number, node: ProseMirrorNode}, tr: Transaction) \u2192 Transaction, setCursorToLastCell: ?boolean) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that maps a given `cellTransform` function to each cell in a row at a given `rowIndex`.\n// It will set the selection into the last cell of the row if `setCursorToLastCell` param is set to `true`.\n//\n// ```javascript\n// dispatch(\n//   forEachCellInRow(0, (cell, tr) => setCellAttrs(cell, { background: 'red' })(tr))(state.tr)\n// );\n// ```\nexport const forEachCellInRow = (\n  rowIndex,\n  cellTransform,\n  setCursorToLastCell\n) => tr => {\n  const cells = getCellsInRow(rowIndex)(tr.selection);\n  if (cells) {\n    for (let i = cells.length - 1; i >= 0; i--) {\n      tr = cellTransform(cells[i], tr);\n    }\n    if (setCursorToLastCell) {\n      const $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));\n      tr.setSelection(Selection.near($pos));\n    }\n  }\n  return tr;\n};\n\n// :: (cell: {pos: number, start: number, node: ProseMirrorNode}, attrs: Object) \u2192 (tr: Transaction) \u2192 Transaction\n// Returns a new transaction that sets given `attrs` to a given `cell`.\n//\n// ```javascript\n// dispatch(\n//   setCellAttrs(findCellClosestToPos($pos), { background: 'blue' })(tr);\n// );\n// ```\nexport const setCellAttrs = (cell, attrs) => tr => {\n  if (cell) {\n    tr.setNodeMarkup(cell.pos, null, Object.assign({}, cell.node.attrs, attrs));\n    return cloneTr(tr);\n  }\n  return tr;\n};\n\n// :: (schema: Schema, rowsCount: ?number, colsCount: ?number, withHeaderRow: ?boolean, cellContent: ?Node) \u2192 Node\n// Returns a table node of a given size.\n// `withHeaderRow` defines whether the first row of the table will be a header row.\n// `cellContent` defines the content of each cell.\n//\n// ```javascript\n// const table = createTable(state.schema); // 3x3 table node\n// dispatch(\n//   tr.replaceSelectionWith(table).scrollIntoView()\n// );\n// ```\nexport const createTable = (\n  schema,\n  rowsCount = 3,\n  colsCount = 3,\n  withHeaderRow = true,\n  cellContent = null\n) => {\n  const {\n    cell: tableCell,\n    header_cell: tableHeader,\n    row: tableRow,\n    table\n  } = tableNodeTypes(schema);\n\n  const cells = [];\n  const headerCells = [];\n  for (let i = 0; i < colsCount; i++) {\n    cells.push(createCell(tableCell, cellContent));\n\n    if (withHeaderRow) {\n      headerCells.push(createCell(tableHeader, cellContent));\n    }\n  }\n\n  const rows = [];\n  for (let i = 0; i < rowsCount; i++) {\n    rows.push(\n      tableRow.createChecked(\n        null,\n        withHeaderRow && i === 0 ? headerCells : cells\n      )\n    );\n  }\n\n  return table.createChecked(null, rows);\n};\n\n// :: ($pos: ResolvedPos) \u2192 ?{pos: number, start: number, node: ProseMirrorNode}\n// Iterates over parent nodes, returning a table cell or a table header node closest to a given `$pos`.\n//\n// ```javascript\n// const cell = findCellClosestToPos(state.selection.$from);\n// ```\nexport const findCellClosestToPos = $pos => {\n  const predicate = node =>\n    node.type.spec.tableRole && /cell/i.test(node.type.spec.tableRole);\n  return findParentNodeClosestToPos($pos, predicate);\n};\n\n// :: ($pos: ResolvedPos) \u2192 ?{left: number, top: number, right: number, bottom: number}\n// Returns the rectangle spanning a cell closest to a given `$pos`.\n//\n// ```javascript\n// dispatch(\n//   findCellRectClosestToPos(state.selection.$from)\n// );\n// ```\nexport const findCellRectClosestToPos = $pos => {\n  const cell = findCellClosestToPos($pos);\n  if (cell) {\n    const table = findTableClosestToPos($pos);\n    const map = TableMap.get(table.node);\n    const cellPos = cell.pos - table.start;\n    return map.rectBetween(cellPos, cellPos);\n  }\n};\n\nconst filterCellsInRow = (rowIndex, predicate) => tr => {\n  let foundCells = [];\n  const cells = getCellsInRow(rowIndex)(tr.selection);\n  if (cells) {\n    for (let j = cells.length - 1; j >= 0; j--) {\n      if (predicate(cells[j], tr)) {\n        foundCells.push(cells[j]);\n      }\n    }\n  }\n\n  return foundCells;\n};\n\n// :: (columnIndex: number) \u2192 (tr: Transaction) \u2192 {$anchor: ResolvedPos, $head: ResolvedPos, indexes: [number]}\n// Returns a range of rectangular selection spanning all merged cells around a column at index `columnIndex`.\n//\n// ```javascript\n// const range = getSelectionRangeInColumn(3)(state.tr);\n// ```\nexport const getSelectionRangeInColumn = columnIndex => tr => {\n  let startIndex = columnIndex;\n  let endIndex = columnIndex;\n\n  // looking for selection start column (startIndex)\n  for (let i = columnIndex; i >= 0; i--) {\n    const cells = getCellsInColumn(i)(tr.selection);\n    if (cells) {\n      cells.forEach(cell => {\n        let maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (maybeEndIndex >= startIndex) {\n          startIndex = i;\n        }\n        if (maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n  // looking for selection end column (endIndex)\n  for (let i = columnIndex; i <= endIndex; i++) {\n    const cells = getCellsInColumn(i)(tr.selection);\n    if (cells) {\n      cells.forEach(cell => {\n        let maybeEndIndex = cell.node.attrs.colspan + i - 1;\n        if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) {\n          endIndex = maybeEndIndex;\n        }\n      });\n    }\n  }\n\n  // filter out columns without cells (where all rows have colspan > 1 in the same column)\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInColumn(i)(tr.selection);\n    if (maybeCells && maybeCells.length) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n\n  const firstSelectedColumnCells = getCellsInColumn(startIndex)(tr.selection);\n  const firstRowCells = getCellsInRow(0)(tr.selection);\n  const $anchor = tr.doc.resolve(\n    firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos\n  );\n\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const columnCells = getCellsInColumn(i)(tr.selection);\n    if (columnCells && columnCells.length) {\n      for (let j = firstRowCells.length - 1; j >= 0; j--) {\n        if (firstRowCells[j].pos === columnCells[0].pos) {\n          headCell = columnCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n};\n\n// :: (rowIndex: number) \u2192 (tr: Transaction) \u2192 {$anchor: ResolvedPos, $head: ResolvedPos, indexes: [number]}\n// Returns a range of rectangular selection spanning all merged cells around a row at index `rowIndex`.\n//\n// ```javascript\n// const range = getSelectionRangeInRow(3)(state.tr);\n// ```\nexport const getSelectionRangeInRow = rowIndex => tr => {\n  let startIndex = rowIndex;\n  let endIndex = rowIndex;\n  // looking for selection start row (startIndex)\n  for (let i = rowIndex; i >= 0; i--) {\n    const cells = getCellsInRow(i)(tr.selection);\n    cells.forEach(cell => {\n      let maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n      if (maybeEndIndex >= startIndex) {\n        startIndex = i;\n      }\n      if (maybeEndIndex > endIndex) {\n        endIndex = maybeEndIndex;\n      }\n    });\n  }\n  // looking for selection end row (endIndex)\n  for (let i = rowIndex; i <= endIndex; i++) {\n    const cells = getCellsInRow(i)(tr.selection);\n    cells.forEach(cell => {\n      let maybeEndIndex = cell.node.attrs.rowspan + i - 1;\n      if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) {\n        endIndex = maybeEndIndex;\n      }\n    });\n  }\n\n  // filter out rows without cells (where all columns have rowspan > 1 in the same row)\n  const indexes = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    const maybeCells = getCellsInRow(i)(tr.selection);\n    if (maybeCells && maybeCells.length) {\n      indexes.push(i);\n    }\n  }\n  startIndex = indexes[0];\n  endIndex = indexes[indexes.length - 1];\n\n  const firstSelectedRowCells = getCellsInRow(startIndex)(tr.selection);\n  const firstColumnCells = getCellsInColumn(0)(tr.selection);\n  const $anchor = tr.doc.resolve(\n    firstSelectedRowCells[firstSelectedRowCells.length - 1].pos\n  );\n\n  let headCell;\n  for (let i = endIndex; i >= startIndex; i--) {\n    const rowCells = getCellsInRow(i)(tr.selection);\n    if (rowCells && rowCells.length) {\n      for (let j = firstColumnCells.length - 1; j >= 0; j--) {\n        if (firstColumnCells[j].pos === rowCells[0].pos) {\n          headCell = rowCells[0];\n          break;\n        }\n      }\n      if (headCell) {\n        break;\n      }\n    }\n  }\n\n  const $head = tr.doc.resolve(headCell.pos);\n  return { $anchor, $head, indexes };\n};\n", "export default require(\"./node_modules/prosemirror-utils/dist/index.js\");"],
  "mappings": "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",
  "names": ["require_dist", "_get", "_wrapNativeSuper", "Class", "_construct", "Parent", "args", "_setPrototypeOf", "o", "p", "_getPrototypeOf", "obj", "Fragment", "copy", "found", "Mark", "ReplaceError", "Slice", "ResolvedPos", "marks", "doc", "NodeRange", "Node", "TextNode", "ContentMatch", "TokenStream", "nfa", "edge", "expr", "node", "i", "NodeType", "Attribute", "MarkType", "Schema", "DOMParser", "_loop2", "name", "_loop3", "_name", "NodeContext", "ParseContext", "match", "_loop4", "scan", "DOMSerializer", "require_dist", "obj", "_wrapNativeSuper", "Class", "_construct", "Parent", "args", "_setPrototypeOf", "o", "p", "_getPrototypeOf", "MapResult", "StepMap", "Mapping", "Step", "StepResult", "AddMarkStep", "parent", "RemoveMarkStep", "AddNodeMarkStep", "RemoveNodeMarkStep", "ReplaceStep", "ReplaceAroundStep", "Fitter", "fit", "close", "AttrStep", "Transform", "require_dist", "obj", "_get", "_setPrototypeOf", "o", "p", "_getPrototypeOf", "Selection", "SelectionRange", "TextSelection", "TextBookmark", "NodeSelection", "NodeBookmark", "AllSelection", "Transaction", "FieldDesc", "Configuration", "EditorState", "Plugin", "PluginKey", "require_dist", "require_dist", "obj", "_get", "_setPrototypeOf", "o", "p", "_getPrototypeOf", "domIndex", "parentNode", "textRange", "isEquivalentPosition", "selectionCollapsed", "doc", "ViewDesc", "WidgetViewDesc", "CompositionViewDesc", "MarkViewDesc", "NodeViewDesc", "TextViewDesc", "TrailingHackViewDesc", "CustomNodeViewDesc", "OuterDecoLevel", "prop", "ViewTreeUpdater", "empty", "ruleFromNode", "dom", "_loop", "d", "InputState", "_loop2", "event", "handlers", "_loop3", "i", "MouseDown", "Dragging", "WidgetType", "InlineType", "NodeType", "Decoration", "DecorationSet", "DecorationGroup", "locals", "_loop4", "oldOffset", "SelectionState", "DOMObserver", "update", "EditorView", "_loop5", "search", "key", "PluginKey", "Selection", "SelectionRange", "TextSelection", "Fragment", "Slice", "Decoration", "DecorationSet", "NodeSelection", "Transform", "start", "keydownHandler", "handleMouseDown", "$anchor", "Plugin", "event", "pluginState", "tableEditingKey", "removeParentNodeOfType", "parent", "findParentNodeOfType", "nodeType", "tr", "selection", "removeNodeAtPos", "pos", "replaceParentNodeOfType", "content", "Array", "isArray", "i", "count", "length", "newTr", "replaceNodeAtPos", "removeSelectedNode", "isNodeSelection", "from", "$from", "to", "$to", "cloneTr", "delete", "replaceSelectedNode", "Fragment", "canReplace", "index", "indexAfter", "canReplaceWith", "type", "replaceWith", "setSelection", "NodeSelection", "doc", "resolve", "setTextSelection", "position", "dir", "nextSelection", "Selection", "findFrom", "isSelectableNode", "node", "spec", "selectable", "shouldSelectNode", "isLeaf", "safeInsert", "tryToReplace", "hasPosition", "$insertPos", "oldTr", "isEmptyParagraph", "before", "depth", "canInsert", "insert", "$anchor", "after", "$pos", "setParentNodeMarkup", "attrs", "marks", "setNodeMarkup", "Object", "assign", "selectParentNodeOfType", "create", "removeNodeBefore", "findPositionOfNodeBefore", "equalNodeType", "indexOf", "setTime", "Date", "now", "nodeAt", "nodeSize", "start", "Math", "max", "validContent", "tableNodeTypes", "schema", "cached", "roles", "keys", "nodes", "forEach", "tableRole", "PMNode", "name", "findTableClosestToPos", "predicate", "test", "findParentNodeClosestToPos", "createCell", "cellType", "cellContent", "createChecked", "createAndFill", "isRectSelected", "map", "TableMap", "get", "$anchorCell", "cells", "cellsInRect", "rect", "selectedCells", "rectBetween", "$headCell", "transpose", "array", "_", "column", "convertTableNodeToArrayOfRows", "tableNode", "rows", "rowIndex", "height", "rowCells", "seen", "colIndex", "width", "cellPos", "cell", "findCell", "top", "push", "convertArrayOfRowsToTableNode", "arrayOfNodes", "rowsPM", "row", "child", "oldCell", "newCell", "newTable", "moveTableColumn", "table", "indexesOrigin", "indexesTarget", "direction", "moveRowInArrayOfRows", "moveTableRow", "directionOverride", "rowsExtracted", "splice", "positionOffset", "target", "apply", "concat", "checkInvalidMovements", "originIndex", "targetIndex", "targets", "errorMessage", "slice", "Error", "findParentNode", "findParentDomRef", "domAtPos", "findDomRefAtPos", "hasParentNode", "findParentNodeOfTypeClosestToPos", "hasParentNodeOfType", "findParentDomRefOfType", "findSelectedNodeOfType", "nodeBefore", "maybeSelection", "dom", "childNodes", "offset", "Node", "TEXT_NODE", "parentNode", "flatten", "descend", "result", "descendants", "findChildren", "filter", "findTextNodes", "isText", "findInlineNodes", "isInline", "findBlockNodes", "isBlock", "findChildrenByAttr", "findChildrenByType", "findChildrenByMark", "markType", "isInSet", "contains", "findTable", "isCellSelection", "CellSelection", "getSelectionRect", "isColumnSelected", "columnIndex", "isRowSelected", "isTableSelected", "getCellsInColumn", "indexes", "reduce", "acc", "nodePos", "getCellsInRow", "getCellsInTable", "select", "expand", "isRowSelection", "left", "right", "bottom", "findCellClosestToPos", "selRect", "min", "cellsInFirstRow", "cellsInLastRow", "head", "anchor", "$head", "selectColumn", "selectRow", "selectTable", "emptyCell", "eq", "addColumnAt", "addColumn", "moveRow", "originRowIndex", "targetRowIndex", "opts", "defaultOptions", "tryToFit", "options", "getSelectionRangeInRow", "indexesOriginRow", "indexesTargetRow", "moveColumn", "originColumnIndex", "targetColumnIndex", "getSelectionRangeInColumn", "indexesOriginColumn", "indexesTargetColumn", "addRowAt", "clonePreviousRow", "cloneRowIndex", "cloneRowAt", "addRow", "tableNodes", "rowPos", "cloneRow", "rowWidth", "rowspan", "colspan", "rowSpanCells", "foundCells", "filterCellsInRow", "spanRange", "setCellAttrs", "removeColumnAt", "removeTable", "removeRowAt", "removeSelectedColumns", "pmTableRect", "tableStart", "removeSelectedRows", "removeColumnClosestToPos", "findCellRectClosestToPos", "removeRowClosestToPos", "forEachCellInColumn", "cellTransform", "setCursorToLastCell", "mapping", "near", "forEachCellInRow", "createTable", "rowsCount", "colsCount", "withHeaderRow", "tableCell", "tableHeader", "header_cell", "tableRow", "headerCells", "j", "startIndex", "endIndex", "maybeEndIndex", "maybeCells", "firstSelectedColumnCells", "firstRowCells", "headCell", "columnCells", "firstSelectedRowCells", "firstColumnCells"]
}
