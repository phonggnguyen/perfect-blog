import {
  __commonJS
} from "./chunk-Z53QHQNZ.js";

// node_modules/orderedmap/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/orderedmap/dist/index.cjs"(exports, module) {
    "use strict";
    function OrderedMap(content) {
      this.content = content;
    }
    OrderedMap.prototype = {
      constructor: OrderedMap,
      find: function(key) {
        for (var i = 0; i < this.content.length; i += 2)
          if (this.content[i] === key)
            return i;
        return -1;
      },
      get: function(key) {
        var found = this.find(key);
        return found == -1 ? void 0 : this.content[found + 1];
      },
      update: function(key, value, newKey) {
        var self = newKey && newKey != key ? this.remove(newKey) : this;
        var found = self.find(key), content = self.content.slice();
        if (found == -1) {
          content.push(newKey || key, value);
        } else {
          content[found + 1] = value;
          if (newKey)
            content[found] = newKey;
        }
        return new OrderedMap(content);
      },
      remove: function(key) {
        var found = this.find(key);
        if (found == -1)
          return this;
        var content = this.content.slice();
        content.splice(found, 2);
        return new OrderedMap(content);
      },
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },
      addToEnd: function(key, value) {
        var content = this.remove(key).content.slice();
        content.push(key, value);
        return new OrderedMap(content);
      },
      addBefore: function(place, key, value) {
        var without = this.remove(key), content = without.content.slice();
        var found = without.find(place);
        content.splice(found == -1 ? content.length : found, 0, key, value);
        return new OrderedMap(content);
      },
      forEach: function(f) {
        for (var i = 0; i < this.content.length; i += 2)
          f(this.content[i], this.content[i + 1]);
      },
      prepend: function(map) {
        map = OrderedMap.from(map);
        if (!map.size)
          return this;
        return new OrderedMap(map.content.concat(this.subtract(map).content));
      },
      append: function(map) {
        map = OrderedMap.from(map);
        if (!map.size)
          return this;
        return new OrderedMap(this.subtract(map).content.concat(map.content));
      },
      subtract: function(map) {
        var result = this;
        map = OrderedMap.from(map);
        for (var i = 0; i < map.content.length; i += 2)
          result = result.remove(map.content[i]);
        return result;
      },
      toObject: function() {
        var result = {};
        this.forEach(function(key, value) {
          result[key] = value;
        });
        return result;
      },
      get size() {
        return this.content.length >> 1;
      }
    };
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap)
        return value;
      var content = [];
      if (value)
        for (var prop in value)
          content.push(prop, value[prop]);
      return new OrderedMap(content);
    };
    module.exports = OrderedMap;
  }
});

// node_modules/prosemirror-model/dist/index.cjs
var require_dist2 = __commonJS({
  "node_modules/prosemirror-model/dist/index.cjs"(exports) {
    "use strict";
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var OrderedMap = require_dist();
    function _interopDefaultLegacy(e) {
      return e && _typeof(e) === "object" && "default" in e ? e : {
        "default": e
      };
    }
    var OrderedMap__default = _interopDefaultLegacy(OrderedMap);
    function _findDiffStart(a, b, pos) {
      for (var i = 0; ; i++) {
        if (i == a.childCount || i == b.childCount)
          return a.childCount == b.childCount ? null : pos;
        var childA = a.child(i), childB = b.child(i);
        if (childA == childB) {
          pos += childA.nodeSize;
          continue;
        }
        if (!childA.sameMarkup(childB))
          return pos;
        if (childA.isText && childA.text != childB.text) {
          for (var j = 0; childA.text[j] == childB.text[j]; j++) {
            pos++;
          }
          return pos;
        }
        if (childA.content.size || childB.content.size) {
          var inner = _findDiffStart(childA.content, childB.content, pos + 1);
          if (inner != null)
            return inner;
        }
        pos += childA.nodeSize;
      }
    }
    function _findDiffEnd(a, b, posA, posB) {
      for (var iA = a.childCount, iB = b.childCount; ; ) {
        if (iA == 0 || iB == 0)
          return iA == iB ? null : {
            a: posA,
            b: posB
          };
        var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
        if (childA == childB) {
          posA -= size;
          posB -= size;
          continue;
        }
        if (!childA.sameMarkup(childB))
          return {
            a: posA,
            b: posB
          };
        if (childA.isText && childA.text != childB.text) {
          var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
          while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
            same++;
            posA--;
            posB--;
          }
          return {
            a: posA,
            b: posB
          };
        }
        if (childA.content.size || childB.content.size) {
          var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
          if (inner)
            return inner;
        }
        posA -= size;
        posB -= size;
      }
    }
    var Fragment = function() {
      function Fragment2(content, size) {
        _classCallCheck(this, Fragment2);
        this.content = content;
        this.size = size || 0;
        if (size == null)
          for (var i = 0; i < content.length; i++) {
            this.size += content[i].nodeSize;
          }
      }
      _createClass(Fragment2, [{
        key: "nodesBetween",
        value: function nodesBetween(from, to, f) {
          var nodeStart = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var parent = arguments.length > 4 ? arguments[4] : void 0;
          for (var i = 0, pos = 0; pos < to; i++) {
            var child = this.content[i], end = pos + child.nodeSize;
            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
              var start = pos + 1;
              child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
            }
            pos = end;
          }
        }
      }, {
        key: "descendants",
        value: function descendants(f) {
          this.nodesBetween(0, this.size, f);
        }
      }, {
        key: "textBetween",
        value: function textBetween(from, to, blockSeparator, leafText) {
          var text = "", separated = true;
          this.nodesBetween(from, to, function(node, pos) {
            if (node.isText) {
              text += node.text.slice(Math.max(from, pos) - pos, to - pos);
              separated = !blockSeparator;
            } else if (node.isLeaf) {
              if (leafText) {
                text += typeof leafText === "function" ? leafText(node) : leafText;
              } else if (node.type.spec.leafText) {
                text += node.type.spec.leafText(node);
              }
              separated = !blockSeparator;
            } else if (!separated && node.isBlock) {
              text += blockSeparator;
              separated = true;
            }
          }, 0);
          return text;
        }
      }, {
        key: "append",
        value: function append(other) {
          if (!other.size)
            return this;
          if (!this.size)
            return other;
          var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
          if (last.isText && last.sameMarkup(first)) {
            content[content.length - 1] = last.withText(last.text + first.text);
            i = 1;
          }
          for (; i < other.content.length; i++) {
            content.push(other.content[i]);
          }
          return new Fragment2(content, this.size + other.size);
        }
      }, {
        key: "cut",
        value: function cut(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size;
          if (from == 0 && to == this.size)
            return this;
          var result = [], size = 0;
          if (to > from)
            for (var i = 0, pos = 0; pos < to; i++) {
              var child = this.content[i], end = pos + child.nodeSize;
              if (end > from) {
                if (pos < from || end > to) {
                  if (child.isText)
                    child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
                  else
                    child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
                }
                result.push(child);
                size += child.nodeSize;
              }
              pos = end;
            }
          return new Fragment2(result, size);
        }
      }, {
        key: "cutByIndex",
        value: function cutByIndex(from, to) {
          if (from == to)
            return Fragment2.empty;
          if (from == 0 && to == this.content.length)
            return this;
          return new Fragment2(this.content.slice(from, to));
        }
      }, {
        key: "replaceChild",
        value: function replaceChild(index, node) {
          var current = this.content[index];
          if (current == node)
            return this;
          var copy2 = this.content.slice();
          var size = this.size + node.nodeSize - current.nodeSize;
          copy2[index] = node;
          return new Fragment2(copy2, size);
        }
      }, {
        key: "addToStart",
        value: function addToStart(node) {
          return new Fragment2([node].concat(this.content), this.size + node.nodeSize);
        }
      }, {
        key: "addToEnd",
        value: function addToEnd(node) {
          return new Fragment2(this.content.concat(node), this.size + node.nodeSize);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          if (this.content.length != other.content.length)
            return false;
          for (var i = 0; i < this.content.length; i++) {
            if (!this.content[i].eq(other.content[i]))
              return false;
          }
          return true;
        }
      }, {
        key: "firstChild",
        get: function get() {
          return this.content.length ? this.content[0] : null;
        }
      }, {
        key: "lastChild",
        get: function get() {
          return this.content.length ? this.content[this.content.length - 1] : null;
        }
      }, {
        key: "childCount",
        get: function get() {
          return this.content.length;
        }
      }, {
        key: "child",
        value: function child(index) {
          var found2 = this.content[index];
          if (!found2)
            throw new RangeError("Index " + index + " out of range for " + this);
          return found2;
        }
      }, {
        key: "maybeChild",
        value: function maybeChild(index) {
          return this.content[index] || null;
        }
      }, {
        key: "forEach",
        value: function forEach(f) {
          for (var i = 0, p = 0; i < this.content.length; i++) {
            var child = this.content[i];
            f(child, p, i);
            p += child.nodeSize;
          }
        }
      }, {
        key: "findDiffStart",
        value: function findDiffStart(other) {
          var pos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return _findDiffStart(this, other, pos);
        }
      }, {
        key: "findDiffEnd",
        value: function findDiffEnd(other) {
          var pos = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size;
          var otherPos = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : other.size;
          return _findDiffEnd(this, other, pos, otherPos);
        }
      }, {
        key: "findIndex",
        value: function findIndex(pos) {
          var round = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
          if (pos == 0)
            return retIndex(0, pos);
          if (pos == this.size)
            return retIndex(this.content.length, pos);
          if (pos > this.size || pos < 0)
            throw new RangeError("Position ".concat(pos, " outside of fragment (").concat(this, ")"));
          for (var i = 0, curPos = 0; ; i++) {
            var cur = this.child(i), end = curPos + cur.nodeSize;
            if (end >= pos) {
              if (end == pos || round > 0)
                return retIndex(i + 1, end);
              return retIndex(i, curPos);
            }
            curPos = end;
          }
        }
      }, {
        key: "toString",
        value: function toString() {
          return "<" + this.toStringInner() + ">";
        }
      }, {
        key: "toStringInner",
        value: function toStringInner() {
          return this.content.join(", ");
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return this.content.length ? this.content.map(function(n) {
            return n.toJSON();
          }) : null;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, value) {
          if (!value)
            return Fragment2.empty;
          if (!Array.isArray(value))
            throw new RangeError("Invalid input for Fragment.fromJSON");
          return new Fragment2(value.map(schema.nodeFromJSON));
        }
      }, {
        key: "fromArray",
        value: function fromArray(array) {
          if (!array.length)
            return Fragment2.empty;
          var joined, size = 0;
          for (var i = 0; i < array.length; i++) {
            var node = array[i];
            size += node.nodeSize;
            if (i && node.isText && array[i - 1].sameMarkup(node)) {
              if (!joined)
                joined = array.slice(0, i);
              joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
            } else if (joined) {
              joined.push(node);
            }
          }
          return new Fragment2(joined || array, size);
        }
      }, {
        key: "from",
        value: function from(nodes) {
          if (!nodes)
            return Fragment2.empty;
          if (nodes instanceof Fragment2)
            return nodes;
          if (Array.isArray(nodes))
            return this.fromArray(nodes);
          if (nodes.attrs)
            return new Fragment2([nodes], nodes.nodeSize);
          throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
        }
      }]);
      return Fragment2;
    }();
    Fragment.empty = new Fragment([], 0);
    var found = {
      index: 0,
      offset: 0
    };
    function retIndex(index, offset) {
      found.index = index;
      found.offset = offset;
      return found;
    }
    function compareDeep(a, b) {
      if (a === b)
        return true;
      if (!(a && _typeof(a) == "object") || !(b && _typeof(b) == "object"))
        return false;
      var array = Array.isArray(a);
      if (Array.isArray(b) != array)
        return false;
      if (array) {
        if (a.length != b.length)
          return false;
        for (var i = 0; i < a.length; i++) {
          if (!compareDeep(a[i], b[i]))
            return false;
        }
      } else {
        for (var p in a) {
          if (!(p in b) || !compareDeep(a[p], b[p]))
            return false;
        }
        for (var _p in b) {
          if (!(_p in a))
            return false;
        }
      }
      return true;
    }
    var Mark = function() {
      function Mark2(type, attrs) {
        _classCallCheck(this, Mark2);
        this.type = type;
        this.attrs = attrs;
      }
      _createClass(Mark2, [{
        key: "addToSet",
        value: function addToSet(set) {
          var copy2, placed = false;
          for (var i = 0; i < set.length; i++) {
            var other = set[i];
            if (this.eq(other))
              return set;
            if (this.type.excludes(other.type)) {
              if (!copy2)
                copy2 = set.slice(0, i);
            } else if (other.type.excludes(this.type)) {
              return set;
            } else {
              if (!placed && other.type.rank > this.type.rank) {
                if (!copy2)
                  copy2 = set.slice(0, i);
                copy2.push(this);
                placed = true;
              }
              if (copy2)
                copy2.push(other);
            }
          }
          if (!copy2)
            copy2 = set.slice();
          if (!placed)
            copy2.push(this);
          return copy2;
        }
      }, {
        key: "removeFromSet",
        value: function removeFromSet(set) {
          for (var i = 0; i < set.length; i++) {
            if (this.eq(set[i]))
              return set.slice(0, i).concat(set.slice(i + 1));
          }
          return set;
        }
      }, {
        key: "isInSet",
        value: function isInSet(set) {
          for (var i = 0; i < set.length; i++) {
            if (this.eq(set[i]))
              return true;
          }
          return false;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var obj = {
            type: this.type.name
          };
          for (var _ in this.attrs) {
            obj.attrs = this.attrs;
            break;
          }
          return obj;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (!json)
            throw new RangeError("Invalid input for Mark.fromJSON");
          var type = schema.marks[json.type];
          if (!type)
            throw new RangeError("There is no mark type ".concat(json.type, " in this schema"));
          return type.create(json.attrs);
        }
      }, {
        key: "sameSet",
        value: function sameSet(a, b) {
          if (a == b)
            return true;
          if (a.length != b.length)
            return false;
          for (var i = 0; i < a.length; i++) {
            if (!a[i].eq(b[i]))
              return false;
          }
          return true;
        }
      }, {
        key: "setFrom",
        value: function setFrom(marks) {
          if (!marks || Array.isArray(marks) && marks.length == 0)
            return Mark2.none;
          if (marks instanceof Mark2)
            return [marks];
          var copy2 = marks.slice();
          copy2.sort(function(a, b) {
            return a.type.rank - b.type.rank;
          });
          return copy2;
        }
      }]);
      return Mark2;
    }();
    Mark.none = [];
    var ReplaceError = function(_Error) {
      _inherits(ReplaceError2, _Error);
      var _super = _createSuper(ReplaceError2);
      function ReplaceError2() {
        _classCallCheck(this, ReplaceError2);
        return _super.apply(this, arguments);
      }
      return _createClass(ReplaceError2);
    }(_wrapNativeSuper(Error));
    var Slice = function() {
      function Slice2(content, openStart, openEnd) {
        _classCallCheck(this, Slice2);
        this.content = content;
        this.openStart = openStart;
        this.openEnd = openEnd;
      }
      _createClass(Slice2, [{
        key: "size",
        get: function get() {
          return this.content.size - this.openStart - this.openEnd;
        }
      }, {
        key: "insertAt",
        value: function insertAt(pos, fragment) {
          var content = insertInto(this.content, pos + this.openStart, fragment);
          return content && new Slice2(content, this.openStart, this.openEnd);
        }
      }, {
        key: "removeBetween",
        value: function removeBetween(from, to) {
          return new Slice2(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
        }
      }, {
        key: "toString",
        value: function toString() {
          return this.content + "(" + this.openStart + "," + this.openEnd + ")";
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          if (!this.content.size)
            return null;
          var json = {
            content: this.content.toJSON()
          };
          if (this.openStart > 0)
            json.openStart = this.openStart;
          if (this.openEnd > 0)
            json.openEnd = this.openEnd;
          return json;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (!json)
            return Slice2.empty;
          var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
          if (typeof openStart != "number" || typeof openEnd != "number")
            throw new RangeError("Invalid input for Slice.fromJSON");
          return new Slice2(Fragment.fromJSON(schema, json.content), openStart, openEnd);
        }
      }, {
        key: "maxOpen",
        value: function maxOpen(fragment) {
          var openIsolating = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var openStart = 0, openEnd = 0;
          for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
            openStart++;
          }
          for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) {
            openEnd++;
          }
          return new Slice2(fragment, openStart, openEnd);
        }
      }]);
      return Slice2;
    }();
    Slice.empty = new Slice(Fragment.empty, 0, 0);
    function removeRange(content, from, to) {
      var _content$findIndex = content.findIndex(from), index = _content$findIndex.index, offset = _content$findIndex.offset, child = content.maybeChild(index);
      var _content$findIndex2 = content.findIndex(to), indexTo = _content$findIndex2.index, offsetTo = _content$findIndex2.offset;
      if (offset == from || child.isText) {
        if (offsetTo != to && !content.child(indexTo).isText)
          throw new RangeError("Removing non-flat range");
        return content.cut(0, from).append(content.cut(to));
      }
      if (index != indexTo)
        throw new RangeError("Removing non-flat range");
      return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
    }
    function insertInto(content, dist, insert, parent) {
      var _content$findIndex3 = content.findIndex(dist), index = _content$findIndex3.index, offset = _content$findIndex3.offset, child = content.maybeChild(index);
      if (offset == dist || child.isText) {
        if (parent && !parent.canReplace(index, index, insert))
          return null;
        return content.cut(0, dist).append(insert).append(content.cut(dist));
      }
      var inner = insertInto(child.content, dist - offset - 1, insert);
      return inner && content.replaceChild(index, child.copy(inner));
    }
    function _replace($from, $to, slice) {
      if (slice.openStart > $from.depth)
        throw new ReplaceError("Inserted content deeper than insertion position");
      if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
        throw new ReplaceError("Inconsistent open depths");
      return replaceOuter($from, $to, slice, 0);
    }
    function replaceOuter($from, $to, slice, depth) {
      var index = $from.index(depth), node = $from.node(depth);
      if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
        var inner = replaceOuter($from, $to, slice, depth + 1);
        return node.copy(node.content.replaceChild(index, inner));
      } else if (!slice.content.size) {
        return close(node, replaceTwoWay($from, $to, depth));
      } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
        var parent = $from.parent, content = parent.content;
        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
      } else {
        var _prepareSliceForRepla = prepareSliceForReplace(slice, $from), start = _prepareSliceForRepla.start, end = _prepareSliceForRepla.end;
        return close(node, replaceThreeWay($from, start, end, $to, depth));
      }
    }
    function checkJoin(main, sub) {
      if (!sub.type.compatibleContent(main.type))
        throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
    }
    function joinable($before, $after, depth) {
      var node = $before.node(depth);
      checkJoin(node, $after.node(depth));
      return node;
    }
    function addNode(child, target) {
      var last = target.length - 1;
      if (last >= 0 && child.isText && child.sameMarkup(target[last]))
        target[last] = child.withText(target[last].text + child.text);
      else
        target.push(child);
    }
    function addRange($start, $end, depth, target) {
      var node = ($end || $start).node(depth);
      var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
      if ($start) {
        startIndex = $start.index(depth);
        if ($start.depth > depth) {
          startIndex++;
        } else if ($start.textOffset) {
          addNode($start.nodeAfter, target);
          startIndex++;
        }
      }
      for (var i = startIndex; i < endIndex; i++) {
        addNode(node.child(i), target);
      }
      if ($end && $end.depth == depth && $end.textOffset)
        addNode($end.nodeBefore, target);
    }
    function close(node, content) {
      if (!node.type.validContent(content))
        throw new ReplaceError("Invalid content for node " + node.type.name);
      return node.copy(content);
    }
    function replaceThreeWay($from, $start, $end, $to, depth) {
      var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
      var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
      var content = [];
      addRange(null, $from, depth, content);
      if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
        checkJoin(openStart, openEnd);
        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
      } else {
        if (openStart)
          addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
        addRange($start, $end, depth, content);
        if (openEnd)
          addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function replaceTwoWay($from, $to, depth) {
      var content = [];
      addRange(null, $from, depth, content);
      if ($from.depth > depth) {
        var type = joinable($from, $to, depth + 1);
        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
      }
      addRange($to, null, depth, content);
      return new Fragment(content);
    }
    function prepareSliceForReplace(slice, $along) {
      var extra = $along.depth - slice.openStart, parent = $along.node(extra);
      var node = parent.copy(slice.content);
      for (var i = extra - 1; i >= 0; i--) {
        node = $along.node(i).copy(Fragment.from(node));
      }
      return {
        start: node.resolveNoCache(slice.openStart + extra),
        end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
      };
    }
    var ResolvedPos = function() {
      function ResolvedPos2(pos, path, parentOffset) {
        _classCallCheck(this, ResolvedPos2);
        this.pos = pos;
        this.path = path;
        this.parentOffset = parentOffset;
        this.depth = path.length / 3 - 1;
      }
      _createClass(ResolvedPos2, [{
        key: "resolveDepth",
        value: function resolveDepth(val) {
          if (val == null)
            return this.depth;
          if (val < 0)
            return this.depth + val;
          return val;
        }
      }, {
        key: "parent",
        get: function get() {
          return this.node(this.depth);
        }
      }, {
        key: "doc",
        get: function get() {
          return this.node(0);
        }
      }, {
        key: "node",
        value: function node(depth) {
          return this.path[this.resolveDepth(depth) * 3];
        }
      }, {
        key: "index",
        value: function index(depth) {
          return this.path[this.resolveDepth(depth) * 3 + 1];
        }
      }, {
        key: "indexAfter",
        value: function indexAfter(depth) {
          depth = this.resolveDepth(depth);
          return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
        }
      }, {
        key: "start",
        value: function start(depth) {
          depth = this.resolveDepth(depth);
          return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
        }
      }, {
        key: "end",
        value: function end(depth) {
          depth = this.resolveDepth(depth);
          return this.start(depth) + this.node(depth).content.size;
        }
      }, {
        key: "before",
        value: function before(depth) {
          depth = this.resolveDepth(depth);
          if (!depth)
            throw new RangeError("There is no position before the top-level node");
          return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
        }
      }, {
        key: "after",
        value: function after(depth) {
          depth = this.resolveDepth(depth);
          if (!depth)
            throw new RangeError("There is no position after the top-level node");
          return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
        }
      }, {
        key: "textOffset",
        get: function get() {
          return this.pos - this.path[this.path.length - 1];
        }
      }, {
        key: "nodeAfter",
        get: function get() {
          var parent = this.parent, index = this.index(this.depth);
          if (index == parent.childCount)
            return null;
          var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
          return dOff ? parent.child(index).cut(dOff) : child;
        }
      }, {
        key: "nodeBefore",
        get: function get() {
          var index = this.index(this.depth);
          var dOff = this.pos - this.path[this.path.length - 1];
          if (dOff)
            return this.parent.child(index).cut(0, dOff);
          return index == 0 ? null : this.parent.child(index - 1);
        }
      }, {
        key: "posAtIndex",
        value: function posAtIndex(index, depth) {
          depth = this.resolveDepth(depth);
          var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
          for (var i = 0; i < index; i++) {
            pos += node.child(i).nodeSize;
          }
          return pos;
        }
      }, {
        key: "marks",
        value: function marks() {
          var parent = this.parent, index = this.index();
          if (parent.content.size == 0)
            return Mark.none;
          if (this.textOffset)
            return parent.child(index).marks;
          var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
          if (!main) {
            var tmp = main;
            main = other;
            other = tmp;
          }
          var marks2 = main.marks;
          for (var i = 0; i < marks2.length; i++) {
            if (marks2[i].type.spec.inclusive === false && (!other || !marks2[i].isInSet(other.marks)))
              marks2 = marks2[i--].removeFromSet(marks2);
          }
          return marks2;
        }
      }, {
        key: "marksAcross",
        value: function marksAcross($end) {
          var after = this.parent.maybeChild(this.index());
          if (!after || !after.isInline)
            return null;
          var marks = after.marks, next = $end.parent.maybeChild($end.index());
          for (var i = 0; i < marks.length; i++) {
            if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
              marks = marks[i--].removeFromSet(marks);
          }
          return marks;
        }
      }, {
        key: "sharedDepth",
        value: function sharedDepth(pos) {
          for (var depth = this.depth; depth > 0; depth--) {
            if (this.start(depth) <= pos && this.end(depth) >= pos)
              return depth;
          }
          return 0;
        }
      }, {
        key: "blockRange",
        value: function blockRange() {
          var other = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this;
          var pred = arguments.length > 1 ? arguments[1] : void 0;
          if (other.pos < this.pos)
            return other.blockRange(this);
          for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
            if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
              return new NodeRange(this, other, d);
          }
          return null;
        }
      }, {
        key: "sameParent",
        value: function sameParent(other) {
          return this.pos - this.parentOffset == other.pos - other.parentOffset;
        }
      }, {
        key: "max",
        value: function max(other) {
          return other.pos > this.pos ? other : this;
        }
      }, {
        key: "min",
        value: function min(other) {
          return other.pos < this.pos ? other : this;
        }
      }, {
        key: "toString",
        value: function toString() {
          var str = "";
          for (var i = 1; i <= this.depth; i++) {
            str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
          }
          return str + ":" + this.parentOffset;
        }
      }], [{
        key: "resolve",
        value: function resolve(doc2, pos) {
          if (!(pos >= 0 && pos <= doc2.content.size))
            throw new RangeError("Position " + pos + " out of range");
          var path = [];
          var start = 0, parentOffset = pos;
          for (var node = doc2; ; ) {
            var _node$content$findInd = node.content.findIndex(parentOffset), index = _node$content$findInd.index, offset = _node$content$findInd.offset;
            var rem = parentOffset - offset;
            path.push(node, index, start + offset);
            if (!rem)
              break;
            node = node.child(index);
            if (node.isText)
              break;
            parentOffset = rem - 1;
            start += offset + 1;
          }
          return new ResolvedPos2(pos, path, parentOffset);
        }
      }, {
        key: "resolveCached",
        value: function resolveCached(doc2, pos) {
          for (var i = 0; i < resolveCache.length; i++) {
            var cached = resolveCache[i];
            if (cached.pos == pos && cached.doc == doc2)
              return cached;
          }
          var result = resolveCache[resolveCachePos] = ResolvedPos2.resolve(doc2, pos);
          resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
          return result;
        }
      }]);
      return ResolvedPos2;
    }();
    var resolveCache = [];
    var resolveCachePos = 0;
    var resolveCacheSize = 12;
    var NodeRange = function() {
      function NodeRange2($from, $to, depth) {
        _classCallCheck(this, NodeRange2);
        this.$from = $from;
        this.$to = $to;
        this.depth = depth;
      }
      _createClass(NodeRange2, [{
        key: "start",
        get: function get() {
          return this.$from.before(this.depth + 1);
        }
      }, {
        key: "end",
        get: function get() {
          return this.$to.after(this.depth + 1);
        }
      }, {
        key: "parent",
        get: function get() {
          return this.$from.node(this.depth);
        }
      }, {
        key: "startIndex",
        get: function get() {
          return this.$from.index(this.depth);
        }
      }, {
        key: "endIndex",
        get: function get() {
          return this.$to.indexAfter(this.depth);
        }
      }]);
      return NodeRange2;
    }();
    var emptyAttrs = /* @__PURE__ */ Object.create(null);
    var Node2 = function() {
      function Node3(type, attrs, content) {
        var marks = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Mark.none;
        _classCallCheck(this, Node3);
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.content = content || Fragment.empty;
      }
      _createClass(Node3, [{
        key: "nodeSize",
        get: function get() {
          return this.isLeaf ? 1 : 2 + this.content.size;
        }
      }, {
        key: "childCount",
        get: function get() {
          return this.content.childCount;
        }
      }, {
        key: "child",
        value: function child(index) {
          return this.content.child(index);
        }
      }, {
        key: "maybeChild",
        value: function maybeChild(index) {
          return this.content.maybeChild(index);
        }
      }, {
        key: "forEach",
        value: function forEach(f) {
          this.content.forEach(f);
        }
      }, {
        key: "nodesBetween",
        value: function nodesBetween(from, to, f) {
          var startPos = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          this.content.nodesBetween(from, to, f, startPos, this);
        }
      }, {
        key: "descendants",
        value: function descendants(f) {
          this.nodesBetween(0, this.content.size, f);
        }
      }, {
        key: "textContent",
        get: function get() {
          return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
        }
      }, {
        key: "textBetween",
        value: function textBetween(from, to, blockSeparator, leafText) {
          return this.content.textBetween(from, to, blockSeparator, leafText);
        }
      }, {
        key: "firstChild",
        get: function get() {
          return this.content.firstChild;
        }
      }, {
        key: "lastChild",
        get: function get() {
          return this.content.lastChild;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || this.sameMarkup(other) && this.content.eq(other.content);
        }
      }, {
        key: "sameMarkup",
        value: function sameMarkup(other) {
          return this.hasMarkup(other.type, other.attrs, other.marks);
        }
      }, {
        key: "hasMarkup",
        value: function hasMarkup(type, attrs, marks) {
          return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
        }
      }, {
        key: "copy",
        value: function copy2() {
          var content = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          if (content == this.content)
            return this;
          return new Node3(this.type, this.attrs, content, this.marks);
        }
      }, {
        key: "mark",
        value: function mark(marks) {
          return marks == this.marks ? this : new Node3(this.type, this.attrs, this.content, marks);
        }
      }, {
        key: "cut",
        value: function cut(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size;
          if (from == 0 && to == this.content.size)
            return this;
          return this.copy(this.content.cut(from, to));
        }
      }, {
        key: "slice",
        value: function slice(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size;
          var includeParents = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          if (from == to)
            return Slice.empty;
          var $from = this.resolve(from), $to = this.resolve(to);
          var depth = includeParents ? 0 : $from.sharedDepth(to);
          var start = $from.start(depth), node = $from.node(depth);
          var content = node.content.cut($from.pos - start, $to.pos - start);
          return new Slice(content, $from.depth - depth, $to.depth - depth);
        }
      }, {
        key: "replace",
        value: function replace(from, to, slice) {
          return _replace(this.resolve(from), this.resolve(to), slice);
        }
      }, {
        key: "nodeAt",
        value: function nodeAt(pos) {
          for (var node = this; ; ) {
            var _node$content$findInd2 = node.content.findIndex(pos), index = _node$content$findInd2.index, offset = _node$content$findInd2.offset;
            node = node.maybeChild(index);
            if (!node)
              return null;
            if (offset == pos || node.isText)
              return node;
            pos -= offset + 1;
          }
        }
      }, {
        key: "childAfter",
        value: function childAfter(pos) {
          var _this$content$findInd = this.content.findIndex(pos), index = _this$content$findInd.index, offset = _this$content$findInd.offset;
          return {
            node: this.content.maybeChild(index),
            index,
            offset
          };
        }
      }, {
        key: "childBefore",
        value: function childBefore(pos) {
          if (pos == 0)
            return {
              node: null,
              index: 0,
              offset: 0
            };
          var _this$content$findInd2 = this.content.findIndex(pos), index = _this$content$findInd2.index, offset = _this$content$findInd2.offset;
          if (offset < pos)
            return {
              node: this.content.child(index),
              index,
              offset
            };
          var node = this.content.child(index - 1);
          return {
            node,
            index: index - 1,
            offset: offset - node.nodeSize
          };
        }
      }, {
        key: "resolve",
        value: function resolve(pos) {
          return ResolvedPos.resolveCached(this, pos);
        }
      }, {
        key: "resolveNoCache",
        value: function resolveNoCache(pos) {
          return ResolvedPos.resolve(this, pos);
        }
      }, {
        key: "rangeHasMark",
        value: function rangeHasMark(from, to, type) {
          var found2 = false;
          if (to > from)
            this.nodesBetween(from, to, function(node) {
              if (type.isInSet(node.marks))
                found2 = true;
              return !found2;
            });
          return found2;
        }
      }, {
        key: "isBlock",
        get: function get() {
          return this.type.isBlock;
        }
      }, {
        key: "isTextblock",
        get: function get() {
          return this.type.isTextblock;
        }
      }, {
        key: "inlineContent",
        get: function get() {
          return this.type.inlineContent;
        }
      }, {
        key: "isInline",
        get: function get() {
          return this.type.isInline;
        }
      }, {
        key: "isText",
        get: function get() {
          return this.type.isText;
        }
      }, {
        key: "isLeaf",
        get: function get() {
          return this.type.isLeaf;
        }
      }, {
        key: "isAtom",
        get: function get() {
          return this.type.isAtom;
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
          var name = this.type.name;
          if (this.content.size)
            name += "(" + this.content.toStringInner() + ")";
          return wrapMarks(this.marks, name);
        }
      }, {
        key: "contentMatchAt",
        value: function contentMatchAt(index) {
          var match = this.type.contentMatch.matchFragment(this.content, 0, index);
          if (!match)
            throw new Error("Called contentMatchAt on a node with invalid content");
          return match;
        }
      }, {
        key: "canReplace",
        value: function canReplace(from, to) {
          var replacement = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Fragment.empty;
          var start = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          var end = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : replacement.childCount;
          var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
          var two = one && one.matchFragment(this.content, to);
          if (!two || !two.validEnd)
            return false;
          for (var i = start; i < end; i++) {
            if (!this.type.allowsMarks(replacement.child(i).marks))
              return false;
          }
          return true;
        }
      }, {
        key: "canReplaceWith",
        value: function canReplaceWith(from, to, type, marks) {
          if (marks && !this.type.allowsMarks(marks))
            return false;
          var start = this.contentMatchAt(from).matchType(type);
          var end = start && start.matchFragment(this.content, to);
          return end ? end.validEnd : false;
        }
      }, {
        key: "canAppend",
        value: function canAppend(other) {
          if (other.content.size)
            return this.canReplace(this.childCount, this.childCount, other.content);
          else
            return this.type.compatibleContent(other.type);
        }
      }, {
        key: "check",
        value: function check() {
          if (!this.type.validContent(this.content))
            throw new RangeError("Invalid content for node ".concat(this.type.name, ": ").concat(this.content.toString().slice(0, 50)));
          var copy2 = Mark.none;
          for (var i = 0; i < this.marks.length; i++) {
            copy2 = this.marks[i].addToSet(copy2);
          }
          if (!Mark.sameSet(copy2, this.marks))
            throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function(m) {
              return m.type.name;
            })));
          this.content.forEach(function(node) {
            return node.check();
          });
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var obj = {
            type: this.type.name
          };
          for (var _ in this.attrs) {
            obj.attrs = this.attrs;
            break;
          }
          if (this.content.size)
            obj.content = this.content.toJSON();
          if (this.marks.length)
            obj.marks = this.marks.map(function(n) {
              return n.toJSON();
            });
          return obj;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (!json)
            throw new RangeError("Invalid input for Node.fromJSON");
          var marks = null;
          if (json.marks) {
            if (!Array.isArray(json.marks))
              throw new RangeError("Invalid mark data for Node.fromJSON");
            marks = json.marks.map(schema.markFromJSON);
          }
          if (json.type == "text") {
            if (typeof json.text != "string")
              throw new RangeError("Invalid text node in JSON");
            return schema.text(json.text, marks);
          }
          var content = Fragment.fromJSON(schema, json.content);
          return schema.nodeType(json.type).create(json.attrs, content, marks);
        }
      }]);
      return Node3;
    }();
    Node2.prototype.text = void 0;
    var TextNode = function(_Node) {
      _inherits(TextNode2, _Node);
      var _super2 = _createSuper(TextNode2);
      function TextNode2(type, attrs, content, marks) {
        var _this;
        _classCallCheck(this, TextNode2);
        _this = _super2.call(this, type, attrs, null, marks);
        if (!content)
          throw new RangeError("Empty text nodes are not allowed");
        _this.text = content;
        return _this;
      }
      _createClass(TextNode2, [{
        key: "toString",
        value: function toString() {
          if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
          return wrapMarks(this.marks, JSON.stringify(this.text));
        }
      }, {
        key: "textContent",
        get: function get() {
          return this.text;
        }
      }, {
        key: "textBetween",
        value: function textBetween(from, to) {
          return this.text.slice(from, to);
        }
      }, {
        key: "nodeSize",
        get: function get() {
          return this.text.length;
        }
      }, {
        key: "mark",
        value: function mark(marks) {
          return marks == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks);
        }
      }, {
        key: "withText",
        value: function withText(text) {
          if (text == this.text)
            return this;
          return new TextNode2(this.type, this.attrs, text, this.marks);
        }
      }, {
        key: "cut",
        value: function cut() {
          var from = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.text.length;
          if (from == 0 && to == this.text.length)
            return this;
          return this.withText(this.text.slice(from, to));
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this.sameMarkup(other) && this.text == other.text;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var base = _get(_getPrototypeOf(TextNode2.prototype), "toJSON", this).call(this);
          base.text = this.text;
          return base;
        }
      }]);
      return TextNode2;
    }(Node2);
    function wrapMarks(marks, str) {
      for (var i = marks.length - 1; i >= 0; i--) {
        str = marks[i].type.name + "(" + str + ")";
      }
      return str;
    }
    var ContentMatch = function() {
      function ContentMatch2(validEnd) {
        _classCallCheck(this, ContentMatch2);
        this.validEnd = validEnd;
        this.next = [];
        this.wrapCache = [];
      }
      _createClass(ContentMatch2, [{
        key: "matchType",
        value: function matchType(type) {
          for (var i = 0; i < this.next.length; i++) {
            if (this.next[i].type == type)
              return this.next[i].next;
          }
          return null;
        }
      }, {
        key: "matchFragment",
        value: function matchFragment(frag) {
          var start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : frag.childCount;
          var cur = this;
          for (var i = start; cur && i < end; i++) {
            cur = cur.matchType(frag.child(i).type);
          }
          return cur;
        }
      }, {
        key: "inlineContent",
        get: function get() {
          return this.next.length && this.next[0].type.isInline;
        }
      }, {
        key: "defaultType",
        get: function get() {
          for (var i = 0; i < this.next.length; i++) {
            var type = this.next[i].type;
            if (!(type.isText || type.hasRequiredAttrs()))
              return type;
          }
          return null;
        }
      }, {
        key: "compatible",
        value: function compatible(other) {
          for (var i = 0; i < this.next.length; i++) {
            for (var j = 0; j < other.next.length; j++) {
              if (this.next[i].type == other.next[j].type)
                return true;
            }
          }
          return false;
        }
      }, {
        key: "fillBefore",
        value: function fillBefore(after) {
          var toEnd = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          var startIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          var seen = [this];
          function search(match, types) {
            var finished = match.matchFragment(after, startIndex);
            if (finished && (!toEnd || finished.validEnd))
              return Fragment.from(types.map(function(tp) {
                return tp.createAndFill();
              }));
            for (var i = 0; i < match.next.length; i++) {
              var _match$next$i = match.next[i], type = _match$next$i.type, next = _match$next$i.next;
              if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
                seen.push(next);
                var _found = search(next, types.concat(type));
                if (_found)
                  return _found;
              }
            }
            return null;
          }
          return search(this, []);
        }
      }, {
        key: "findWrapping",
        value: function findWrapping(target) {
          for (var i = 0; i < this.wrapCache.length; i += 2) {
            if (this.wrapCache[i] == target)
              return this.wrapCache[i + 1];
          }
          var computed = this.computeWrapping(target);
          this.wrapCache.push(target, computed);
          return computed;
        }
      }, {
        key: "computeWrapping",
        value: function computeWrapping(target) {
          var seen = /* @__PURE__ */ Object.create(null), active = [{
            match: this,
            type: null,
            via: null
          }];
          while (active.length) {
            var current = active.shift(), match = current.match;
            if (match.matchType(target)) {
              var result = [];
              for (var obj = current; obj.type; obj = obj.via) {
                result.push(obj.type);
              }
              return result.reverse();
            }
            for (var i = 0; i < match.next.length; i++) {
              var _match$next$i2 = match.next[i], type = _match$next$i2.type, next = _match$next$i2.next;
              if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
                active.push({
                  match: type.contentMatch,
                  type,
                  via: current
                });
                seen[type.name] = true;
              }
            }
          }
          return null;
        }
      }, {
        key: "edgeCount",
        get: function get() {
          return this.next.length;
        }
      }, {
        key: "edge",
        value: function edge(n) {
          if (n >= this.next.length)
            throw new RangeError("There's no ".concat(n, "th edge in this content match"));
          return this.next[n];
        }
      }, {
        key: "toString",
        value: function toString() {
          var seen = [];
          function scan(m) {
            seen.push(m);
            for (var i = 0; i < m.next.length; i++) {
              if (seen.indexOf(m.next[i].next) == -1)
                scan(m.next[i].next);
            }
          }
          scan(this);
          return seen.map(function(m, i) {
            var out = i + (m.validEnd ? "*" : " ") + " ";
            for (var _i = 0; _i < m.next.length; _i++) {
              out += (_i ? ", " : "") + m.next[_i].type.name + "->" + seen.indexOf(m.next[_i].next);
            }
            return out;
          }).join("\n");
        }
      }], [{
        key: "parse",
        value: function parse(string, nodeTypes) {
          var stream = new TokenStream(string, nodeTypes);
          if (stream.next == null)
            return ContentMatch2.empty;
          var expr = parseExpr(stream);
          if (stream.next)
            stream.err("Unexpected trailing text");
          var match = dfa(nfa(expr));
          checkForDeadEnds(match, stream);
          return match;
        }
      }]);
      return ContentMatch2;
    }();
    ContentMatch.empty = new ContentMatch(true);
    var TokenStream = function() {
      function TokenStream2(string, nodeTypes) {
        _classCallCheck(this, TokenStream2);
        this.string = string;
        this.nodeTypes = nodeTypes;
        this.inline = null;
        this.pos = 0;
        this.tokens = string.split(/\s*(?=\b|\W|$)/);
        if (this.tokens[this.tokens.length - 1] == "")
          this.tokens.pop();
        if (this.tokens[0] == "")
          this.tokens.shift();
      }
      _createClass(TokenStream2, [{
        key: "next",
        get: function get() {
          return this.tokens[this.pos];
        }
      }, {
        key: "eat",
        value: function eat(tok) {
          return this.next == tok && (this.pos++ || true);
        }
      }, {
        key: "err",
        value: function err(str) {
          throw new SyntaxError(str + " (in content expression '" + this.string + "')");
        }
      }]);
      return TokenStream2;
    }();
    function parseExpr(stream) {
      var exprs = [];
      do {
        exprs.push(parseExprSeq(stream));
      } while (stream.eat("|"));
      return exprs.length == 1 ? exprs[0] : {
        type: "choice",
        exprs
      };
    }
    function parseExprSeq(stream) {
      var exprs = [];
      do {
        exprs.push(parseExprSubscript(stream));
      } while (stream.next && stream.next != ")" && stream.next != "|");
      return exprs.length == 1 ? exprs[0] : {
        type: "seq",
        exprs
      };
    }
    function parseExprSubscript(stream) {
      var expr = parseExprAtom(stream);
      for (; ; ) {
        if (stream.eat("+"))
          expr = {
            type: "plus",
            expr
          };
        else if (stream.eat("*"))
          expr = {
            type: "star",
            expr
          };
        else if (stream.eat("?"))
          expr = {
            type: "opt",
            expr
          };
        else if (stream.eat("{"))
          expr = parseExprRange(stream, expr);
        else
          break;
      }
      return expr;
    }
    function parseNum(stream) {
      if (/\D/.test(stream.next))
        stream.err("Expected number, got '" + stream.next + "'");
      var result = Number(stream.next);
      stream.pos++;
      return result;
    }
    function parseExprRange(stream, expr) {
      var min = parseNum(stream), max = min;
      if (stream.eat(",")) {
        if (stream.next != "}")
          max = parseNum(stream);
        else
          max = -1;
      }
      if (!stream.eat("}"))
        stream.err("Unclosed braced range");
      return {
        type: "range",
        min,
        max,
        expr
      };
    }
    function resolveName(stream, name) {
      var types = stream.nodeTypes, type = types[name];
      if (type)
        return [type];
      var result = [];
      for (var typeName in types) {
        var _type = types[typeName];
        if (_type.groups.indexOf(name) > -1)
          result.push(_type);
      }
      if (result.length == 0)
        stream.err("No node type or group '" + name + "' found");
      return result;
    }
    function parseExprAtom(stream) {
      if (stream.eat("(")) {
        var expr = parseExpr(stream);
        if (!stream.eat(")"))
          stream.err("Missing closing paren");
        return expr;
      } else if (!/\W/.test(stream.next)) {
        var exprs = resolveName(stream, stream.next).map(function(type) {
          if (stream.inline == null)
            stream.inline = type.isInline;
          else if (stream.inline != type.isInline)
            stream.err("Mixing inline and block content");
          return {
            type: "name",
            value: type
          };
        });
        stream.pos++;
        return exprs.length == 1 ? exprs[0] : {
          type: "choice",
          exprs
        };
      } else {
        stream.err("Unexpected token '" + stream.next + "'");
      }
    }
    function nfa(expr) {
      var nfa2 = [[]];
      connect(compile(expr, 0), node());
      return nfa2;
      function node() {
        return nfa2.push([]) - 1;
      }
      function edge(from, to, term) {
        var edge2 = {
          term,
          to
        };
        nfa2[from].push(edge2);
        return edge2;
      }
      function connect(edges, to) {
        edges.forEach(function(edge2) {
          return edge2.to = to;
        });
      }
      function compile(expr2, from) {
        if (expr2.type == "choice") {
          return expr2.exprs.reduce(function(out, expr3) {
            return out.concat(compile(expr3, from));
          }, []);
        } else if (expr2.type == "seq") {
          for (var i = 0; ; i++) {
            var next = compile(expr2.exprs[i], from);
            if (i == expr2.exprs.length - 1)
              return next;
            connect(next, from = node());
          }
        } else if (expr2.type == "star") {
          var loop = node();
          edge(from, loop);
          connect(compile(expr2.expr, loop), loop);
          return [edge(loop)];
        } else if (expr2.type == "plus") {
          var _loop = node();
          connect(compile(expr2.expr, from), _loop);
          connect(compile(expr2.expr, _loop), _loop);
          return [edge(_loop)];
        } else if (expr2.type == "opt") {
          return [edge(from)].concat(compile(expr2.expr, from));
        } else if (expr2.type == "range") {
          var cur = from;
          for (var _i2 = 0; _i2 < expr2.min; _i2++) {
            var _next = node();
            connect(compile(expr2.expr, cur), _next);
            cur = _next;
          }
          if (expr2.max == -1) {
            connect(compile(expr2.expr, cur), cur);
          } else {
            for (var _i3 = expr2.min; _i3 < expr2.max; _i3++) {
              var _next2 = node();
              edge(cur, _next2);
              connect(compile(expr2.expr, cur), _next2);
              cur = _next2;
            }
          }
          return [edge(cur)];
        } else if (expr2.type == "name") {
          return [edge(from, void 0, expr2.value)];
        } else {
          throw new Error("Unknown expr type");
        }
      }
    }
    function cmp(a, b) {
      return b - a;
    }
    function nullFrom(nfa2, node) {
      var result = [];
      scan(node);
      return result.sort(cmp);
      function scan(node2) {
        var edges = nfa2[node2];
        if (edges.length == 1 && !edges[0].term)
          return scan(edges[0].to);
        result.push(node2);
        for (var i = 0; i < edges.length; i++) {
          var _edges$i = edges[i], term = _edges$i.term, to = _edges$i.to;
          if (!term && result.indexOf(to) == -1)
            scan(to);
        }
      }
    }
    function dfa(nfa2) {
      var labeled = /* @__PURE__ */ Object.create(null);
      return explore(nullFrom(nfa2, 0));
      function explore(states) {
        var out = [];
        states.forEach(function(node) {
          nfa2[node].forEach(function(_ref) {
            var term = _ref.term, to = _ref.to;
            if (!term)
              return;
            var set;
            for (var i2 = 0; i2 < out.length; i2++) {
              if (out[i2][0] == term)
                set = out[i2][1];
            }
            nullFrom(nfa2, to).forEach(function(node2) {
              if (!set)
                out.push([term, set = []]);
              if (set.indexOf(node2) == -1)
                set.push(node2);
            });
          });
        });
        var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
        for (var i = 0; i < out.length; i++) {
          var _states = out[i][1].sort(cmp);
          state.next.push({
            type: out[i][0],
            next: labeled[_states.join(",")] || explore(_states)
          });
        }
        return state;
      }
    }
    function checkForDeadEnds(match, stream) {
      for (var i = 0, work = [match]; i < work.length; i++) {
        var state = work[i], dead = !state.validEnd, nodes = [];
        for (var j = 0; j < state.next.length; j++) {
          var _state$next$j = state.next[j], type = _state$next$j.type, next = _state$next$j.next;
          nodes.push(type.name);
          if (dead && !(type.isText || type.hasRequiredAttrs()))
            dead = false;
          if (work.indexOf(next) == -1)
            work.push(next);
        }
        if (dead)
          stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
      }
    }
    function defaultAttrs(attrs) {
      var defaults = /* @__PURE__ */ Object.create(null);
      for (var attrName in attrs) {
        var attr = attrs[attrName];
        if (!attr.hasDefault)
          return null;
        defaults[attrName] = attr["default"];
      }
      return defaults;
    }
    function _computeAttrs(attrs, value) {
      var built = /* @__PURE__ */ Object.create(null);
      for (var name in attrs) {
        var given = value && value[name];
        if (given === void 0) {
          var attr = attrs[name];
          if (attr.hasDefault)
            given = attr["default"];
          else
            throw new RangeError("No value supplied for attribute " + name);
        }
        built[name] = given;
      }
      return built;
    }
    function initAttrs(attrs) {
      var result = /* @__PURE__ */ Object.create(null);
      if (attrs)
        for (var name in attrs) {
          result[name] = new Attribute(attrs[name]);
        }
      return result;
    }
    var NodeType = function() {
      function NodeType2(name, schema, spec) {
        _classCallCheck(this, NodeType2);
        this.name = name;
        this.schema = schema;
        this.spec = spec;
        this.markSet = null;
        this.groups = spec.group ? spec.group.split(" ") : [];
        this.attrs = initAttrs(spec.attrs);
        this.defaultAttrs = defaultAttrs(this.attrs);
        this.contentMatch = null;
        this.inlineContent = null;
        this.isBlock = !(spec.inline || name == "text");
        this.isText = name == "text";
      }
      _createClass(NodeType2, [{
        key: "isInline",
        get: function get() {
          return !this.isBlock;
        }
      }, {
        key: "isTextblock",
        get: function get() {
          return this.isBlock && this.inlineContent;
        }
      }, {
        key: "isLeaf",
        get: function get() {
          return this.contentMatch == ContentMatch.empty;
        }
      }, {
        key: "isAtom",
        get: function get() {
          return this.isLeaf || !!this.spec.atom;
        }
      }, {
        key: "whitespace",
        get: function get() {
          return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
        }
      }, {
        key: "hasRequiredAttrs",
        value: function hasRequiredAttrs() {
          for (var n in this.attrs) {
            if (this.attrs[n].isRequired)
              return true;
          }
          return false;
        }
      }, {
        key: "compatibleContent",
        value: function compatibleContent(other) {
          return this == other || this.contentMatch.compatible(other.contentMatch);
        }
      }, {
        key: "computeAttrs",
        value: function computeAttrs(attrs) {
          if (!attrs && this.defaultAttrs)
            return this.defaultAttrs;
          else
            return _computeAttrs(this.attrs, attrs);
        }
      }, {
        key: "create",
        value: function create() {
          var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var content = arguments.length > 1 ? arguments[1] : void 0;
          var marks = arguments.length > 2 ? arguments[2] : void 0;
          if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
          return new Node2(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
        }
      }, {
        key: "createChecked",
        value: function createChecked() {
          var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var content = arguments.length > 1 ? arguments[1] : void 0;
          var marks = arguments.length > 2 ? arguments[2] : void 0;
          content = Fragment.from(content);
          if (!this.validContent(content))
            throw new RangeError("Invalid content for node " + this.name);
          return new Node2(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
        }
      }, {
        key: "createAndFill",
        value: function createAndFill() {
          var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          var content = arguments.length > 1 ? arguments[1] : void 0;
          var marks = arguments.length > 2 ? arguments[2] : void 0;
          attrs = this.computeAttrs(attrs);
          content = Fragment.from(content);
          if (content.size) {
            var before = this.contentMatch.fillBefore(content);
            if (!before)
              return null;
            content = before.append(content);
          }
          var matched = this.contentMatch.matchFragment(content);
          var after = matched && matched.fillBefore(Fragment.empty, true);
          if (!after)
            return null;
          return new Node2(this, attrs, content.append(after), Mark.setFrom(marks));
        }
      }, {
        key: "validContent",
        value: function validContent(content) {
          var result = this.contentMatch.matchFragment(content);
          if (!result || !result.validEnd)
            return false;
          for (var i = 0; i < content.childCount; i++) {
            if (!this.allowsMarks(content.child(i).marks))
              return false;
          }
          return true;
        }
      }, {
        key: "allowsMarkType",
        value: function allowsMarkType(markType) {
          return this.markSet == null || this.markSet.indexOf(markType) > -1;
        }
      }, {
        key: "allowsMarks",
        value: function allowsMarks(marks) {
          if (this.markSet == null)
            return true;
          for (var i = 0; i < marks.length; i++) {
            if (!this.allowsMarkType(marks[i].type))
              return false;
          }
          return true;
        }
      }, {
        key: "allowedMarks",
        value: function allowedMarks(marks) {
          if (this.markSet == null)
            return marks;
          var copy2;
          for (var i = 0; i < marks.length; i++) {
            if (!this.allowsMarkType(marks[i].type)) {
              if (!copy2)
                copy2 = marks.slice(0, i);
            } else if (copy2) {
              copy2.push(marks[i]);
            }
          }
          return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
        }
      }], [{
        key: "compile",
        value: function compile(nodes, schema) {
          var result = /* @__PURE__ */ Object.create(null);
          nodes.forEach(function(name, spec) {
            return result[name] = new NodeType2(name, schema, spec);
          });
          var topType = schema.spec.topNode || "doc";
          if (!result[topType])
            throw new RangeError("Schema is missing its top node type ('" + topType + "')");
          if (!result.text)
            throw new RangeError("Every schema needs a 'text' type");
          for (var _ in result.text.attrs) {
            throw new RangeError("The text node type should not have attributes");
          }
          return result;
        }
      }]);
      return NodeType2;
    }();
    var Attribute = function() {
      function Attribute2(options) {
        _classCallCheck(this, Attribute2);
        this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
        this["default"] = options["default"];
      }
      _createClass(Attribute2, [{
        key: "isRequired",
        get: function get() {
          return !this.hasDefault;
        }
      }]);
      return Attribute2;
    }();
    var MarkType = function() {
      function MarkType2(name, rank, schema, spec) {
        _classCallCheck(this, MarkType2);
        this.name = name;
        this.rank = rank;
        this.schema = schema;
        this.spec = spec;
        this.attrs = initAttrs(spec.attrs);
        this.excluded = null;
        var defaults = defaultAttrs(this.attrs);
        this.instance = defaults ? new Mark(this, defaults) : null;
      }
      _createClass(MarkType2, [{
        key: "create",
        value: function create() {
          var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          if (!attrs && this.instance)
            return this.instance;
          return new Mark(this, _computeAttrs(this.attrs, attrs));
        }
      }, {
        key: "removeFromSet",
        value: function removeFromSet(set) {
          for (var i = 0; i < set.length; i++) {
            if (set[i].type == this) {
              set = set.slice(0, i).concat(set.slice(i + 1));
              i--;
            }
          }
          return set;
        }
      }, {
        key: "isInSet",
        value: function isInSet(set) {
          for (var i = 0; i < set.length; i++) {
            if (set[i].type == this)
              return set[i];
          }
        }
      }, {
        key: "excludes",
        value: function excludes(other) {
          return this.excluded.indexOf(other) > -1;
        }
      }], [{
        key: "compile",
        value: function compile(marks, schema) {
          var result = /* @__PURE__ */ Object.create(null), rank = 0;
          marks.forEach(function(name, spec) {
            return result[name] = new MarkType2(name, rank++, schema, spec);
          });
          return result;
        }
      }]);
      return MarkType2;
    }();
    var Schema = function() {
      function Schema2(spec) {
        _classCallCheck(this, Schema2);
        this.cached = /* @__PURE__ */ Object.create(null);
        this.spec = {
          nodes: OrderedMap__default["default"].from(spec.nodes),
          marks: OrderedMap__default["default"].from(spec.marks || {}),
          topNode: spec.topNode
        };
        this.nodes = NodeType.compile(this.spec.nodes, this);
        this.marks = MarkType.compile(this.spec.marks, this);
        var contentExprCache = /* @__PURE__ */ Object.create(null);
        for (var prop in this.nodes) {
          if (prop in this.marks)
            throw new RangeError(prop + " can not be both a node and a mark");
          var type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
          type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
          type.inlineContent = type.contentMatch.inlineContent;
          type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
        }
        for (var _prop in this.marks) {
          var _type2 = this.marks[_prop], excl = _type2.spec.excludes;
          _type2.excluded = excl == null ? [_type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
        }
        this.nodeFromJSON = this.nodeFromJSON.bind(this);
        this.markFromJSON = this.markFromJSON.bind(this);
        this.topNodeType = this.nodes[this.spec.topNode || "doc"];
        this.cached.wrappings = /* @__PURE__ */ Object.create(null);
      }
      _createClass(Schema2, [{
        key: "node",
        value: function node(type) {
          var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var content = arguments.length > 2 ? arguments[2] : void 0;
          var marks = arguments.length > 3 ? arguments[3] : void 0;
          if (typeof type == "string")
            type = this.nodeType(type);
          else if (!(type instanceof NodeType))
            throw new RangeError("Invalid node type: " + type);
          else if (type.schema != this)
            throw new RangeError("Node type from different schema used (" + type.name + ")");
          return type.createChecked(attrs, content, marks);
        }
      }, {
        key: "text",
        value: function text(_text, marks) {
          var type = this.nodes.text;
          return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));
        }
      }, {
        key: "mark",
        value: function mark(type, attrs) {
          if (typeof type == "string")
            type = this.marks[type];
          return type.create(attrs);
        }
      }, {
        key: "nodeFromJSON",
        value: function nodeFromJSON(json) {
          return Node2.fromJSON(this, json);
        }
      }, {
        key: "markFromJSON",
        value: function markFromJSON(json) {
          return Mark.fromJSON(this, json);
        }
      }, {
        key: "nodeType",
        value: function nodeType(name) {
          var found2 = this.nodes[name];
          if (!found2)
            throw new RangeError("Unknown node type: " + name);
          return found2;
        }
      }]);
      return Schema2;
    }();
    function gatherMarks(schema, marks) {
      var found2 = [];
      for (var i = 0; i < marks.length; i++) {
        var name = marks[i], mark = schema.marks[name], ok = mark;
        if (mark) {
          found2.push(mark);
        } else {
          for (var prop in schema.marks) {
            var _mark = schema.marks[prop];
            if (name == "_" || _mark.spec.group && _mark.spec.group.split(" ").indexOf(name) > -1)
              found2.push(ok = _mark);
          }
        }
        if (!ok)
          throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
      }
      return found2;
    }
    var DOMParser = function() {
      function DOMParser2(schema, rules) {
        var _this2 = this;
        _classCallCheck(this, DOMParser2);
        this.schema = schema;
        this.rules = rules;
        this.tags = [];
        this.styles = [];
        rules.forEach(function(rule) {
          if (rule.tag)
            _this2.tags.push(rule);
          else if (rule.style)
            _this2.styles.push(rule);
        });
        this.normalizeLists = !this.tags.some(function(r) {
          if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
            return false;
          var node = schema.nodes[r.node];
          return node.contentMatch.matchType(node);
        });
      }
      _createClass(DOMParser2, [{
        key: "parse",
        value: function parse(dom) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var context = new ParseContext(this, options, false);
          context.addAll(dom, options.from, options.to);
          return context.finish();
        }
      }, {
        key: "parseSlice",
        value: function parseSlice(dom) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var context = new ParseContext(this, options, true);
          context.addAll(dom, options.from, options.to);
          return Slice.maxOpen(context.finish());
        }
      }, {
        key: "matchTag",
        value: function matchTag(dom, context, after) {
          for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
            var rule = this.tags[i];
            if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
              if (rule.getAttrs) {
                var result = rule.getAttrs(dom);
                if (result === false)
                  continue;
                rule.attrs = result || void 0;
              }
              return rule;
            }
          }
        }
      }, {
        key: "matchStyle",
        value: function matchStyle(prop, value, context, after) {
          for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
            var rule = this.styles[i], style = rule.style;
            if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
              continue;
            if (rule.getAttrs) {
              var result = rule.getAttrs(value);
              if (result === false)
                continue;
              rule.attrs = result || void 0;
            }
            return rule;
          }
        }
      }], [{
        key: "schemaRules",
        value: function schemaRules(schema) {
          var result = [];
          function insert(rule) {
            var priority = rule.priority == null ? 50 : rule.priority, i = 0;
            for (; i < result.length; i++) {
              var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
              if (nextPriority < priority)
                break;
            }
            result.splice(i, 0, rule);
          }
          var _loop2 = function _loop22(name2) {
            var rules = schema.marks[name2].spec.parseDOM;
            if (rules)
              rules.forEach(function(rule) {
                insert(rule = copy(rule));
                rule.mark = name2;
              });
          };
          for (var name in schema.marks) {
            _loop2(name);
          }
          var _loop3 = function _loop32(_name2) {
            var rules = schema.nodes[_name2].spec.parseDOM;
            if (rules)
              rules.forEach(function(rule) {
                insert(rule = copy(rule));
                rule.node = _name2;
              });
          };
          for (var _name in schema.nodes) {
            _loop3(_name);
          }
          return result;
        }
      }, {
        key: "fromSchema",
        value: function fromSchema(schema) {
          return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
        }
      }]);
      return DOMParser2;
    }();
    var blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    var ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    var listTags = {
      ol: true,
      ul: true
    };
    var OPT_PRESERVE_WS = 1;
    var OPT_PRESERVE_WS_FULL = 2;
    var OPT_OPEN_LEFT = 4;
    function wsOptionsFor(type, preserveWhitespace, base) {
      if (preserveWhitespace != null)
        return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
      return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
    }
    var NodeContext = function() {
      function NodeContext2(type, attrs, marks, pendingMarks, solid, match, options) {
        _classCallCheck(this, NodeContext2);
        this.type = type;
        this.attrs = attrs;
        this.marks = marks;
        this.pendingMarks = pendingMarks;
        this.solid = solid;
        this.options = options;
        this.content = [];
        this.activeMarks = Mark.none;
        this.stashMarks = [];
        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
      }
      _createClass(NodeContext2, [{
        key: "findWrapping",
        value: function findWrapping(node) {
          if (!this.match) {
            if (!this.type)
              return [];
            var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
            if (fill) {
              this.match = this.type.contentMatch.matchFragment(fill);
            } else {
              var start = this.type.contentMatch, wrap;
              if (wrap = start.findWrapping(node.type)) {
                this.match = start;
                return wrap;
              } else {
                return null;
              }
            }
          }
          return this.match.findWrapping(node.type);
        }
      }, {
        key: "finish",
        value: function finish(openEnd) {
          if (!(this.options & OPT_PRESERVE_WS)) {
            var last = this.content[this.content.length - 1], m;
            if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
              var text = last;
              if (last.text.length == m[0].length)
                this.content.pop();
              else
                this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
            }
          }
          var content = Fragment.from(this.content);
          if (!openEnd && this.match)
            content = content.append(this.match.fillBefore(Fragment.empty, true));
          return this.type ? this.type.create(this.attrs, content, this.marks) : content;
        }
      }, {
        key: "popFromStashMark",
        value: function popFromStashMark(mark) {
          for (var i = this.stashMarks.length - 1; i >= 0; i--) {
            if (mark.eq(this.stashMarks[i]))
              return this.stashMarks.splice(i, 1)[0];
          }
        }
      }, {
        key: "applyPending",
        value: function applyPending(nextType) {
          for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
            var mark = pending[i];
            if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
              this.activeMarks = mark.addToSet(this.activeMarks);
              this.pendingMarks = mark.removeFromSet(this.pendingMarks);
            }
          }
        }
      }, {
        key: "inlineContext",
        value: function inlineContext(node) {
          if (this.type)
            return this.type.inlineContent;
          if (this.content.length)
            return this.content[0].isInline;
          return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
        }
      }]);
      return NodeContext2;
    }();
    var ParseContext = function() {
      function ParseContext2(parser, options, isOpen) {
        _classCallCheck(this, ParseContext2);
        this.parser = parser;
        this.options = options;
        this.isOpen = isOpen;
        this.open = 0;
        var topNode = options.topNode, topContext;
        var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
        if (topNode)
          topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
        else if (isOpen)
          topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
        else
          topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
        this.nodes = [topContext];
        this.find = options.findPositions;
        this.needsBlock = false;
      }
      _createClass(ParseContext2, [{
        key: "top",
        get: function get() {
          return this.nodes[this.open];
        }
      }, {
        key: "addDOM",
        value: function addDOM(dom) {
          if (dom.nodeType == 3) {
            this.addTextNode(dom);
          } else if (dom.nodeType == 1) {
            var style = dom.getAttribute("style");
            var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;
            if (marks != null)
              for (var i = 0; i < marks.length; i++) {
                this.addPendingMark(marks[i]);
              }
            this.addElement(dom);
            if (marks != null)
              for (var _i4 = 0; _i4 < marks.length; _i4++) {
                this.removePendingMark(marks[_i4], top);
              }
          }
        }
      }, {
        key: "addTextNode",
        value: function addTextNode(dom) {
          var value = dom.nodeValue;
          var top = this.top;
          if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
            if (!(top.options & OPT_PRESERVE_WS)) {
              value = value.replace(/[ \t\r\n\u000c]+/g, " ");
              if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
                var nodeBefore = top.content[top.content.length - 1];
                var domNodeBefore = dom.previousSibling;
                if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
                  value = value.slice(1);
              }
            } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
              value = value.replace(/\r?\n|\r/g, " ");
            } else {
              value = value.replace(/\r\n?/g, "\n");
            }
            if (value)
              this.insertNode(this.parser.schema.text(value));
            this.findInText(dom);
          } else {
            this.findInside(dom);
          }
        }
      }, {
        key: "addElement",
        value: function addElement(dom, matchAfter) {
          var name = dom.nodeName.toLowerCase(), ruleID;
          if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
            normalizeList(dom);
          var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
          if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
            this.findInside(dom);
            this.ignoreFallback(dom);
          } else if (!rule || rule.skip || rule.closeParent) {
            if (rule && rule.closeParent)
              this.open = Math.max(0, this.open - 1);
            else if (rule && rule.skip.nodeType)
              dom = rule.skip;
            var sync, top = this.top, oldNeedsBlock = this.needsBlock;
            if (blockTags.hasOwnProperty(name)) {
              sync = true;
              if (!top.type)
                this.needsBlock = true;
            } else if (!dom.firstChild) {
              this.leafFallback(dom);
              return;
            }
            this.addAll(dom);
            if (sync)
              this.sync(top);
            this.needsBlock = oldNeedsBlock;
          } else {
            this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
          }
        }
      }, {
        key: "leafFallback",
        value: function leafFallback(dom) {
          if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
            this.addTextNode(dom.ownerDocument.createTextNode("\n"));
        }
      }, {
        key: "ignoreFallback",
        value: function ignoreFallback(dom) {
          if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
            this.findPlace(this.parser.schema.text("-"));
        }
      }, {
        key: "readStyles",
        value: function readStyles(styles) {
          var marks = Mark.none;
          style:
            for (var i = 0; i < styles.length; i += 2) {
              for (var after = void 0; ; ) {
                var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
                if (!rule)
                  continue style;
                if (rule.ignore)
                  return null;
                marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
                if (rule.consuming === false)
                  after = rule;
                else
                  break;
              }
            }
          return marks;
        }
      }, {
        key: "addElementByRule",
        value: function addElementByRule(dom, rule, continueAfter) {
          var _this3 = this;
          var sync, nodeType, mark;
          if (rule.node) {
            nodeType = this.parser.schema.nodes[rule.node];
            if (!nodeType.isLeaf) {
              sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
            } else if (!this.insertNode(nodeType.create(rule.attrs))) {
              this.leafFallback(dom);
            }
          } else {
            var markType = this.parser.schema.marks[rule.mark];
            mark = markType.create(rule.attrs);
            this.addPendingMark(mark);
          }
          var startIn = this.top;
          if (nodeType && nodeType.isLeaf) {
            this.findInside(dom);
          } else if (continueAfter) {
            this.addElement(dom, continueAfter);
          } else if (rule.getContent) {
            this.findInside(dom);
            rule.getContent(dom, this.parser.schema).forEach(function(node) {
              return _this3.insertNode(node);
            });
          } else {
            var contentDOM = dom;
            if (typeof rule.contentElement == "string")
              contentDOM = dom.querySelector(rule.contentElement);
            else if (typeof rule.contentElement == "function")
              contentDOM = rule.contentElement(dom);
            else if (rule.contentElement)
              contentDOM = rule.contentElement;
            this.findAround(dom, contentDOM, true);
            this.addAll(contentDOM);
          }
          if (sync && this.sync(startIn))
            this.open--;
          if (mark)
            this.removePendingMark(mark, startIn);
        }
      }, {
        key: "addAll",
        value: function addAll(parent, startIndex, endIndex) {
          var index = startIndex || 0;
          for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
            this.findAtPoint(parent, index);
            this.addDOM(dom);
          }
          this.findAtPoint(parent, index);
        }
      }, {
        key: "findPlace",
        value: function findPlace(node) {
          var route, sync;
          for (var depth = this.open; depth >= 0; depth--) {
            var cx = this.nodes[depth];
            var _found2 = cx.findWrapping(node);
            if (_found2 && (!route || route.length > _found2.length)) {
              route = _found2;
              sync = cx;
              if (!_found2.length)
                break;
            }
            if (cx.solid)
              break;
          }
          if (!route)
            return false;
          this.sync(sync);
          for (var i = 0; i < route.length; i++) {
            this.enterInner(route[i], null, false);
          }
          return true;
        }
      }, {
        key: "insertNode",
        value: function insertNode(node) {
          if (node.isInline && this.needsBlock && !this.top.type) {
            var block = this.textblockFromContext();
            if (block)
              this.enterInner(block);
          }
          if (this.findPlace(node)) {
            this.closeExtra();
            var top = this.top;
            top.applyPending(node.type);
            if (top.match)
              top.match = top.match.matchType(node.type);
            var marks = top.activeMarks;
            for (var i = 0; i < node.marks.length; i++) {
              if (!top.type || top.type.allowsMarkType(node.marks[i].type))
                marks = node.marks[i].addToSet(marks);
            }
            top.content.push(node.mark(marks));
            return true;
          }
          return false;
        }
      }, {
        key: "enter",
        value: function enter(type, attrs, preserveWS) {
          var ok = this.findPlace(type.create(attrs));
          if (ok)
            this.enterInner(type, attrs, true, preserveWS);
          return ok;
        }
      }, {
        key: "enterInner",
        value: function enterInner(type) {
          var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var solid = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var preserveWS = arguments.length > 3 ? arguments[3] : void 0;
          this.closeExtra();
          var top = this.top;
          top.applyPending(type);
          top.match = top.match && top.match.matchType(type);
          var options = wsOptionsFor(type, preserveWS, top.options);
          if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
            options |= OPT_OPEN_LEFT;
          this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
          this.open++;
        }
      }, {
        key: "closeExtra",
        value: function closeExtra() {
          var openEnd = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
          var i = this.nodes.length - 1;
          if (i > this.open) {
            for (; i > this.open; i--) {
              this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
            }
            this.nodes.length = this.open + 1;
          }
        }
      }, {
        key: "finish",
        value: function finish() {
          this.open = 0;
          this.closeExtra(this.isOpen);
          return this.nodes[0].finish(this.isOpen || this.options.topOpen);
        }
      }, {
        key: "sync",
        value: function sync(to) {
          for (var i = this.open; i >= 0; i--) {
            if (this.nodes[i] == to) {
              this.open = i;
              return true;
            }
          }
          return false;
        }
      }, {
        key: "currentPos",
        get: function get() {
          this.closeExtra();
          var pos = 0;
          for (var i = this.open; i >= 0; i--) {
            var content = this.nodes[i].content;
            for (var j = content.length - 1; j >= 0; j--) {
              pos += content[j].nodeSize;
            }
            if (i)
              pos++;
          }
          return pos;
        }
      }, {
        key: "findAtPoint",
        value: function findAtPoint(parent, offset) {
          if (this.find)
            for (var i = 0; i < this.find.length; i++) {
              if (this.find[i].node == parent && this.find[i].offset == offset)
                this.find[i].pos = this.currentPos;
            }
        }
      }, {
        key: "findInside",
        value: function findInside(parent) {
          if (this.find)
            for (var i = 0; i < this.find.length; i++) {
              if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
                this.find[i].pos = this.currentPos;
            }
        }
      }, {
        key: "findAround",
        value: function findAround(parent, content, before) {
          if (parent != content && this.find)
            for (var i = 0; i < this.find.length; i++) {
              if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
                var pos = content.compareDocumentPosition(this.find[i].node);
                if (pos & (before ? 2 : 4))
                  this.find[i].pos = this.currentPos;
              }
            }
        }
      }, {
        key: "findInText",
        value: function findInText(textNode) {
          if (this.find)
            for (var i = 0; i < this.find.length; i++) {
              if (this.find[i].node == textNode)
                this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
            }
        }
      }, {
        key: "matchesContext",
        value: function matchesContext(context) {
          var _this4 = this;
          if (context.indexOf("|") > -1)
            return context.split(/\s*\|\s*/).some(this.matchesContext, this);
          var parts = context.split("/");
          var option = this.options.context;
          var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
          var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
          var match = function match2(i, depth) {
            for (; i >= 0; i--) {
              var part = parts[i];
              if (part == "") {
                if (i == parts.length - 1 || i == 0)
                  continue;
                for (; depth >= minDepth; depth--) {
                  if (match2(i - 1, depth))
                    return true;
                }
                return false;
              } else {
                var next = depth > 0 || depth == 0 && useRoot ? _this4.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
                if (!next || next.name != part && next.groups.indexOf(part) == -1)
                  return false;
                depth--;
              }
            }
            return true;
          };
          return match(parts.length - 1, this.open);
        }
      }, {
        key: "textblockFromContext",
        value: function textblockFromContext() {
          var $context = this.options.context;
          if ($context)
            for (var d = $context.depth; d >= 0; d--) {
              var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
              if (deflt && deflt.isTextblock && deflt.defaultAttrs)
                return deflt;
            }
          for (var name in this.parser.schema.nodes) {
            var type = this.parser.schema.nodes[name];
            if (type.isTextblock && type.defaultAttrs)
              return type;
          }
        }
      }, {
        key: "addPendingMark",
        value: function addPendingMark(mark) {
          var found2 = findSameMarkInSet(mark, this.top.pendingMarks);
          if (found2)
            this.top.stashMarks.push(found2);
          this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
        }
      }, {
        key: "removePendingMark",
        value: function removePendingMark(mark, upto) {
          for (var depth = this.open; depth >= 0; depth--) {
            var level = this.nodes[depth];
            var _found3 = level.pendingMarks.lastIndexOf(mark);
            if (_found3 > -1) {
              level.pendingMarks = mark.removeFromSet(level.pendingMarks);
            } else {
              level.activeMarks = mark.removeFromSet(level.activeMarks);
              var stashMark = level.popFromStashMark(mark);
              if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
                level.activeMarks = stashMark.addToSet(level.activeMarks);
            }
            if (level == upto)
              break;
          }
        }
      }]);
      return ParseContext2;
    }();
    function normalizeList(dom) {
      for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
        var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
        if (name && listTags.hasOwnProperty(name) && prevItem) {
          prevItem.appendChild(child);
          child = prevItem;
        } else if (name == "li") {
          prevItem = child;
        } else if (name) {
          prevItem = null;
        }
      }
    }
    function matches(dom, selector) {
      return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
    }
    function parseStyles(style) {
      var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
      while (m = re.exec(style)) {
        result.push(m[1], m[2].trim());
      }
      return result;
    }
    function copy(obj) {
      var copy2 = {};
      for (var prop in obj) {
        copy2[prop] = obj[prop];
      }
      return copy2;
    }
    function markMayApply(markType, nodeType) {
      var nodes = nodeType.schema.nodes;
      var _loop4 = function _loop42(name2) {
        var parent = nodes[name2];
        if (!parent.allowsMarkType(markType))
          return "continue";
        var seen = [], scan = function scan2(match) {
          seen.push(match);
          for (var i = 0; i < match.edgeCount; i++) {
            var _match$edge = match.edge(i), type = _match$edge.type, next = _match$edge.next;
            if (type == nodeType)
              return true;
            if (seen.indexOf(next) < 0 && scan2(next))
              return true;
          }
        };
        if (scan(parent.contentMatch))
          return {
            v: true
          };
      };
      for (var name in nodes) {
        var _ret = _loop4(name);
        if (_ret === "continue")
          continue;
        if (_typeof(_ret) === "object")
          return _ret.v;
      }
    }
    function findSameMarkInSet(mark, set) {
      for (var i = 0; i < set.length; i++) {
        if (mark.eq(set[i]))
          return set[i];
      }
    }
    var DOMSerializer = function() {
      function DOMSerializer2(nodes, marks) {
        _classCallCheck(this, DOMSerializer2);
        this.nodes = nodes;
        this.marks = marks;
      }
      _createClass(DOMSerializer2, [{
        key: "serializeFragment",
        value: function serializeFragment(fragment) {
          var _this5 = this;
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var target = arguments.length > 2 ? arguments[2] : void 0;
          if (!target)
            target = doc(options).createDocumentFragment();
          var top = target, active = [];
          fragment.forEach(function(node) {
            if (active.length || node.marks.length) {
              var keep = 0, rendered = 0;
              while (keep < active.length && rendered < node.marks.length) {
                var next = node.marks[rendered];
                if (!_this5.marks[next.type.name]) {
                  rendered++;
                  continue;
                }
                if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
                  break;
                keep++;
                rendered++;
              }
              while (keep < active.length) {
                top = active.pop()[1];
              }
              while (rendered < node.marks.length) {
                var add = node.marks[rendered++];
                var markDOM = _this5.serializeMark(add, node.isInline, options);
                if (markDOM) {
                  active.push([add, top]);
                  top.appendChild(markDOM.dom);
                  top = markDOM.contentDOM || markDOM.dom;
                }
              }
            }
            top.appendChild(_this5.serializeNodeInner(node, options));
          });
          return target;
        }
      }, {
        key: "serializeNodeInner",
        value: function serializeNodeInner(node, options) {
          var _DOMSerializer$render = DOMSerializer2.renderSpec(doc(options), this.nodes[node.type.name](node)), dom = _DOMSerializer$render.dom, contentDOM = _DOMSerializer$render.contentDOM;
          if (contentDOM) {
            if (node.isLeaf)
              throw new RangeError("Content hole not allowed in a leaf node spec");
            this.serializeFragment(node.content, options, contentDOM);
          }
          return dom;
        }
      }, {
        key: "serializeNode",
        value: function serializeNode(node) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var dom = this.serializeNodeInner(node, options);
          for (var i = node.marks.length - 1; i >= 0; i--) {
            var wrap = this.serializeMark(node.marks[i], node.isInline, options);
            if (wrap) {
              (wrap.contentDOM || wrap.dom).appendChild(dom);
              dom = wrap.dom;
            }
          }
          return dom;
        }
      }, {
        key: "serializeMark",
        value: function serializeMark(mark, inline) {
          var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          var toDOM = this.marks[mark.type.name];
          return toDOM && DOMSerializer2.renderSpec(doc(options), toDOM(mark, inline));
        }
      }], [{
        key: "renderSpec",
        value: function renderSpec(doc2, structure) {
          var xmlNS = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (typeof structure == "string")
            return {
              dom: doc2.createTextNode(structure)
            };
          if (structure.nodeType != null)
            return {
              dom: structure
            };
          if (structure.dom && structure.dom.nodeType != null)
            return structure;
          var tagName = structure[0], space = tagName.indexOf(" ");
          if (space > 0) {
            xmlNS = tagName.slice(0, space);
            tagName = tagName.slice(space + 1);
          }
          var contentDOM;
          var dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
          var attrs = structure[1], start = 1;
          if (attrs && _typeof(attrs) == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
            start = 2;
            for (var name in attrs) {
              if (attrs[name] != null) {
                var _space = name.indexOf(" ");
                if (_space > 0)
                  dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);
                else
                  dom.setAttribute(name, attrs[name]);
              }
            }
          }
          for (var i = start; i < structure.length; i++) {
            var child = structure[i];
            if (child === 0) {
              if (i < structure.length - 1 || i > start)
                throw new RangeError("Content hole must be the only child of its parent node");
              return {
                dom,
                contentDOM: dom
              };
            } else {
              var _DOMSerializer$render2 = DOMSerializer2.renderSpec(doc2, child, xmlNS), inner = _DOMSerializer$render2.dom, innerContent = _DOMSerializer$render2.contentDOM;
              dom.appendChild(inner);
              if (innerContent) {
                if (contentDOM)
                  throw new RangeError("Multiple content holes");
                contentDOM = innerContent;
              }
            }
          }
          return {
            dom,
            contentDOM
          };
        }
      }, {
        key: "fromSchema",
        value: function fromSchema(schema) {
          return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer2(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
        }
      }, {
        key: "nodesFromSchema",
        value: function nodesFromSchema(schema) {
          var result = gatherToDOM(schema.nodes);
          if (!result.text)
            result.text = function(node) {
              return node.text;
            };
          return result;
        }
      }, {
        key: "marksFromSchema",
        value: function marksFromSchema(schema) {
          return gatherToDOM(schema.marks);
        }
      }]);
      return DOMSerializer2;
    }();
    function gatherToDOM(obj) {
      var result = {};
      for (var name in obj) {
        var toDOM = obj[name].spec.toDOM;
        if (toDOM)
          result[name] = toDOM;
      }
      return result;
    }
    function doc(options) {
      return options.document || window.document;
    }
    exports.ContentMatch = ContentMatch;
    exports.DOMParser = DOMParser;
    exports.DOMSerializer = DOMSerializer;
    exports.Fragment = Fragment;
    exports.Mark = Mark;
    exports.MarkType = MarkType;
    exports.Node = Node2;
    exports.NodeRange = NodeRange;
    exports.NodeType = NodeType;
    exports.ReplaceError = ReplaceError;
    exports.ResolvedPos = ResolvedPos;
    exports.Schema = Schema;
    exports.Slice = Slice;
  }
});

// node_modules/prosemirror-transform/dist/index.cjs
var require_dist3 = __commonJS({
  "node_modules/prosemirror-transform/dist/index.cjs"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var prosemirrorModel = require_dist2();
    var lower16 = 65535;
    var factor16 = Math.pow(2, 16);
    function makeRecover(index, offset) {
      return index + offset * factor16;
    }
    function recoverIndex(value) {
      return value & lower16;
    }
    function recoverOffset(value) {
      return (value - (value & lower16)) / factor16;
    }
    var DEL_BEFORE = 1;
    var DEL_AFTER = 2;
    var DEL_ACROSS = 4;
    var DEL_SIDE = 8;
    var MapResult = function() {
      function MapResult2(pos, delInfo, recover) {
        _classCallCheck(this, MapResult2);
        this.pos = pos;
        this.delInfo = delInfo;
        this.recover = recover;
      }
      _createClass(MapResult2, [{
        key: "deleted",
        get: function get() {
          return (this.delInfo & DEL_SIDE) > 0;
        }
      }, {
        key: "deletedBefore",
        get: function get() {
          return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
        }
      }, {
        key: "deletedAfter",
        get: function get() {
          return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
        }
      }, {
        key: "deletedAcross",
        get: function get() {
          return (this.delInfo & DEL_ACROSS) > 0;
        }
      }]);
      return MapResult2;
    }();
    var StepMap = function() {
      function StepMap2(ranges) {
        var inverted = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        _classCallCheck(this, StepMap2);
        this.ranges = ranges;
        this.inverted = inverted;
        if (!ranges.length && StepMap2.empty)
          return StepMap2.empty;
      }
      _createClass(StepMap2, [{
        key: "recover",
        value: function recover(value) {
          var diff = 0, index = recoverIndex(value);
          if (!this.inverted)
            for (var i = 0; i < index; i++) {
              diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
            }
          return this.ranges[index * 3] + diff + recoverOffset(value);
        }
      }, {
        key: "mapResult",
        value: function mapResult(pos) {
          var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(pos, assoc, false);
        }
      }, {
        key: "map",
        value: function map(pos) {
          var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(pos, assoc, true);
        }
      }, {
        key: "_map",
        value: function _map(pos, assoc, simple) {
          var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
          for (var i = 0; i < this.ranges.length; i += 3) {
            var start = this.ranges[i] - (this.inverted ? diff : 0);
            if (start > pos)
              break;
            var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
            if (pos <= end) {
              var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
              var result = start + diff + (side < 0 ? 0 : newSize);
              if (simple)
                return result;
              var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
              var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
              if (assoc < 0 ? pos != start : pos != end)
                del |= DEL_SIDE;
              return new MapResult(result, del, recover);
            }
            diff += newSize - oldSize;
          }
          return simple ? pos + diff : new MapResult(pos + diff, 0, null);
        }
      }, {
        key: "touches",
        value: function touches(pos, recover) {
          var diff = 0, index = recoverIndex(recover);
          var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
          for (var i = 0; i < this.ranges.length; i += 3) {
            var start = this.ranges[i] - (this.inverted ? diff : 0);
            if (start > pos)
              break;
            var oldSize = this.ranges[i + oldIndex], end = start + oldSize;
            if (pos <= end && i == index * 3)
              return true;
            diff += this.ranges[i + newIndex] - oldSize;
          }
          return false;
        }
      }, {
        key: "forEach",
        value: function forEach(f) {
          var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
          for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
            var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
            var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
            diff += newSize - oldSize;
          }
        }
      }, {
        key: "invert",
        value: function invert() {
          return new StepMap2(this.ranges, !this.inverted);
        }
      }, {
        key: "toString",
        value: function toString() {
          return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
        }
      }], [{
        key: "offset",
        value: function offset(n) {
          return n == 0 ? StepMap2.empty : new StepMap2(n < 0 ? [0, -n, 0] : [0, 0, n]);
        }
      }]);
      return StepMap2;
    }();
    StepMap.empty = new StepMap([]);
    var Mapping = function() {
      function Mapping2() {
        var maps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var mirror = arguments.length > 1 ? arguments[1] : void 0;
        var from = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var to = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : maps.length;
        _classCallCheck(this, Mapping2);
        this.maps = maps;
        this.mirror = mirror;
        this.from = from;
        this.to = to;
      }
      _createClass(Mapping2, [{
        key: "slice",
        value: function slice() {
          var from = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.maps.length;
          return new Mapping2(this.maps, this.mirror, from, to);
        }
      }, {
        key: "copy",
        value: function copy() {
          return new Mapping2(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
        }
      }, {
        key: "appendMap",
        value: function appendMap(map, mirrors) {
          this.to = this.maps.push(map);
          if (mirrors != null)
            this.setMirror(this.maps.length - 1, mirrors);
        }
      }, {
        key: "appendMapping",
        value: function appendMapping(mapping) {
          for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
            var mirr = mapping.getMirror(i);
            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
          }
        }
      }, {
        key: "getMirror",
        value: function getMirror(n) {
          if (this.mirror)
            for (var i = 0; i < this.mirror.length; i++) {
              if (this.mirror[i] == n)
                return this.mirror[i + (i % 2 ? -1 : 1)];
            }
        }
      }, {
        key: "setMirror",
        value: function setMirror(n, m) {
          if (!this.mirror)
            this.mirror = [];
          this.mirror.push(n, m);
        }
      }, {
        key: "appendMappingInverted",
        value: function appendMappingInverted(mapping) {
          for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
            var mirr = mapping.getMirror(i);
            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
          }
        }
      }, {
        key: "invert",
        value: function invert() {
          var inverse = new Mapping2();
          inverse.appendMappingInverted(this);
          return inverse;
        }
      }, {
        key: "map",
        value: function map(pos) {
          var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          if (this.mirror)
            return this._map(pos, assoc, true);
          for (var i = this.from; i < this.to; i++) {
            pos = this.maps[i].map(pos, assoc);
          }
          return pos;
        }
      }, {
        key: "mapResult",
        value: function mapResult(pos) {
          var assoc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(pos, assoc, false);
        }
      }, {
        key: "_map",
        value: function _map(pos, assoc, simple) {
          var delInfo = 0;
          for (var i = this.from; i < this.to; i++) {
            var map = this.maps[i], result = map.mapResult(pos, assoc);
            if (result.recover != null) {
              var corr = this.getMirror(i);
              if (corr != null && corr > i && corr < this.to) {
                i = corr;
                pos = this.maps[corr].recover(result.recover);
                continue;
              }
            }
            delInfo |= result.delInfo;
            pos = result.pos;
          }
          return simple ? pos : new MapResult(pos, delInfo, null);
        }
      }]);
      return Mapping2;
    }();
    var stepsByID = /* @__PURE__ */ Object.create(null);
    var Step = function() {
      function Step2() {
        _classCallCheck(this, Step2);
      }
      _createClass(Step2, [{
        key: "getMap",
        value: function getMap() {
          return StepMap.empty;
        }
      }, {
        key: "merge",
        value: function merge(other) {
          return null;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (!json || !json.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
          var type = stepsByID[json.stepType];
          if (!type)
            throw new RangeError("No step type ".concat(json.stepType, " defined"));
          return type.fromJSON(schema, json);
        }
      }, {
        key: "jsonID",
        value: function jsonID(id, stepClass) {
          if (id in stepsByID)
            throw new RangeError("Duplicate use of step JSON ID " + id);
          stepsByID[id] = stepClass;
          stepClass.prototype.jsonID = id;
          return stepClass;
        }
      }]);
      return Step2;
    }();
    var StepResult = function() {
      function StepResult2(doc, failed) {
        _classCallCheck(this, StepResult2);
        this.doc = doc;
        this.failed = failed;
      }
      _createClass(StepResult2, null, [{
        key: "ok",
        value: function ok(doc) {
          return new StepResult2(doc, null);
        }
      }, {
        key: "fail",
        value: function fail(message) {
          return new StepResult2(null, message);
        }
      }, {
        key: "fromReplace",
        value: function fromReplace(doc, from, to, slice) {
          try {
            return StepResult2.ok(doc.replace(from, to, slice));
          } catch (e) {
            if (e instanceof prosemirrorModel.ReplaceError)
              return StepResult2.fail(e.message);
            throw e;
          }
        }
      }]);
      return StepResult2;
    }();
    function mapFragment(fragment, f, parent) {
      var mapped = [];
      for (var i = 0; i < fragment.childCount; i++) {
        var child = fragment.child(i);
        if (child.content.size)
          child = child.copy(mapFragment(child.content, f, child));
        if (child.isInline)
          child = f(child, parent, i);
        mapped.push(child);
      }
      return prosemirrorModel.Fragment.fromArray(mapped);
    }
    var AddMarkStep = function(_Step) {
      _inherits(AddMarkStep2, _Step);
      var _super = _createSuper(AddMarkStep2);
      function AddMarkStep2(from, to, mark) {
        var _this;
        _classCallCheck(this, AddMarkStep2);
        _this = _super.call(this);
        _this.from = from;
        _this.to = to;
        _this.mark = mark;
        return _this;
      }
      _createClass(AddMarkStep2, [{
        key: "apply",
        value: function apply(doc) {
          var _this2 = this;
          var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
          var parent = $from.node($from.sharedDepth(this.to));
          var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function(node, parent2) {
            if (!node.isAtom || !parent2.type.allowsMarkType(_this2.mark.type))
              return node;
            return node.mark(_this2.mark.addToSet(node.marks));
          }, parent), oldSlice.openStart, oldSlice.openEnd);
          return StepResult.fromReplace(doc, this.from, this.to, slice);
        }
      }, {
        key: "invert",
        value: function invert() {
          return new RemoveMarkStep(this.from, this.to, this.mark);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
          if (from.deleted && to.deleted || from.pos >= to.pos)
            return null;
          return new AddMarkStep2(from.pos, to.pos, this.mark);
        }
      }, {
        key: "merge",
        value: function merge(other) {
          if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
            return new AddMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
          return null;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number")
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
          return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
        }
      }]);
      return AddMarkStep2;
    }(Step);
    Step.jsonID("addMark", AddMarkStep);
    var RemoveMarkStep = function(_Step2) {
      _inherits(RemoveMarkStep2, _Step2);
      var _super2 = _createSuper(RemoveMarkStep2);
      function RemoveMarkStep2(from, to, mark) {
        var _this3;
        _classCallCheck(this, RemoveMarkStep2);
        _this3 = _super2.call(this);
        _this3.from = from;
        _this3.to = to;
        _this3.mark = mark;
        return _this3;
      }
      _createClass(RemoveMarkStep2, [{
        key: "apply",
        value: function apply(doc) {
          var _this4 = this;
          var oldSlice = doc.slice(this.from, this.to);
          var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function(node) {
            return node.mark(_this4.mark.removeFromSet(node.marks));
          }, doc), oldSlice.openStart, oldSlice.openEnd);
          return StepResult.fromReplace(doc, this.from, this.to, slice);
        }
      }, {
        key: "invert",
        value: function invert() {
          return new AddMarkStep(this.from, this.to, this.mark);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
          if (from.deleted && to.deleted || from.pos >= to.pos)
            return null;
          return new RemoveMarkStep2(from.pos, to.pos, this.mark);
        }
      }, {
        key: "merge",
        value: function merge(other) {
          if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
            return new RemoveMarkStep2(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
          return null;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number")
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
          return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
        }
      }]);
      return RemoveMarkStep2;
    }(Step);
    Step.jsonID("removeMark", RemoveMarkStep);
    var AddNodeMarkStep = function(_Step3) {
      _inherits(AddNodeMarkStep2, _Step3);
      var _super3 = _createSuper(AddNodeMarkStep2);
      function AddNodeMarkStep2(pos, mark) {
        var _this5;
        _classCallCheck(this, AddNodeMarkStep2);
        _this5 = _super3.call(this);
        _this5.pos = pos;
        _this5.mark = mark;
        return _this5;
      }
      _createClass(AddNodeMarkStep2, [{
        key: "apply",
        value: function apply(doc) {
          var node = doc.nodeAt(this.pos);
          if (!node)
            return StepResult.fail("No node at mark step's position");
          var updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
          return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          var node = doc.nodeAt(this.pos);
          if (node) {
            var newSet = this.mark.addToSet(node.marks);
            if (newSet.length == node.marks.length) {
              for (var i = 0; i < node.marks.length; i++) {
                if (!node.marks[i].isInSet(newSet))
                  return new AddNodeMarkStep2(this.pos, node.marks[i]);
              }
              return new AddNodeMarkStep2(this.pos, this.mark);
            }
          }
          return new RemoveNodeMarkStep(this.pos, this.mark);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new AddNodeMarkStep2(pos.pos, this.mark);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.pos != "number")
            throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
          return new AddNodeMarkStep2(json.pos, schema.markFromJSON(json.mark));
        }
      }]);
      return AddNodeMarkStep2;
    }(Step);
    Step.jsonID("addNodeMark", AddNodeMarkStep);
    var RemoveNodeMarkStep = function(_Step4) {
      _inherits(RemoveNodeMarkStep2, _Step4);
      var _super4 = _createSuper(RemoveNodeMarkStep2);
      function RemoveNodeMarkStep2(pos, mark) {
        var _this6;
        _classCallCheck(this, RemoveNodeMarkStep2);
        _this6 = _super4.call(this);
        _this6.pos = pos;
        _this6.mark = mark;
        return _this6;
      }
      _createClass(RemoveNodeMarkStep2, [{
        key: "apply",
        value: function apply(doc) {
          var node = doc.nodeAt(this.pos);
          if (!node)
            return StepResult.fail("No node at mark step's position");
          var updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
          return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          var node = doc.nodeAt(this.pos);
          if (!node || !this.mark.isInSet(node.marks))
            return this;
          return new AddNodeMarkStep(this.pos, this.mark);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new RemoveNodeMarkStep2(pos.pos, this.mark);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.pos != "number")
            throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
          return new RemoveNodeMarkStep2(json.pos, schema.markFromJSON(json.mark));
        }
      }]);
      return RemoveNodeMarkStep2;
    }(Step);
    Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
    var ReplaceStep = function(_Step5) {
      _inherits(ReplaceStep2, _Step5);
      var _super5 = _createSuper(ReplaceStep2);
      function ReplaceStep2(from, to, slice) {
        var _this7;
        var structure = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
        _classCallCheck(this, ReplaceStep2);
        _this7 = _super5.call(this);
        _this7.from = from;
        _this7.to = to;
        _this7.slice = slice;
        _this7.structure = structure;
        return _this7;
      }
      _createClass(ReplaceStep2, [{
        key: "apply",
        value: function apply(doc) {
          if (this.structure && contentBetween(doc, this.from, this.to))
            return StepResult.fail("Structure replace would overwrite content");
          return StepResult.fromReplace(doc, this.from, this.to, this.slice);
        }
      }, {
        key: "getMap",
        value: function getMap() {
          return new StepMap([this.from, this.to - this.from, this.slice.size]);
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          return new ReplaceStep2(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
          if (from.deletedAcross && to.deletedAcross)
            return null;
          return new ReplaceStep2(from.pos, Math.max(from.pos, to.pos), this.slice);
        }
      }, {
        key: "merge",
        value: function merge(other) {
          if (!(other instanceof ReplaceStep2) || other.structure || this.structure)
            return null;
          if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
            var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
            return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice, this.structure);
          } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
            var _slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
            return new ReplaceStep2(other.from, this.to, _slice, this.structure);
          } else {
            return null;
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var json = {
            stepType: "replace",
            from: this.from,
            to: this.to
          };
          if (this.slice.size)
            json.slice = this.slice.toJSON();
          if (this.structure)
            json.structure = true;
          return json;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number")
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
          return new ReplaceStep2(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure);
        }
      }]);
      return ReplaceStep2;
    }(Step);
    Step.jsonID("replace", ReplaceStep);
    var ReplaceAroundStep = function(_Step6) {
      _inherits(ReplaceAroundStep2, _Step6);
      var _super6 = _createSuper(ReplaceAroundStep2);
      function ReplaceAroundStep2(from, to, gapFrom, gapTo, slice, insert) {
        var _this8;
        var structure = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
        _classCallCheck(this, ReplaceAroundStep2);
        _this8 = _super6.call(this);
        _this8.from = from;
        _this8.to = to;
        _this8.gapFrom = gapFrom;
        _this8.gapTo = gapTo;
        _this8.slice = slice;
        _this8.insert = insert;
        _this8.structure = structure;
        return _this8;
      }
      _createClass(ReplaceAroundStep2, [{
        key: "apply",
        value: function apply(doc) {
          if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to)))
            return StepResult.fail("Structure gap-replace would overwrite content");
          var gap = doc.slice(this.gapFrom, this.gapTo);
          if (gap.openStart || gap.openEnd)
            return StepResult.fail("Gap is not a flat range");
          var inserted = this.slice.insertAt(this.insert, gap.content);
          if (!inserted)
            return StepResult.fail("Content does not fit in gap");
          return StepResult.fromReplace(doc, this.from, this.to, inserted);
        }
      }, {
        key: "getMap",
        value: function getMap() {
          return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          var gap = this.gapTo - this.gapFrom;
          return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
          var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
          if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)
            return null;
          return new ReplaceAroundStep2(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var json = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
          };
          if (this.slice.size)
            json.slice = this.slice.toJSON();
          if (this.structure)
            json.structure = true;
          return json;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
            throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
          return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
        }
      }]);
      return ReplaceAroundStep2;
    }(Step);
    Step.jsonID("replaceAround", ReplaceAroundStep);
    function contentBetween(doc, from, to) {
      var $from = doc.resolve(from), dist = to - from, depth = $from.depth;
      while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
        depth--;
        dist--;
      }
      if (dist > 0) {
        var next = $from.node(depth).maybeChild($from.indexAfter(depth));
        while (dist > 0) {
          if (!next || next.isLeaf)
            return true;
          next = next.firstChild;
          dist--;
        }
      }
      return false;
    }
    function _addMark(tr, from, to, mark) {
      var removed = [], added = [];
      var removing, adding;
      tr.doc.nodesBetween(from, to, function(node, pos, parent) {
        if (!node.isInline)
          return;
        var marks = node.marks;
        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
          var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
          var newSet = mark.addToSet(marks);
          for (var i = 0; i < marks.length; i++) {
            if (!marks[i].isInSet(newSet)) {
              if (removing && removing.to == start && removing.mark.eq(marks[i]))
                removing.to = end;
              else
                removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
            }
          }
          if (adding && adding.to == start)
            adding.to = end;
          else
            added.push(adding = new AddMarkStep(start, end, mark));
        }
      });
      removed.forEach(function(s) {
        return tr.step(s);
      });
      added.forEach(function(s) {
        return tr.step(s);
      });
    }
    function _removeMark(tr, from, to, mark) {
      var matched = [], step = 0;
      tr.doc.nodesBetween(from, to, function(node, pos) {
        if (!node.isInline)
          return;
        step++;
        var toRemove = null;
        if (mark instanceof prosemirrorModel.MarkType) {
          var set = node.marks, found;
          while (found = mark.isInSet(set)) {
            (toRemove || (toRemove = [])).push(found);
            set = found.removeFromSet(set);
          }
        } else if (mark) {
          if (mark.isInSet(node.marks))
            toRemove = [mark];
        } else {
          toRemove = node.marks;
        }
        if (toRemove && toRemove.length) {
          var end = Math.min(pos + node.nodeSize, to);
          for (var i = 0; i < toRemove.length; i++) {
            var style = toRemove[i], _found = void 0;
            for (var j = 0; j < matched.length; j++) {
              var m = matched[j];
              if (m.step == step - 1 && style.eq(matched[j].style))
                _found = m;
            }
            if (_found) {
              _found.to = end;
              _found.step = step;
            } else {
              matched.push({
                style,
                from: Math.max(pos, from),
                to: end,
                step
              });
            }
          }
        }
      });
      matched.forEach(function(m) {
        return tr.step(new RemoveMarkStep(m.from, m.to, m.style));
      });
    }
    function _clearIncompatible(tr, pos, parentType) {
      var match = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : parentType.contentMatch;
      var node = tr.doc.nodeAt(pos);
      var delSteps = [], cur = pos + 1;
      for (var i = 0; i < node.childCount; i++) {
        var child = node.child(i), end = cur + child.nodeSize;
        var allowed = match.matchType(child.type);
        if (!allowed) {
          delSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));
        } else {
          match = allowed;
          for (var j = 0; j < child.marks.length; j++) {
            if (!parentType.allowsMarkType(child.marks[j].type))
              tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
          }
        }
        cur = end;
      }
      if (!match.validEnd) {
        var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);
        tr.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));
      }
      for (var _i = delSteps.length - 1; _i >= 0; _i--) {
        tr.step(delSteps[_i]);
      }
    }
    function canCut(node, start, end) {
      return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
    }
    function liftTarget(range) {
      var parent = range.parent;
      var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
      for (var depth = range.depth; ; --depth) {
        var node = range.$from.node(depth);
        var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
        if (depth < range.depth && node.canReplace(index, endIndex, content))
          return depth;
        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))
          break;
      }
      return null;
    }
    function _lift(tr, range, target) {
      var $from = range.$from, $to = range.$to, depth = range.depth;
      var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
      var start = gapStart, end = gapEnd;
      var before = prosemirrorModel.Fragment.empty, openStart = 0;
      for (var d = depth, splitting = false; d > target; d--) {
        if (splitting || $from.index(d) > 0) {
          splitting = true;
          before = prosemirrorModel.Fragment.from($from.node(d).copy(before));
          openStart++;
        } else {
          start--;
        }
      }
      var after = prosemirrorModel.Fragment.empty, openEnd = 0;
      for (var _d = depth, _splitting = false; _d > target; _d--) {
        if (_splitting || $to.after(_d + 1) < $to.end(_d)) {
          _splitting = true;
          after = prosemirrorModel.Fragment.from($to.node(_d).copy(after));
          openEnd++;
        } else {
          end++;
        }
      }
      tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirrorModel.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
    }
    function findWrapping(range, nodeType) {
      var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      var innerRange = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : range;
      var around = findWrappingOutside(range, nodeType);
      var inner = around && findWrappingInside(innerRange, nodeType);
      if (!inner)
        return null;
      return around.map(withAttrs).concat({
        type: nodeType,
        attrs
      }).concat(inner.map(withAttrs));
    }
    function withAttrs(type) {
      return {
        type,
        attrs: null
      };
    }
    function findWrappingOutside(range, type) {
      var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;
      var around = parent.contentMatchAt(startIndex).findWrapping(type);
      if (!around)
        return null;
      var outer = around.length ? around[0] : type;
      return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
    }
    function findWrappingInside(range, type) {
      var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;
      var inner = parent.child(startIndex);
      var inside = type.contentMatch.findWrapping(inner.type);
      if (!inside)
        return null;
      var lastType = inside.length ? inside[inside.length - 1] : type;
      var innerMatch = lastType.contentMatch;
      for (var i = startIndex; innerMatch && i < endIndex; i++) {
        innerMatch = innerMatch.matchType(parent.child(i).type);
      }
      if (!innerMatch || !innerMatch.validEnd)
        return null;
      return inside;
    }
    function _wrap2(tr, range, wrappers) {
      var content = prosemirrorModel.Fragment.empty;
      for (var i = wrappers.length - 1; i >= 0; i--) {
        if (content.size) {
          var match = wrappers[i].type.contentMatch.matchFragment(content);
          if (!match || !match.validEnd)
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
      }
      var start = range.start, end = range.end;
      tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
    }
    function _setBlockType(tr, from, to, type, attrs) {
      if (!type.isTextblock)
        throw new RangeError("Type given to setBlockType should be a textblock");
      var mapFrom = tr.steps.length;
      tr.doc.nodesBetween(from, to, function(node, pos) {
        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
          tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
          var mapping = tr.mapping.slice(mapFrom);
          var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
          tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
          return false;
        }
      });
    }
    function canChangeType(doc, pos, type) {
      var $pos = doc.resolve(pos), index = $pos.index();
      return $pos.parent.canReplaceWith(index, index + 1, type);
    }
    function _setNodeMarkup(tr, pos, type, attrs, marks) {
      var node = tr.doc.nodeAt(pos);
      if (!node)
        throw new RangeError("No node at given position");
      if (!type)
        type = node.type;
      var newNode = type.create(attrs, null, marks || node.marks);
      if (node.isLeaf)
        return tr.replaceWith(pos, pos + node.nodeSize, newNode);
      if (!type.validContent(node.content))
        throw new RangeError("Invalid content for node type " + type.name);
      tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true));
    }
    function canSplit(doc, pos) {
      var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var typesAfter = arguments.length > 3 ? arguments[3] : void 0;
      var $pos = doc.resolve(pos), base = $pos.depth - depth;
      var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
      if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
        return false;
      for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
        var node = $pos.node(d), _index = $pos.index(d);
        if (node.type.spec.isolating)
          return false;
        var rest = node.content.cutByIndex(_index, node.childCount);
        var after = typesAfter && typesAfter[i] || node;
        if (after != node)
          rest = rest.replaceChild(0, after.type.create(after.attrs));
        if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest))
          return false;
      }
      var index = $pos.indexAfter(base);
      var baseType = typesAfter && typesAfter[0];
      return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
    }
    function _split(tr, pos) {
      var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var typesAfter = arguments.length > 3 ? arguments[3] : void 0;
      var $pos = tr.doc.resolve(pos), before = prosemirrorModel.Fragment.empty, after = prosemirrorModel.Fragment.empty;
      for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
        before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));
        var typeAfter = typesAfter && typesAfter[i];
        after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
      }
      tr.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth), true));
    }
    function canJoin(doc, pos) {
      var $pos = doc.resolve(pos), index = $pos.index();
      return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
    }
    function joinable(a, b) {
      return !!(a && b && !a.isLeaf && a.canAppend(b));
    }
    function joinPoint(doc, pos) {
      var dir = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
      var $pos = doc.resolve(pos);
      for (var d = $pos.depth; ; d--) {
        var before = void 0, after = void 0, index = $pos.index(d);
        if (d == $pos.depth) {
          before = $pos.nodeBefore;
          after = $pos.nodeAfter;
        } else if (dir > 0) {
          before = $pos.node(d + 1);
          index++;
          after = $pos.node(d).maybeChild(index);
        } else {
          before = $pos.node(d).maybeChild(index - 1);
          after = $pos.node(d + 1);
        }
        if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1))
          return pos;
        if (d == 0)
          break;
        pos = dir < 0 ? $pos.before(d) : $pos.after(d);
      }
    }
    function _join(tr, pos, depth) {
      var step = new ReplaceStep(pos - depth, pos + depth, prosemirrorModel.Slice.empty, true);
      tr.step(step);
    }
    function insertPoint(doc, pos, nodeType) {
      var $pos = doc.resolve(pos);
      if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
        return pos;
      if ($pos.parentOffset == 0)
        for (var d = $pos.depth - 1; d >= 0; d--) {
          var index = $pos.index(d);
          if ($pos.node(d).canReplaceWith(index, index, nodeType))
            return $pos.before(d + 1);
          if (index > 0)
            return null;
        }
      if ($pos.parentOffset == $pos.parent.content.size)
        for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {
          var _index2 = $pos.indexAfter(_d2);
          if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType))
            return $pos.after(_d2 + 1);
          if (_index2 < $pos.node(_d2).childCount)
            return null;
        }
      return null;
    }
    function dropPoint(doc, pos, slice) {
      var $pos = doc.resolve(pos);
      if (!slice.content.size)
        return pos;
      var content = slice.content;
      for (var i = 0; i < slice.openStart; i++) {
        content = content.firstChild.content;
      }
      for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
        for (var d = $pos.depth; d >= 0; d--) {
          var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
          var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
          var parent = $pos.node(d), fits = false;
          if (pass == 1) {
            fits = parent.canReplace(insertPos, insertPos, content);
          } else {
            var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
            fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
          }
          if (fits)
            return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
        }
      }
      return null;
    }
    function replaceStep(doc, from) {
      var to = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : from;
      var slice = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : prosemirrorModel.Slice.empty;
      if (from == to && !slice.size)
        return null;
      var $from = doc.resolve(from), $to = doc.resolve(to);
      if (fitsTrivially($from, $to, slice))
        return new ReplaceStep(from, to, slice);
      return new Fitter($from, $to, slice).fit();
    }
    function fitsTrivially($from, $to, slice) {
      return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
    }
    var Fitter = function() {
      function Fitter2($from, $to, unplaced) {
        _classCallCheck(this, Fitter2);
        this.$from = $from;
        this.$to = $to;
        this.unplaced = unplaced;
        this.frontier = [];
        this.placed = prosemirrorModel.Fragment.empty;
        for (var i = 0; i <= $from.depth; i++) {
          var node = $from.node(i);
          this.frontier.push({
            type: node.type,
            match: node.contentMatchAt($from.indexAfter(i))
          });
        }
        for (var _i2 = $from.depth; _i2 > 0; _i2--) {
          this.placed = prosemirrorModel.Fragment.from($from.node(_i2).copy(this.placed));
        }
      }
      _createClass(Fitter2, [{
        key: "depth",
        get: function get() {
          return this.frontier.length - 1;
        }
      }, {
        key: "fit",
        value: function fit() {
          while (this.unplaced.size) {
            var fit2 = this.findFittable();
            if (fit2)
              this.placeNodes(fit2);
            else
              this.openMore() || this.dropNode();
          }
          var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
          var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
          if (!$to)
            return null;
          var content = this.placed, openStart = $from.depth, openEnd = $to.depth;
          while (openStart && openEnd && content.childCount == 1) {
            content = content.firstChild.content;
            openStart--;
            openEnd--;
          }
          var slice = new prosemirrorModel.Slice(content, openStart, openEnd);
          if (moveInline > -1)
            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
          if (slice.size || $from.pos != this.$to.pos)
            return new ReplaceStep($from.pos, $to.pos, slice);
          return null;
        }
      }, {
        key: "findFittable",
        value: function findFittable() {
          for (var pass = 1; pass <= 2; pass++) {
            for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
              var fragment = void 0, parent = null;
              if (sliceDepth) {
                parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
                fragment = parent.content;
              } else {
                fragment = this.unplaced.content;
              }
              var first = fragment.firstChild;
              for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
                var _this$frontier$fronti = this.frontier[frontierDepth], type = _this$frontier$fronti.type, match = _this$frontier$fronti.match, _wrap = void 0, inject = null;
                if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirrorModel.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type)))
                  return {
                    sliceDepth,
                    frontierDepth,
                    parent,
                    inject
                  };
                else if (pass == 2 && first && (_wrap = match.findWrapping(first.type)))
                  return {
                    sliceDepth,
                    frontierDepth,
                    parent,
                    wrap: _wrap
                  };
                if (parent && match.matchType(parent.type))
                  break;
              }
            }
          }
        }
      }, {
        key: "openMore",
        value: function openMore() {
          var _this$unplaced = this.unplaced, content = _this$unplaced.content, openStart = _this$unplaced.openStart, openEnd = _this$unplaced.openEnd;
          var inner = contentAt(content, openStart);
          if (!inner.childCount || inner.firstChild.isLeaf)
            return false;
          this.unplaced = new prosemirrorModel.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
          return true;
        }
      }, {
        key: "dropNode",
        value: function dropNode() {
          var _this$unplaced2 = this.unplaced, content = _this$unplaced2.content, openStart = _this$unplaced2.openStart, openEnd = _this$unplaced2.openEnd;
          var inner = contentAt(content, openStart);
          if (inner.childCount <= 1 && openStart > 0) {
            var openAtEnd = content.size - openStart <= openStart + inner.size;
            this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
          } else {
            this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
          }
        }
      }, {
        key: "placeNodes",
        value: function placeNodes(_ref) {
          var sliceDepth = _ref.sliceDepth, frontierDepth = _ref.frontierDepth, parent = _ref.parent, inject = _ref.inject, wrap = _ref.wrap;
          while (this.depth > frontierDepth) {
            this.closeFrontierNode();
          }
          if (wrap)
            for (var i = 0; i < wrap.length; i++) {
              this.openFrontierNode(wrap[i]);
            }
          var slice = this.unplaced, fragment = parent ? parent.content : slice.content;
          var openStart = slice.openStart - sliceDepth;
          var taken = 0, add = [];
          var _this$frontier$fronti2 = this.frontier[frontierDepth], match = _this$frontier$fronti2.match, type = _this$frontier$fronti2.type;
          if (inject) {
            for (var i = 0; i < inject.childCount; i++) {
              add.push(inject.child(i));
            }
            match = match.matchFragment(inject);
          }
          var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
          while (taken < fragment.childCount) {
            var next = fragment.child(taken), matches = match.matchType(next.type);
            if (!matches)
              break;
            taken++;
            if (taken > 1 || openStart == 0 || next.content.size) {
              match = matches;
              add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
            }
          }
          var toEnd = taken == fragment.childCount;
          if (!toEnd)
            openEndCount = -1;
          this.placed = addToFragment(this.placed, frontierDepth, prosemirrorModel.Fragment.from(add));
          this.frontier[frontierDepth].match = match;
          if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
            this.closeFrontierNode();
          for (var _i3 = 0, cur = fragment; _i3 < openEndCount; _i3++) {
            var node = cur.lastChild;
            this.frontier.push({
              type: node.type,
              match: node.contentMatchAt(node.childCount)
            });
            cur = node.content;
          }
          this.unplaced = !toEnd ? new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
        }
      }, {
        key: "mustMoveInline",
        value: function mustMoveInline() {
          if (!this.$to.parent.isTextblock)
            return -1;
          var top = this.frontier[this.depth], level;
          if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
            return -1;
          var depth = this.$to.depth, after = this.$to.after(depth);
          while (depth > 1 && after == this.$to.end(--depth)) {
            ++after;
          }
          return after;
        }
      }, {
        key: "findCloseLevel",
        value: function findCloseLevel($to) {
          scan:
            for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
              var _this$frontier$i = this.frontier[i], match = _this$frontier$i.match, type = _this$frontier$i.type;
              var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
              var fit = contentAfterFits($to, i, type, match, dropInner);
              if (!fit)
                continue;
              for (var d = i - 1; d >= 0; d--) {
                var _this$frontier$d = this.frontier[d], _match = _this$frontier$d.match, _type = _this$frontier$d.type;
                var matches = contentAfterFits($to, d, _type, _match, true);
                if (!matches || matches.childCount)
                  continue scan;
              }
              return {
                depth: i,
                fit,
                move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to
              };
            }
        }
      }, {
        key: "close",
        value: function close($to) {
          var close2 = this.findCloseLevel($to);
          if (!close2)
            return null;
          while (this.depth > close2.depth) {
            this.closeFrontierNode();
          }
          if (close2.fit.childCount)
            this.placed = addToFragment(this.placed, close2.depth, close2.fit);
          $to = close2.move;
          for (var d = close2.depth + 1; d <= $to.depth; d++) {
            var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
            this.openFrontierNode(node.type, node.attrs, add);
          }
          return $to;
        }
      }, {
        key: "openFrontierNode",
        value: function openFrontierNode(type) {
          var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var content = arguments.length > 2 ? arguments[2] : void 0;
          var top = this.frontier[this.depth];
          top.match = top.match.matchType(type);
          this.placed = addToFragment(this.placed, this.depth, prosemirrorModel.Fragment.from(type.create(attrs, content)));
          this.frontier.push({
            type,
            match: type.contentMatch
          });
        }
      }, {
        key: "closeFrontierNode",
        value: function closeFrontierNode() {
          var open = this.frontier.pop();
          var add = open.match.fillBefore(prosemirrorModel.Fragment.empty, true);
          if (add.childCount)
            this.placed = addToFragment(this.placed, this.frontier.length, add);
        }
      }]);
      return Fitter2;
    }();
    function dropFromFragment(fragment, depth, count) {
      if (depth == 0)
        return fragment.cutByIndex(count, fragment.childCount);
      return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
    }
    function addToFragment(fragment, depth, content) {
      if (depth == 0)
        return fragment.append(content);
      return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
    }
    function contentAt(fragment, depth) {
      for (var i = 0; i < depth; i++) {
        fragment = fragment.firstChild.content;
      }
      return fragment;
    }
    function closeNodeStart(node, openStart, openEnd) {
      if (openStart <= 0)
        return node;
      var frag = node.content;
      if (openStart > 1)
        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
      if (openStart > 0) {
        frag = node.type.contentMatch.fillBefore(frag).append(frag);
        if (openEnd <= 0)
          frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirrorModel.Fragment.empty, true));
      }
      return node.copy(frag);
    }
    function contentAfterFits($to, depth, type, match, open) {
      var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
      if (index == node.childCount && !type.compatibleContent(node.type))
        return null;
      var fit = match.fillBefore(node.content, true, index);
      return fit && !invalidMarks(type, node.content, index) ? fit : null;
    }
    function invalidMarks(type, fragment, start) {
      for (var i = start; i < fragment.childCount; i++) {
        if (!type.allowsMarks(fragment.child(i).marks))
          return true;
      }
      return false;
    }
    function definesContent(type) {
      return type.spec.defining || type.spec.definingForContent;
    }
    function _replaceRange(tr, from, to, slice) {
      if (!slice.size)
        return tr.deleteRange(from, to);
      var $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
      if (fitsTrivially($from, $to, slice))
        return tr.step(new ReplaceStep(from, to, slice));
      var targetDepths = coveredDepths($from, tr.doc.resolve(to));
      if (targetDepths[targetDepths.length - 1] == 0)
        targetDepths.pop();
      var preferredTarget = -($from.depth + 1);
      targetDepths.unshift(preferredTarget);
      for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
        var spec = $from.node(d).type.spec;
        if (spec.defining || spec.definingAsContext || spec.isolating)
          break;
        if (targetDepths.indexOf(d) > -1)
          preferredTarget = d;
        else if ($from.before(d) == pos)
          targetDepths.splice(1, 0, -d);
      }
      var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
      var leftNodes = [], preferredDepth = slice.openStart;
      for (var content = slice.content, i = 0; ; i++) {
        var node = content.firstChild;
        leftNodes.push(node);
        if (i == slice.openStart)
          break;
        content = node.content;
      }
      for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {
        var type = leftNodes[_d3].type, def = definesContent(type);
        if (def && $from.node(preferredTargetIndex).type != type)
          preferredDepth = _d3;
        else if (def || !type.isTextblock)
          break;
      }
      for (var j = slice.openStart; j >= 0; j--) {
        var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
        var insert = leftNodes[openDepth];
        if (!insert)
          continue;
        for (var _i4 = 0; _i4 < targetDepths.length; _i4++) {
          var targetDepth = targetDepths[(_i4 + preferredTargetIndex) % targetDepths.length], expand = true;
          if (targetDepth < 0) {
            expand = false;
            targetDepth = -targetDepth;
          }
          var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
          if (parent.canReplaceWith(index, index, insert.type, insert.marks))
            return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
        }
      }
      var startSteps = tr.steps.length;
      for (var _i5 = targetDepths.length - 1; _i5 >= 0; _i5--) {
        tr.replace(from, to, slice);
        if (tr.steps.length > startSteps)
          break;
        var depth = targetDepths[_i5];
        if (depth < 0)
          continue;
        from = $from.before(depth);
        to = $to.after(depth);
      }
    }
    function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
      if (depth < oldOpen) {
        var first = fragment.firstChild;
        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
      }
      if (depth > newOpen) {
        var match = parent.contentMatchAt(0);
        var start = match.fillBefore(fragment).append(fragment);
        fragment = start.append(match.matchFragment(start).fillBefore(prosemirrorModel.Fragment.empty, true));
      }
      return fragment;
    }
    function _replaceRangeWith(tr, from, to, node) {
      if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
        var point = insertPoint(tr.doc, from, node.type);
        if (point != null)
          from = to = point;
      }
      tr.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));
    }
    function _deleteRange(tr, from, to) {
      var $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
      var covered = coveredDepths($from, $to);
      for (var i = 0; i < covered.length; i++) {
        var depth = covered[i], last = i == covered.length - 1;
        if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
          return tr["delete"]($from.start(depth), $to.end(depth));
        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
          return tr["delete"]($from.before(depth), $to.after(depth));
      }
      for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
          return tr["delete"]($from.before(d), to);
      }
      tr["delete"](from, to);
    }
    function coveredDepths($from, $to) {
      var result = [], minDepth = Math.min($from.depth, $to.depth);
      for (var d = minDepth; d >= 0; d--) {
        var start = $from.start(d);
        if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)
          break;
        if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)
          result.push(d);
      }
      return result;
    }
    var AttrStep = function(_Step7) {
      _inherits(AttrStep2, _Step7);
      var _super7 = _createSuper(AttrStep2);
      function AttrStep2(pos, attr, value) {
        var _this9;
        _classCallCheck(this, AttrStep2);
        _this9 = _super7.call(this);
        _this9.pos = pos;
        _this9.attr = attr;
        _this9.value = value;
        return _this9;
      }
      _createClass(AttrStep2, [{
        key: "apply",
        value: function apply(doc) {
          var node = doc.nodeAt(this.pos);
          if (!node)
            return StepResult.fail("No node at attribute step's position");
          var attrs = /* @__PURE__ */ Object.create(null);
          for (var name in node.attrs) {
            attrs[name] = node.attrs[name];
          }
          attrs[this.attr] = this.value;
          var updated = node.type.create(attrs, null, node.marks);
          return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
        }
      }, {
        key: "getMap",
        value: function getMap() {
          return StepMap.empty;
        }
      }, {
        key: "invert",
        value: function invert(doc) {
          return new AttrStep2(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);
        }
      }, {
        key: "map",
        value: function map(mapping) {
          var pos = mapping.mapResult(this.pos, 1);
          return pos.deletedAfter ? null : new AttrStep2(pos.pos, this.attr, this.value);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(schema, json) {
          if (typeof json.pos != "number" || typeof json.attr != "string")
            throw new RangeError("Invalid input for AttrStep.fromJSON");
          return new AttrStep2(json.pos, json.attr, json.value);
        }
      }]);
      return AttrStep2;
    }(Step);
    Step.jsonID("attr", AttrStep);
    exports.TransformError = function(_Error) {
      _inherits(_class, _Error);
      var _super8 = _createSuper(_class);
      function _class() {
        _classCallCheck(this, _class);
        return _super8.apply(this, arguments);
      }
      return _createClass(_class);
    }(_wrapNativeSuper(Error));
    exports.TransformError = function TransformError(message) {
      var err = Error.call(this, message);
      err.__proto__ = TransformError.prototype;
      return err;
    };
    exports.TransformError.prototype = Object.create(Error.prototype);
    exports.TransformError.prototype.constructor = exports.TransformError;
    exports.TransformError.prototype.name = "TransformError";
    var Transform = function() {
      function Transform2(doc) {
        _classCallCheck(this, Transform2);
        this.doc = doc;
        this.steps = [];
        this.docs = [];
        this.mapping = new Mapping();
      }
      _createClass(Transform2, [{
        key: "before",
        get: function get() {
          return this.docs.length ? this.docs[0] : this.doc;
        }
      }, {
        key: "step",
        value: function step(_step) {
          var result = this.maybeStep(_step);
          if (result.failed)
            throw new exports.TransformError(result.failed);
          return this;
        }
      }, {
        key: "maybeStep",
        value: function maybeStep(step) {
          var result = step.apply(this.doc);
          if (!result.failed)
            this.addStep(step, result.doc);
          return result;
        }
      }, {
        key: "docChanged",
        get: function get() {
          return this.steps.length > 0;
        }
      }, {
        key: "addStep",
        value: function addStep(step, doc) {
          this.docs.push(this.doc);
          this.steps.push(step);
          this.mapping.appendMap(step.getMap());
          this.doc = doc;
        }
      }, {
        key: "replace",
        value: function replace(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
          var slice = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : prosemirrorModel.Slice.empty;
          var step = replaceStep(this.doc, from, to, slice);
          if (step)
            this.step(step);
          return this;
        }
      }, {
        key: "replaceWith",
        value: function replaceWith(from, to, content) {
          return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0));
        }
      }, {
        key: "delete",
        value: function _delete(from, to) {
          return this.replace(from, to, prosemirrorModel.Slice.empty);
        }
      }, {
        key: "insert",
        value: function insert(pos, content) {
          return this.replaceWith(pos, pos, content);
        }
      }, {
        key: "replaceRange",
        value: function replaceRange(from, to, slice) {
          _replaceRange(this, from, to, slice);
          return this;
        }
      }, {
        key: "replaceRangeWith",
        value: function replaceRangeWith(from, to, node) {
          _replaceRangeWith(this, from, to, node);
          return this;
        }
      }, {
        key: "deleteRange",
        value: function deleteRange(from, to) {
          _deleteRange(this, from, to);
          return this;
        }
      }, {
        key: "lift",
        value: function lift(range, target) {
          _lift(this, range, target);
          return this;
        }
      }, {
        key: "join",
        value: function join(pos) {
          var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          _join(this, pos, depth);
          return this;
        }
      }, {
        key: "wrap",
        value: function wrap(range, wrappers) {
          _wrap2(this, range, wrappers);
          return this;
        }
      }, {
        key: "setBlockType",
        value: function setBlockType(from) {
          var to = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : from;
          var type = arguments.length > 2 ? arguments[2] : void 0;
          var attrs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          _setBlockType(this, from, to, type, attrs);
          return this;
        }
      }, {
        key: "setNodeMarkup",
        value: function setNodeMarkup(pos, type) {
          var attrs = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var marks = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
          _setNodeMarkup(this, pos, type, attrs, marks);
          return this;
        }
      }, {
        key: "setNodeAttribute",
        value: function setNodeAttribute(pos, attr, value) {
          this.step(new AttrStep(pos, attr, value));
          return this;
        }
      }, {
        key: "addNodeMark",
        value: function addNodeMark(pos, mark) {
          this.step(new AddNodeMarkStep(pos, mark));
          return this;
        }
      }, {
        key: "removeNodeMark",
        value: function removeNodeMark(pos, mark) {
          if (!(mark instanceof prosemirrorModel.Mark)) {
            var node = this.doc.nodeAt(pos);
            if (!node)
              throw new RangeError("No node at position " + pos);
            mark = mark.isInSet(node.marks);
            if (!mark)
              return this;
          }
          this.step(new RemoveNodeMarkStep(pos, mark));
          return this;
        }
      }, {
        key: "split",
        value: function split(pos) {
          var depth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          var typesAfter = arguments.length > 2 ? arguments[2] : void 0;
          _split(this, pos, depth, typesAfter);
          return this;
        }
      }, {
        key: "addMark",
        value: function addMark(from, to, mark) {
          _addMark(this, from, to, mark);
          return this;
        }
      }, {
        key: "removeMark",
        value: function removeMark(from, to, mark) {
          _removeMark(this, from, to, mark);
          return this;
        }
      }, {
        key: "clearIncompatible",
        value: function clearIncompatible(pos, parentType, match) {
          _clearIncompatible(this, pos, parentType, match);
          return this;
        }
      }]);
      return Transform2;
    }();
    exports.AddMarkStep = AddMarkStep;
    exports.AddNodeMarkStep = AddNodeMarkStep;
    exports.AttrStep = AttrStep;
    exports.MapResult = MapResult;
    exports.Mapping = Mapping;
    exports.RemoveMarkStep = RemoveMarkStep;
    exports.RemoveNodeMarkStep = RemoveNodeMarkStep;
    exports.ReplaceAroundStep = ReplaceAroundStep;
    exports.ReplaceStep = ReplaceStep;
    exports.Step = Step;
    exports.StepMap = StepMap;
    exports.StepResult = StepResult;
    exports.Transform = Transform;
    exports.canJoin = canJoin;
    exports.canSplit = canSplit;
    exports.dropPoint = dropPoint;
    exports.findWrapping = findWrapping;
    exports.insertPoint = insertPoint;
    exports.joinPoint = joinPoint;
    exports.liftTarget = liftTarget;
    exports.replaceStep = replaceStep;
  }
});

// node_modules/prosemirror-state/dist/index.cjs
var require_dist4 = __commonJS({
  "node_modules/prosemirror-state/dist/index.cjs"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var prosemirrorModel = require_dist2();
    var prosemirrorTransform = require_dist3();
    var classesById = /* @__PURE__ */ Object.create(null);
    var Selection = function() {
      function Selection2($anchor, $head, ranges) {
        _classCallCheck(this, Selection2);
        this.$anchor = $anchor;
        this.$head = $head;
        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      }
      _createClass(Selection2, [{
        key: "anchor",
        get: function get() {
          return this.$anchor.pos;
        }
      }, {
        key: "head",
        get: function get() {
          return this.$head.pos;
        }
      }, {
        key: "from",
        get: function get() {
          return this.$from.pos;
        }
      }, {
        key: "to",
        get: function get() {
          return this.$to.pos;
        }
      }, {
        key: "$from",
        get: function get() {
          return this.ranges[0].$from;
        }
      }, {
        key: "$to",
        get: function get() {
          return this.ranges[0].$to;
        }
      }, {
        key: "empty",
        get: function get() {
          var ranges = this.ranges;
          for (var i = 0; i < ranges.length; i++) {
            if (ranges[i].$from.pos != ranges[i].$to.pos)
              return false;
          }
          return true;
        }
      }, {
        key: "content",
        value: function content() {
          return this.$from.doc.slice(this.from, this.to, true);
        }
      }, {
        key: "replace",
        value: function replace(tr) {
          var content = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prosemirrorModel.Slice.empty;
          var lastNode = content.content.lastChild, lastParent = null;
          for (var i = 0; i < content.openEnd; i++) {
            lastParent = lastNode;
            lastNode = lastNode.lastChild;
          }
          var mapFrom = tr.steps.length, ranges = this.ranges;
          for (var _i = 0; _i < ranges.length; _i++) {
            var _ranges$_i = ranges[_i], $from = _ranges$_i.$from, $to = _ranges$_i.$to, mapping = tr.mapping.slice(mapFrom);
            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? prosemirrorModel.Slice.empty : content);
            if (_i == 0)
              selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
          }
        }
      }, {
        key: "replaceWith",
        value: function replaceWith(tr, node) {
          var mapFrom = tr.steps.length, ranges = this.ranges;
          for (var i = 0; i < ranges.length; i++) {
            var _ranges$i = ranges[i], $from = _ranges$i.$from, $to = _ranges$i.$to, mapping = tr.mapping.slice(mapFrom);
            var from = mapping.map($from.pos), to = mapping.map($to.pos);
            if (i) {
              tr.deleteRange(from, to);
            } else {
              tr.replaceRangeWith(from, to, node);
              selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
            }
          }
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return TextSelection.between(this.$anchor, this.$head).getBookmark();
        }
      }], [{
        key: "findFrom",
        value: function findFrom($pos, dir) {
          var textOnly = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
          var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
          if (inner)
            return inner;
          for (var depth = $pos.depth - 1; depth >= 0; depth--) {
            var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
            if (found)
              return found;
          }
          return null;
        }
      }, {
        key: "near",
        value: function near($pos) {
          var bias = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
        }
      }, {
        key: "atStart",
        value: function atStart(doc) {
          return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
        }
      }, {
        key: "atEnd",
        value: function atEnd(doc) {
          return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
        }
      }, {
        key: "fromJSON",
        value: function fromJSON(doc, json) {
          if (!json || !json.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
          var cls = classesById[json.type];
          if (!cls)
            throw new RangeError("No selection type ".concat(json.type, " defined"));
          return cls.fromJSON(doc, json);
        }
      }, {
        key: "jsonID",
        value: function jsonID(id, selectionClass) {
          if (id in classesById)
            throw new RangeError("Duplicate use of selection JSON ID " + id);
          classesById[id] = selectionClass;
          selectionClass.prototype.jsonID = id;
          return selectionClass;
        }
      }]);
      return Selection2;
    }();
    Selection.prototype.visible = true;
    var SelectionRange = _createClass(function SelectionRange2($from, $to) {
      _classCallCheck(this, SelectionRange2);
      this.$from = $from;
      this.$to = $to;
    });
    var warnedAboutTextSelection = false;
    function checkTextSelection($pos) {
      if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
        warnedAboutTextSelection = true;
        console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
      }
    }
    var TextSelection = function(_Selection) {
      _inherits(TextSelection2, _Selection);
      var _super = _createSuper(TextSelection2);
      function TextSelection2($anchor) {
        var $head = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : $anchor;
        _classCallCheck(this, TextSelection2);
        checkTextSelection($anchor);
        checkTextSelection($head);
        return _super.call(this, $anchor, $head);
      }
      _createClass(TextSelection2, [{
        key: "$cursor",
        get: function get() {
          return this.$anchor.pos == this.$head.pos ? this.$head : null;
        }
      }, {
        key: "map",
        value: function map(doc, mapping) {
          var $head = doc.resolve(mapping.map(this.head));
          if (!$head.parent.inlineContent)
            return Selection.near($head);
          var $anchor = doc.resolve(mapping.map(this.anchor));
          return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
        }
      }, {
        key: "replace",
        value: function replace(tr) {
          var content = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prosemirrorModel.Slice.empty;
          _get(_getPrototypeOf(TextSelection2.prototype), "replace", this).call(this, tr, content);
          if (content == prosemirrorModel.Slice.empty) {
            var marks = this.$from.marksAcross(this.$to);
            if (marks)
              tr.ensureMarks(marks);
          }
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return new TextBookmark(this.anchor, this.head);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            type: "text",
            anchor: this.anchor,
            head: this.head
          };
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(doc, json) {
          if (typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid input for TextSelection.fromJSON");
          return new TextSelection2(doc.resolve(json.anchor), doc.resolve(json.head));
        }
      }, {
        key: "create",
        value: function create(doc, anchor) {
          var head = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : anchor;
          var $anchor = doc.resolve(anchor);
          return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
        }
      }, {
        key: "between",
        value: function between($anchor, $head, bias) {
          var dPos = $anchor.pos - $head.pos;
          if (!bias || dPos)
            bias = dPos >= 0 ? 1 : -1;
          if (!$head.parent.inlineContent) {
            var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
            if (found)
              $head = found.$head;
            else
              return Selection.near($head, bias);
          }
          if (!$anchor.parent.inlineContent) {
            if (dPos == 0) {
              $anchor = $head;
            } else {
              $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
              if ($anchor.pos < $head.pos != dPos < 0)
                $anchor = $head;
            }
          }
          return new TextSelection2($anchor, $head);
        }
      }]);
      return TextSelection2;
    }(Selection);
    Selection.jsonID("text", TextSelection);
    var TextBookmark = function() {
      function TextBookmark2(anchor, head) {
        _classCallCheck(this, TextBookmark2);
        this.anchor = anchor;
        this.head = head;
      }
      _createClass(TextBookmark2, [{
        key: "map",
        value: function map(mapping) {
          return new TextBookmark2(mapping.map(this.anchor), mapping.map(this.head));
        }
      }, {
        key: "resolve",
        value: function resolve(doc) {
          return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
        }
      }]);
      return TextBookmark2;
    }();
    var NodeSelection = function(_Selection2) {
      _inherits(NodeSelection2, _Selection2);
      var _super2 = _createSuper(NodeSelection2);
      function NodeSelection2($pos) {
        var _this;
        _classCallCheck(this, NodeSelection2);
        var node = $pos.nodeAfter;
        var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
        _this = _super2.call(this, $pos, $end);
        _this.node = node;
        return _this;
      }
      _createClass(NodeSelection2, [{
        key: "map",
        value: function map(doc, mapping) {
          var _mapping$mapResult = mapping.mapResult(this.anchor), deleted = _mapping$mapResult.deleted, pos = _mapping$mapResult.pos;
          var $pos = doc.resolve(pos);
          if (deleted)
            return Selection.near($pos);
          return new NodeSelection2($pos);
        }
      }, {
        key: "content",
        value: function content() {
          return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(this.node), 0, 0);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return other instanceof NodeSelection2 && other.anchor == this.anchor;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            type: "node",
            anchor: this.anchor
          };
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return new NodeBookmark(this.anchor);
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(doc, json) {
          if (typeof json.anchor != "number")
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
          return new NodeSelection2(doc.resolve(json.anchor));
        }
      }, {
        key: "create",
        value: function create(doc, from) {
          return new NodeSelection2(doc.resolve(from));
        }
      }, {
        key: "isSelectable",
        value: function isSelectable(node) {
          return !node.isText && node.type.spec.selectable !== false;
        }
      }]);
      return NodeSelection2;
    }(Selection);
    NodeSelection.prototype.visible = false;
    Selection.jsonID("node", NodeSelection);
    var NodeBookmark = function() {
      function NodeBookmark2(anchor) {
        _classCallCheck(this, NodeBookmark2);
        this.anchor = anchor;
      }
      _createClass(NodeBookmark2, [{
        key: "map",
        value: function map(mapping) {
          var _mapping$mapResult2 = mapping.mapResult(this.anchor), deleted = _mapping$mapResult2.deleted, pos = _mapping$mapResult2.pos;
          return deleted ? new TextBookmark(pos, pos) : new NodeBookmark2(pos);
        }
      }, {
        key: "resolve",
        value: function resolve(doc) {
          var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
          if (node && NodeSelection.isSelectable(node))
            return new NodeSelection($pos);
          return Selection.near($pos);
        }
      }]);
      return NodeBookmark2;
    }();
    var AllSelection = function(_Selection3) {
      _inherits(AllSelection2, _Selection3);
      var _super3 = _createSuper(AllSelection2);
      function AllSelection2(doc) {
        _classCallCheck(this, AllSelection2);
        return _super3.call(this, doc.resolve(0), doc.resolve(doc.content.size));
      }
      _createClass(AllSelection2, [{
        key: "replace",
        value: function replace(tr) {
          var content = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : prosemirrorModel.Slice.empty;
          if (content == prosemirrorModel.Slice.empty) {
            tr["delete"](0, tr.doc.content.size);
            var sel = Selection.atStart(tr.doc);
            if (!sel.eq(tr.selection))
              tr.setSelection(sel);
          } else {
            _get(_getPrototypeOf(AllSelection2.prototype), "replace", this).call(this, tr, content);
          }
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            type: "all"
          };
        }
      }, {
        key: "map",
        value: function map(doc) {
          return new AllSelection2(doc);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return other instanceof AllSelection2;
        }
      }, {
        key: "getBookmark",
        value: function getBookmark() {
          return AllBookmark;
        }
      }], [{
        key: "fromJSON",
        value: function fromJSON(doc) {
          return new AllSelection2(doc);
        }
      }]);
      return AllSelection2;
    }(Selection);
    Selection.jsonID("all", AllSelection);
    var AllBookmark = {
      map: function map() {
        return this;
      },
      resolve: function resolve(doc) {
        return new AllSelection(doc);
      }
    };
    function findSelectionIn(doc, node, pos, index, dir) {
      var text = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
      if (node.inlineContent)
        return TextSelection.create(doc, pos);
      for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
        var child = node.child(i);
        if (!child.isAtom) {
          var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
          if (inner)
            return inner;
        } else if (!text && NodeSelection.isSelectable(child)) {
          return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
        }
        pos += child.nodeSize * dir;
      }
      return null;
    }
    function selectionToInsertionEnd(tr, startLen, bias) {
      var last = tr.steps.length - 1;
      if (last < startLen)
        return;
      var step = tr.steps[last];
      if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep))
        return;
      var map = tr.mapping.maps[last], end;
      map.forEach(function(_from, _to, _newFrom, newTo) {
        if (end == null)
          end = newTo;
      });
      tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
    }
    var UPDATED_SEL = 1;
    var UPDATED_MARKS = 2;
    var UPDATED_SCROLL = 4;
    var Transaction = function(_prosemirrorTransform) {
      _inherits(Transaction2, _prosemirrorTransform);
      var _super4 = _createSuper(Transaction2);
      function Transaction2(state) {
        var _this2;
        _classCallCheck(this, Transaction2);
        _this2 = _super4.call(this, state.doc);
        _this2.curSelectionFor = 0;
        _this2.updated = 0;
        _this2.meta = /* @__PURE__ */ Object.create(null);
        _this2.time = Date.now();
        _this2.curSelection = state.selection;
        _this2.storedMarks = state.storedMarks;
        return _this2;
      }
      _createClass(Transaction2, [{
        key: "selection",
        get: function get() {
          if (this.curSelectionFor < this.steps.length) {
            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
            this.curSelectionFor = this.steps.length;
          }
          return this.curSelection;
        }
      }, {
        key: "setSelection",
        value: function setSelection(selection) {
          if (selection.$from.doc != this.doc)
            throw new RangeError("Selection passed to setSelection must point at the current document");
          this.curSelection = selection;
          this.curSelectionFor = this.steps.length;
          this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
          this.storedMarks = null;
          return this;
        }
      }, {
        key: "selectionSet",
        get: function get() {
          return (this.updated & UPDATED_SEL) > 0;
        }
      }, {
        key: "setStoredMarks",
        value: function setStoredMarks(marks) {
          this.storedMarks = marks;
          this.updated |= UPDATED_MARKS;
          return this;
        }
      }, {
        key: "ensureMarks",
        value: function ensureMarks(marks) {
          if (!prosemirrorModel.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
            this.setStoredMarks(marks);
          return this;
        }
      }, {
        key: "addStoredMark",
        value: function addStoredMark(mark) {
          return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
        }
      }, {
        key: "removeStoredMark",
        value: function removeStoredMark(mark) {
          return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
        }
      }, {
        key: "storedMarksSet",
        get: function get() {
          return (this.updated & UPDATED_MARKS) > 0;
        }
      }, {
        key: "addStep",
        value: function addStep(step, doc) {
          _get(_getPrototypeOf(Transaction2.prototype), "addStep", this).call(this, step, doc);
          this.updated = this.updated & ~UPDATED_MARKS;
          this.storedMarks = null;
        }
      }, {
        key: "setTime",
        value: function setTime(time) {
          this.time = time;
          return this;
        }
      }, {
        key: "replaceSelection",
        value: function replaceSelection(slice) {
          this.selection.replace(this, slice);
          return this;
        }
      }, {
        key: "replaceSelectionWith",
        value: function replaceSelectionWith(node) {
          var inheritMarks = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var selection = this.selection;
          if (inheritMarks)
            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirrorModel.Mark.none));
          selection.replaceWith(this, node);
          return this;
        }
      }, {
        key: "deleteSelection",
        value: function deleteSelection() {
          this.selection.replace(this);
          return this;
        }
      }, {
        key: "insertText",
        value: function insertText(text, from, to) {
          var schema = this.doc.type.schema;
          if (from == null) {
            if (!text)
              return this.deleteSelection();
            return this.replaceSelectionWith(schema.text(text), true);
          } else {
            if (to == null)
              to = from;
            to = to == null ? from : to;
            if (!text)
              return this.deleteRange(from, to);
            var marks = this.storedMarks;
            if (!marks) {
              var $from = this.doc.resolve(from);
              marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
            }
            this.replaceRangeWith(from, to, schema.text(text, marks));
            if (!this.selection.empty)
              this.setSelection(Selection.near(this.selection.$to));
            return this;
          }
        }
      }, {
        key: "setMeta",
        value: function setMeta(key, value) {
          this.meta[typeof key == "string" ? key : key.key] = value;
          return this;
        }
      }, {
        key: "getMeta",
        value: function getMeta(key) {
          return this.meta[typeof key == "string" ? key : key.key];
        }
      }, {
        key: "isGeneric",
        get: function get() {
          for (var _ in this.meta) {
            return false;
          }
          return true;
        }
      }, {
        key: "scrollIntoView",
        value: function scrollIntoView() {
          this.updated |= UPDATED_SCROLL;
          return this;
        }
      }, {
        key: "scrolledIntoView",
        get: function get() {
          return (this.updated & UPDATED_SCROLL) > 0;
        }
      }]);
      return Transaction2;
    }(prosemirrorTransform.Transform);
    function bind(f, self) {
      return !self || !f ? f : f.bind(self);
    }
    var FieldDesc = _createClass(function FieldDesc2(name, desc, self) {
      _classCallCheck(this, FieldDesc2);
      this.name = name;
      this.init = bind(desc.init, self);
      this.apply = bind(desc.apply, self);
    });
    var baseFields = [new FieldDesc("doc", {
      init: function init(config) {
        return config.doc || config.schema.topNodeType.createAndFill();
      },
      apply: function apply(tr) {
        return tr.doc;
      }
    }), new FieldDesc("selection", {
      init: function init(config, instance) {
        return config.selection || Selection.atStart(instance.doc);
      },
      apply: function apply(tr) {
        return tr.selection;
      }
    }), new FieldDesc("storedMarks", {
      init: function init(config) {
        return config.storedMarks || null;
      },
      apply: function apply(tr, _marks, _old, state) {
        return state.selection.$cursor ? tr.storedMarks : null;
      }
    }), new FieldDesc("scrollToSelection", {
      init: function init() {
        return 0;
      },
      apply: function apply(tr, prev) {
        return tr.scrolledIntoView ? prev + 1 : prev;
      }
    })];
    var Configuration = _createClass(function Configuration2(schema, plugins) {
      var _this3 = this;
      _classCallCheck(this, Configuration2);
      this.schema = schema;
      this.plugins = [];
      this.pluginsByKey = /* @__PURE__ */ Object.create(null);
      this.fields = baseFields.slice();
      if (plugins)
        plugins.forEach(function(plugin) {
          if (_this3.pluginsByKey[plugin.key])
            throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
          _this3.plugins.push(plugin);
          _this3.pluginsByKey[plugin.key] = plugin;
          if (plugin.spec.state)
            _this3.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
        });
    });
    var EditorState = function() {
      function EditorState2(config) {
        _classCallCheck(this, EditorState2);
        this.config = config;
      }
      _createClass(EditorState2, [{
        key: "schema",
        get: function get() {
          return this.config.schema;
        }
      }, {
        key: "plugins",
        get: function get() {
          return this.config.plugins;
        }
      }, {
        key: "apply",
        value: function apply(tr) {
          return this.applyTransaction(tr).state;
        }
      }, {
        key: "filterTransaction",
        value: function filterTransaction(tr) {
          var ignore = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
          for (var i = 0; i < this.config.plugins.length; i++) {
            if (i != ignore) {
              var plugin = this.config.plugins[i];
              if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
                return false;
            }
          }
          return true;
        }
      }, {
        key: "applyTransaction",
        value: function applyTransaction(rootTr) {
          if (!this.filterTransaction(rootTr))
            return {
              state: this,
              transactions: []
            };
          var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
          for (; ; ) {
            var haveNew = false;
            for (var i = 0; i < this.config.plugins.length; i++) {
              var plugin = this.config.plugins[i];
              if (plugin.spec.appendTransaction) {
                var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
                var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
                if (tr && newState.filterTransaction(tr, i)) {
                  tr.setMeta("appendedTransaction", rootTr);
                  if (!seen) {
                    seen = [];
                    for (var j = 0; j < this.config.plugins.length; j++) {
                      seen.push(j < i ? {
                        state: newState,
                        n: trs.length
                      } : {
                        state: this,
                        n: 0
                      });
                    }
                  }
                  trs.push(tr);
                  newState = newState.applyInner(tr);
                  haveNew = true;
                }
                if (seen)
                  seen[i] = {
                    state: newState,
                    n: trs.length
                  };
              }
            }
            if (!haveNew)
              return {
                state: newState,
                transactions: trs
              };
          }
        }
      }, {
        key: "applyInner",
        value: function applyInner(tr) {
          if (!tr.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
          var newInstance = new EditorState2(this.config), fields = this.config.fields;
          for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
          }
          return newInstance;
        }
      }, {
        key: "tr",
        get: function get() {
          return new Transaction(this);
        }
      }, {
        key: "reconfigure",
        value: function reconfigure(config) {
          var $config = new Configuration(this.schema, config.plugins);
          var fields = $config.fields, instance = new EditorState2($config);
          for (var i = 0; i < fields.length; i++) {
            var name = fields[i].name;
            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
          }
          return instance;
        }
      }, {
        key: "toJSON",
        value: function toJSON(pluginFields) {
          var result = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON()
          };
          if (this.storedMarks)
            result.storedMarks = this.storedMarks.map(function(m) {
              return m.toJSON();
            });
          if (pluginFields && _typeof(pluginFields) == "object")
            for (var prop in pluginFields) {
              if (prop == "doc" || prop == "selection")
                throw new RangeError("The JSON fields `doc` and `selection` are reserved");
              var plugin = pluginFields[prop], state = plugin.spec.state;
              if (state && state.toJSON)
                result[prop] = state.toJSON.call(plugin, this[plugin.key]);
            }
          return result;
        }
      }], [{
        key: "create",
        value: function create(config) {
          var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
          var instance = new EditorState2($config);
          for (var i = 0; i < $config.fields.length; i++) {
            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
          }
          return instance;
        }
      }, {
        key: "fromJSON",
        value: function fromJSON(config, json, pluginFields) {
          if (!json)
            throw new RangeError("Invalid input for EditorState.fromJSON");
          if (!config.schema)
            throw new RangeError("Required config field 'schema' missing");
          var $config = new Configuration(config.schema, config.plugins);
          var instance = new EditorState2($config);
          $config.fields.forEach(function(field) {
            if (field.name == "doc") {
              instance.doc = prosemirrorModel.Node.fromJSON(config.schema, json.doc);
            } else if (field.name == "selection") {
              instance.selection = Selection.fromJSON(instance.doc, json.selection);
            } else if (field.name == "storedMarks") {
              if (json.storedMarks)
                instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
            } else {
              if (pluginFields)
                for (var prop in pluginFields) {
                  var plugin = pluginFields[prop], state = plugin.spec.state;
                  if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
                    instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
                    return;
                  }
                }
              instance[field.name] = field.init(config, instance);
            }
          });
          return instance;
        }
      }]);
      return EditorState2;
    }();
    function bindProps(obj, self, target) {
      for (var prop in obj) {
        var val = obj[prop];
        if (val instanceof Function)
          val = val.bind(self);
        else if (prop == "handleDOMEvents")
          val = bindProps(val, self, {});
        target[prop] = val;
      }
      return target;
    }
    var Plugin = function() {
      function Plugin2(spec) {
        _classCallCheck(this, Plugin2);
        this.spec = spec;
        this.props = {};
        if (spec.props)
          bindProps(spec.props, this, this.props);
        this.key = spec.key ? spec.key.key : createKey("plugin");
      }
      _createClass(Plugin2, [{
        key: "getState",
        value: function getState(state) {
          return state[this.key];
        }
      }]);
      return Plugin2;
    }();
    var keys = /* @__PURE__ */ Object.create(null);
    function createKey(name) {
      if (name in keys)
        return name + "$" + ++keys[name];
      keys[name] = 0;
      return name + "$";
    }
    var PluginKey = function() {
      function PluginKey2() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "key";
        _classCallCheck(this, PluginKey2);
        this.key = createKey(name);
      }
      _createClass(PluginKey2, [{
        key: "get",
        value: function get(state) {
          return state.config.pluginsByKey[this.key];
        }
      }, {
        key: "getState",
        value: function getState(state) {
          return state[this.key];
        }
      }]);
      return PluginKey2;
    }();
    exports.AllSelection = AllSelection;
    exports.EditorState = EditorState;
    exports.NodeSelection = NodeSelection;
    exports.Plugin = Plugin;
    exports.PluginKey = PluginKey;
    exports.Selection = Selection;
    exports.SelectionRange = SelectionRange;
    exports.TextSelection = TextSelection;
    exports.Transaction = Transaction;
  }
});

// node_modules/w3c-keyname/index.cjs
var require_w3c_keyname = __commonJS({
  "node_modules/w3c-keyname/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base = {
      8: "Backspace",
      9: "Tab",
      10: "Enter",
      12: "NumLock",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      44: "PrintScreen",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Meta",
      92: "Meta",
      106: "*",
      107: "+",
      108: ",",
      109: "-",
      110: ".",
      111: "/",
      144: "NumLock",
      145: "ScrollLock",
      160: "Shift",
      161: "Shift",
      162: "Control",
      163: "Control",
      164: "Alt",
      165: "Alt",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'"
    };
    var shift = {
      48: ")",
      49: "!",
      50: "@",
      51: "#",
      52: "$",
      53: "%",
      54: "^",
      55: "&",
      56: "*",
      57: "(",
      59: ":",
      61: "+",
      173: "_",
      186: ":",
      187: "+",
      188: "<",
      189: "_",
      190: ">",
      191: "?",
      192: "~",
      219: "{",
      220: "|",
      221: "}",
      222: '"'
    };
    var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
    var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
    var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
    var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    var brokenModifierNames = mac || chrome && +chrome[1] < 57;
    for (i = 0; i < 10; i++)
      base[48 + i] = base[96 + i] = String(i);
    var i;
    for (i = 1; i <= 24; i++)
      base[i + 111] = "F" + i;
    var i;
    for (i = 65; i <= 90; i++) {
      base[i] = String.fromCharCode(i + 32);
      shift[i] = String.fromCharCode(i);
    }
    var i;
    for (code in base)
      if (!shift.hasOwnProperty(code))
        shift[code] = base[code];
    var code;
    function keyName(event) {
      var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
      var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
      if (name == "Esc")
        name = "Escape";
      if (name == "Del")
        name = "Delete";
      if (name == "Left")
        name = "ArrowLeft";
      if (name == "Up")
        name = "ArrowUp";
      if (name == "Right")
        name = "ArrowRight";
      if (name == "Down")
        name = "ArrowDown";
      return name;
    }
    exports.base = base;
    exports.keyName = keyName;
    exports.shift = shift;
  }
});

// node_modules/prosemirror-keymap/dist/index.cjs
var require_dist5 = __commonJS({
  "node_modules/prosemirror-keymap/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var w3cKeyname = require_w3c_keyname();
    var prosemirrorState = require_dist4();
    var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
    function normalizeKeyName(name) {
      var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
      if (result == "Space")
        result = " ";
      var alt, ctrl, shift, meta;
      for (var i = 0; i < parts.length - 1; i++) {
        var mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
          meta = true;
        else if (/^a(lt)?$/i.test(mod))
          alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
          ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
          shift = true;
        else if (/^mod$/i.test(mod)) {
          if (mac)
            meta = true;
          else
            ctrl = true;
        } else
          throw new Error("Unrecognized modifier name: " + mod);
      }
      if (alt)
        result = "Alt-" + result;
      if (ctrl)
        result = "Ctrl-" + result;
      if (meta)
        result = "Meta-" + result;
      if (shift)
        result = "Shift-" + result;
      return result;
    }
    function normalize(map) {
      var copy = /* @__PURE__ */ Object.create(null);
      for (var prop in map) {
        copy[normalizeKeyName(prop)] = map[prop];
      }
      return copy;
    }
    function modifiers(name, event, shift) {
      if (event.altKey)
        name = "Alt-" + name;
      if (event.ctrlKey)
        name = "Ctrl-" + name;
      if (event.metaKey)
        name = "Meta-" + name;
      if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
      return name;
    }
    function keymap(bindings) {
      return new prosemirrorState.Plugin({
        props: {
          handleKeyDown: keydownHandler(bindings)
        }
      });
    }
    function keydownHandler(bindings) {
      var map = normalize(bindings);
      return function(view, event) {
        var name = w3cKeyname.keyName(event), isChar = name.length == 1 && name != " ", baseName;
        var direct = map[modifiers(name, event, !isChar)];
        if (direct && direct(view.state, view.dispatch, view))
          return true;
        if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
          var fromCode = map[modifiers(baseName, event, true)];
          if (fromCode && fromCode(view.state, view.dispatch, view))
            return true;
        } else if (isChar && event.shiftKey) {
          var withShift = map[modifiers(name, event, true)];
          if (withShift && withShift(view.state, view.dispatch, view))
            return true;
        }
        return false;
      };
    }
    exports.keydownHandler = keydownHandler;
    exports.keymap = keymap;
  }
});

// node_modules/prosemirror-view/dist/index.cjs
var require_dist6 = __commonJS({
  "node_modules/prosemirror-view/dist/index.cjs"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _get() {
      if (typeof Reflect !== "undefined" && Reflect.get) {
        _get = Reflect.get;
      } else {
        _get = function _get2(target, property, receiver) {
          var base = _superPropBase(target, property);
          if (!base)
            return;
          var desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.get) {
            return desc.get.call(arguments.length < 3 ? target : receiver);
          }
          return desc.value;
        };
      }
      return _get.apply(this, arguments);
    }
    function _superPropBase(object, property) {
      while (!Object.prototype.hasOwnProperty.call(object, property)) {
        object = _getPrototypeOf(object);
        if (object === null)
          break;
      }
      return object;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var prosemirrorState = require_dist4();
    var prosemirrorModel = require_dist2();
    var prosemirrorTransform = require_dist3();
    var domIndex = function domIndex2(node) {
      for (var index = 0; ; index++) {
        node = node.previousSibling;
        if (!node)
          return index;
      }
    };
    var parentNode = function parentNode2(node) {
      var parent = node.assignedSlot || node.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent;
    };
    var reusedRange = null;
    var textRange = function textRange2(node, from, to) {
      var range = reusedRange || (reusedRange = document.createRange());
      range.setEnd(node, to == null ? node.nodeValue.length : to);
      range.setStart(node, from || 0);
      return range;
    };
    var isEquivalentPosition = function isEquivalentPosition2(node, off, targetNode, targetOff) {
      return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
    };
    var atomElements = /^(img|br|input|textarea|hr)$/i;
    function scanFor(node, off, targetNode, targetOff, dir) {
      for (; ; ) {
        if (node == targetNode && off == targetOff)
          return true;
        if (off == (dir < 0 ? 0 : nodeSize(node))) {
          var parent = node.parentNode;
          if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
            return false;
          off = domIndex(node) + (dir < 0 ? 0 : 1);
          node = parent;
        } else if (node.nodeType == 1) {
          node = node.childNodes[off + (dir < 0 ? -1 : 0)];
          if (node.contentEditable == "false")
            return false;
          off = dir < 0 ? nodeSize(node) : 0;
        } else {
          return false;
        }
      }
    }
    function nodeSize(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function isOnEdge(node, offset, parent) {
      for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {
        if (node == parent)
          return true;
        var index = domIndex(node);
        node = node.parentNode;
        if (!node)
          return false;
        atStart = atStart && index == 0;
        atEnd = atEnd && index == nodeSize(node);
      }
    }
    function hasBlockDesc(dom) {
      var desc;
      for (var cur = dom; cur; cur = cur.parentNode) {
        if (desc = cur.pmViewDesc)
          break;
      }
      return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
    }
    var selectionCollapsed = function selectionCollapsed2(domSel) {
      return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
    };
    function keyEvent(keyCode, key) {
      var event = document.createEvent("Event");
      event.initEvent("keydown", true, true);
      event.keyCode = keyCode;
      event.key = event.code = key;
      return event;
    }
    function deepActiveElement(doc2) {
      var elt = doc2.activeElement;
      while (elt && elt.shadowRoot) {
        elt = elt.shadowRoot.activeElement;
      }
      return elt;
    }
    var nav = typeof navigator != "undefined" ? navigator : null;
    var doc = typeof document != "undefined" ? document : null;
    var agent = nav && nav.userAgent || "";
    var ie_edge = /Edge\/(\d+)/.exec(agent);
    var ie_upto10 = /MSIE \d/.exec(agent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
    var ie = !!(ie_upto10 || ie_11up || ie_edge);
    var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
    var gecko = !ie && /gecko\/(\d+)/i.test(agent);
    gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
    var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
    var chrome = !!_chrome;
    var chrome_version = _chrome ? +_chrome[1] : 0;
    var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
    var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
    var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
    var android = /Android \d/.test(agent);
    var webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
    var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
    function windowRect(doc2) {
      return {
        left: 0,
        right: doc2.documentElement.clientWidth,
        top: 0,
        bottom: doc2.documentElement.clientHeight
      };
    }
    function getSide(value, side) {
      return typeof value == "number" ? value : value[side];
    }
    function clientRect(node) {
      var rect = node.getBoundingClientRect();
      var scaleX = rect.width / node.offsetWidth || 1;
      var scaleY = rect.height / node.offsetHeight || 1;
      return {
        left: rect.left,
        right: rect.left + node.clientWidth * scaleX,
        top: rect.top,
        bottom: rect.top + node.clientHeight * scaleY
      };
    }
    function scrollRectIntoView(view, rect, startDOM) {
      var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
      var doc2 = view.dom.ownerDocument;
      for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
        if (!parent)
          break;
        if (parent.nodeType != 1)
          continue;
        var elt = parent;
        var atTop = elt == doc2.body;
        var bounding = atTop ? windowRect(doc2) : clientRect(elt);
        var moveX = 0, moveY = 0;
        if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
          moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
          moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
        if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
          moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
        else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
          moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
        if (moveX || moveY) {
          if (atTop) {
            doc2.defaultView.scrollBy(moveX, moveY);
          } else {
            var startX = elt.scrollLeft, startY = elt.scrollTop;
            if (moveY)
              elt.scrollTop += moveY;
            if (moveX)
              elt.scrollLeft += moveX;
            var dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
            rect = {
              left: rect.left - dX,
              top: rect.top - dY,
              right: rect.right - dX,
              bottom: rect.bottom - dY
            };
          }
        }
        if (atTop)
          break;
      }
    }
    function storeScrollPos(view) {
      var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
      var refDOM, refTop;
      for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
        var dom = view.root.elementFromPoint(x, y);
        if (!dom || dom == view.dom || !view.dom.contains(dom))
          continue;
        var localRect = dom.getBoundingClientRect();
        if (localRect.top >= startY - 20) {
          refDOM = dom;
          refTop = localRect.top;
          break;
        }
      }
      return {
        refDOM,
        refTop,
        stack: scrollStack(view.dom)
      };
    }
    function scrollStack(dom) {
      var stack = [], doc2 = dom.ownerDocument;
      for (var cur = dom; cur; cur = parentNode(cur)) {
        stack.push({
          dom: cur,
          top: cur.scrollTop,
          left: cur.scrollLeft
        });
        if (dom == doc2)
          break;
      }
      return stack;
    }
    function resetScrollPos(_ref) {
      var refDOM = _ref.refDOM, refTop = _ref.refTop, stack = _ref.stack;
      var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
      restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
    }
    function restoreScrollStack(stack, dTop) {
      for (var i = 0; i < stack.length; i++) {
        var _stack$i = stack[i], dom = _stack$i.dom, top = _stack$i.top, left = _stack$i.left;
        if (dom.scrollTop != top + dTop)
          dom.scrollTop = top + dTop;
        if (dom.scrollLeft != left)
          dom.scrollLeft = left;
      }
    }
    var preventScrollSupported = null;
    function focusPreventScroll(dom) {
      if (dom.setActive)
        return dom.setActive();
      if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
      var stored = scrollStack(dom);
      dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
          preventScrollSupported = {
            preventScroll: true
          };
          return true;
        }
      } : void 0);
      if (!preventScrollSupported) {
        preventScrollSupported = false;
        restoreScrollStack(stored, 0);
      }
    }
    function findOffsetInNode(node, coords) {
      var closest, dxClosest = 2e8, coordsClosest, offset = 0;
      var rowBot = coords.top, rowTop = coords.top;
      for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
        var rects = void 0;
        if (child.nodeType == 1)
          rects = child.getClientRects();
        else if (child.nodeType == 3)
          rects = textRange(child).getClientRects();
        else
          continue;
        for (var i = 0; i < rects.length; i++) {
          var rect = rects[i];
          if (rect.top <= rowBot && rect.bottom >= rowTop) {
            rowBot = Math.max(rect.bottom, rowBot);
            rowTop = Math.min(rect.top, rowTop);
            var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
            if (dx < dxClosest) {
              closest = child;
              dxClosest = dx;
              coordsClosest = dx && closest.nodeType == 3 ? {
                left: rect.right < coords.left ? rect.right : rect.left,
                top: coords.top
              } : coords;
              if (child.nodeType == 1 && dx)
                offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
              continue;
            }
          }
          if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
            offset = childIndex + 1;
        }
      }
      if (closest && closest.nodeType == 3)
        return findOffsetInText(closest, coordsClosest);
      if (!closest || dxClosest && closest.nodeType == 1)
        return {
          node,
          offset
        };
      return findOffsetInNode(closest, coordsClosest);
    }
    function findOffsetInText(node, coords) {
      var len = node.nodeValue.length;
      var range = document.createRange();
      for (var i = 0; i < len; i++) {
        range.setEnd(node, i + 1);
        range.setStart(node, i);
        var rect = singleRect(range, 1);
        if (rect.top == rect.bottom)
          continue;
        if (inRect(coords, rect))
          return {
            node,
            offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)
          };
      }
      return {
        node,
        offset: 0
      };
    }
    function inRect(coords, rect) {
      return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
    }
    function targetKludge(dom, coords) {
      var parent = dom.parentNode;
      if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
        return parent;
      return dom;
    }
    function posFromElement(view, elt, coords) {
      var _findOffsetInNode = findOffsetInNode(elt, coords), node = _findOffsetInNode.node, offset = _findOffsetInNode.offset, bias = -1;
      if (node.nodeType == 1 && !node.firstChild) {
        var rect = node.getBoundingClientRect();
        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
      }
      return view.docView.posFromDOM(node, offset, bias);
    }
    function posFromCaret(view, node, offset, coords) {
      var outside = -1;
      for (var cur = node; ; ) {
        if (cur == view.dom)
          break;
        var desc = view.docView.nearestDesc(cur, true);
        if (!desc)
          return null;
        if (desc.node.isBlock && desc.parent) {
          var rect = desc.dom.getBoundingClientRect();
          if (rect.left > coords.left || rect.top > coords.top)
            outside = desc.posBefore;
          else if (rect.right < coords.left || rect.bottom < coords.top)
            outside = desc.posAfter;
          else
            break;
        }
        cur = desc.dom.parentNode;
      }
      return outside > -1 ? outside : view.docView.posFromDOM(node, offset, 1);
    }
    function elementFromPoint(element, coords, box) {
      var len = element.childNodes.length;
      if (len && box.top < box.bottom) {
        for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
          var child = element.childNodes[i];
          if (child.nodeType == 1) {
            var rects = child.getClientRects();
            for (var j = 0; j < rects.length; j++) {
              var rect = rects[j];
              if (inRect(coords, rect))
                return elementFromPoint(child, coords, rect);
            }
          }
          if ((i = (i + 1) % len) == startI)
            break;
        }
      }
      return element;
    }
    function _posAtCoords(view, coords) {
      var doc2 = view.dom.ownerDocument, node, offset = 0;
      if (doc2.caretPositionFromPoint) {
        try {
          var _pos = doc2.caretPositionFromPoint(coords.left, coords.top);
          if (_pos) {
            node = _pos.offsetNode;
            offset = _pos.offset;
          }
        } catch (_) {
        }
      }
      if (!node && doc2.caretRangeFromPoint) {
        var range = doc2.caretRangeFromPoint(coords.left, coords.top);
        if (range) {
          node = range.startContainer;
          offset = range.startOffset;
        }
      }
      var elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
      var pos;
      if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
        var box = view.dom.getBoundingClientRect();
        if (!inRect(coords, box))
          return null;
        elt = elementFromPoint(view.dom, coords, box);
        if (!elt)
          return null;
      }
      if (safari) {
        for (var p = elt; node && p; p = parentNode(p)) {
          if (p.draggable)
            node = void 0;
        }
      }
      elt = targetKludge(elt, coords);
      if (node) {
        if (gecko && node.nodeType == 1) {
          offset = Math.min(offset, node.childNodes.length);
          if (offset < node.childNodes.length) {
            var next = node.childNodes[offset], _box;
            if (next.nodeName == "IMG" && (_box = next.getBoundingClientRect()).right <= coords.left && _box.bottom > coords.top)
              offset++;
          }
        }
        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
          pos = view.state.doc.content.size;
        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
          pos = posFromCaret(view, node, offset, coords);
      }
      if (pos == null)
        pos = posFromElement(view, elt, coords);
      var desc = view.docView.nearestDesc(elt, true);
      return {
        pos,
        inside: desc ? desc.posAtStart - desc.border : -1
      };
    }
    function singleRect(target, bias) {
      var rects = target.getClientRects();
      return !rects.length ? target.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
    }
    var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    function _coordsAtPos(view, pos, side) {
      var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1), node = _view$docView$domFrom.node, offset = _view$docView$domFrom.offset, atom = _view$docView$domFrom.atom;
      var supportEmptyRange = webkit || gecko;
      if (node.nodeType == 3) {
        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
          var rect = singleRect(textRange(node, offset, offset), side);
          if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
            var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
            if (rectBefore.top == rect.top) {
              var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
              if (rectAfter.top != rect.top)
                return flattenV(rectAfter, rectAfter.left < rectBefore.left);
            }
          }
          return rect;
        } else {
          var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
          if (side < 0 && !offset) {
            to++;
            takeSide = -1;
          } else if (side >= 0 && offset == node.nodeValue.length) {
            from--;
            takeSide = 1;
          } else if (side < 0) {
            from--;
          } else {
            to++;
          }
          return flattenV(singleRect(textRange(node, from, to), 1), takeSide < 0);
        }
      }
      var $dom = view.state.doc.resolve(pos - (atom || 0));
      if (!$dom.parent.inlineContent) {
        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
          var before = node.childNodes[offset - 1];
          if (before.nodeType == 1)
            return flattenH(before.getBoundingClientRect(), false);
        }
        if (atom == null && offset < nodeSize(node)) {
          var after = node.childNodes[offset];
          if (after.nodeType == 1)
            return flattenH(after.getBoundingClientRect(), true);
        }
        return flattenH(node.getBoundingClientRect(), side >= 0);
      }
      if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
        var _before = node.childNodes[offset - 1];
        var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1)) : _before.nodeType == 1 && (_before.nodeName != "BR" || !_before.nextSibling) ? _before : null;
        if (target)
          return flattenV(singleRect(target, 1), false);
      }
      if (atom == null && offset < nodeSize(node)) {
        var _after = node.childNodes[offset];
        while (_after.pmViewDesc && _after.pmViewDesc.ignoreForCoords) {
          _after = _after.nextSibling;
        }
        var _target = !_after ? null : _after.nodeType == 3 ? textRange(_after, 0, supportEmptyRange ? 0 : 1) : _after.nodeType == 1 ? _after : null;
        if (_target)
          return flattenV(singleRect(_target, -1), true);
      }
      return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
    }
    function flattenV(rect, left) {
      if (rect.width == 0)
        return rect;
      var x = left ? rect.left : rect.right;
      return {
        top: rect.top,
        bottom: rect.bottom,
        left: x,
        right: x
      };
    }
    function flattenH(rect, top) {
      if (rect.height == 0)
        return rect;
      var y = top ? rect.top : rect.bottom;
      return {
        top: y,
        bottom: y,
        left: rect.left,
        right: rect.right
      };
    }
    function withFlushedState(view, state, f) {
      var viewState = view.state, active = view.root.activeElement;
      if (viewState != state)
        view.updateState(state);
      if (active != view.dom)
        view.focus();
      try {
        return f();
      } finally {
        if (viewState != state)
          view.updateState(viewState);
        if (active != view.dom && active)
          active.focus();
      }
    }
    function endOfTextblockVertical(view, state, dir) {
      var sel = state.selection;
      var $pos = dir == "up" ? sel.$from : sel.$to;
      return withFlushedState(view, state, function() {
        var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1), dom = _view$docView$domFrom2.node;
        for (; ; ) {
          var nearest = view.docView.nearestDesc(dom, true);
          if (!nearest)
            break;
          if (nearest.node.isBlock) {
            dom = nearest.dom;
            break;
          }
          dom = nearest.dom.parentNode;
        }
        var coords = _coordsAtPos(view, $pos.pos, 1);
        for (var child = dom.firstChild; child; child = child.nextSibling) {
          var boxes = void 0;
          if (child.nodeType == 1)
            boxes = child.getClientRects();
          else if (child.nodeType == 3)
            boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
          else
            continue;
          for (var i = 0; i < boxes.length; i++) {
            var box = boxes[i];
            if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
              return false;
          }
        }
        return true;
      });
    }
    var maybeRTL = /[\u0590-\u08ac]/;
    function endOfTextblockHorizontal(view, state, dir) {
      var $head = state.selection.$head;
      if (!$head.parent.isTextblock)
        return false;
      var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
      var sel = view.domSelection();
      if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
        return dir == "left" || dir == "backward" ? atStart : atEnd;
      return withFlushedState(view, state, function() {
        var _view$domSelectionRan = view.domSelectionRange(), oldNode = _view$domSelectionRan.focusNode, oldOff = _view$domSelectionRan.focusOffset, anchorNode = _view$domSelectionRan.anchorNode, anchorOffset = _view$domSelectionRan.anchorOffset;
        var oldBidiLevel = sel.caretBidiLevel;
        sel.modify("move", dir, "character");
        var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
        var _view$domSelectionRan2 = view.domSelectionRange(), newNode = _view$domSelectionRan2.focusNode, newOff = _view$domSelectionRan2.focusOffset;
        var result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
        try {
          sel.collapse(anchorNode, anchorOffset);
          if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
            sel.extend(oldNode, oldOff);
        } catch (_) {
        }
        if (oldBidiLevel != null)
          sel.caretBidiLevel = oldBidiLevel;
        return result;
      });
    }
    var cachedState = null;
    var cachedDir = null;
    var cachedResult = false;
    function _endOfTextblock(view, state, dir) {
      if (cachedState == state && cachedDir == dir)
        return cachedResult;
      cachedState = state;
      cachedDir = dir;
      return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
    }
    var NOT_DIRTY = 0;
    var CHILD_DIRTY = 1;
    var CONTENT_DIRTY = 2;
    var NODE_DIRTY = 3;
    var ViewDesc = function() {
      function ViewDesc2(parent, children, dom, contentDOM) {
        _classCallCheck(this, ViewDesc2);
        this.parent = parent;
        this.children = children;
        this.dom = dom;
        this.contentDOM = contentDOM;
        this.dirty = NOT_DIRTY;
        dom.pmViewDesc = this;
      }
      _createClass(ViewDesc2, [{
        key: "matchesWidget",
        value: function matchesWidget(widget) {
          return false;
        }
      }, {
        key: "matchesMark",
        value: function matchesMark(mark) {
          return false;
        }
      }, {
        key: "matchesNode",
        value: function matchesNode(node, outerDeco, innerDeco) {
          return false;
        }
      }, {
        key: "matchesHack",
        value: function matchesHack(nodeName) {
          return false;
        }
      }, {
        key: "parseRule",
        value: function parseRule() {
          return null;
        }
      }, {
        key: "stopEvent",
        value: function stopEvent(event) {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          var size = 0;
          for (var i = 0; i < this.children.length; i++) {
            size += this.children[i].size;
          }
          return size;
        }
      }, {
        key: "border",
        get: function get() {
          return 0;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.parent = void 0;
          if (this.dom.pmViewDesc == this)
            this.dom.pmViewDesc = void 0;
          for (var i = 0; i < this.children.length; i++) {
            this.children[i].destroy();
          }
        }
      }, {
        key: "posBeforeChild",
        value: function posBeforeChild(child) {
          for (var i = 0, pos = this.posAtStart; ; i++) {
            var cur = this.children[i];
            if (cur == child)
              return pos;
            pos += cur.size;
          }
        }
      }, {
        key: "posBefore",
        get: function get() {
          return this.parent.posBeforeChild(this);
        }
      }, {
        key: "posAtStart",
        get: function get() {
          return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
        }
      }, {
        key: "posAfter",
        get: function get() {
          return this.posBefore + this.size;
        }
      }, {
        key: "posAtEnd",
        get: function get() {
          return this.posAtStart + this.size - 2 * this.border;
        }
      }, {
        key: "localPosFromDOM",
        value: function localPosFromDOM(dom, offset, bias) {
          if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
            if (bias < 0) {
              var domBefore, desc;
              if (dom == this.contentDOM) {
                domBefore = dom.childNodes[offset - 1];
              } else {
                while (dom.parentNode != this.contentDOM) {
                  dom = dom.parentNode;
                }
                domBefore = dom.previousSibling;
              }
              while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
                domBefore = domBefore.previousSibling;
              }
              return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
            } else {
              var domAfter, _desc;
              if (dom == this.contentDOM) {
                domAfter = dom.childNodes[offset];
              } else {
                while (dom.parentNode != this.contentDOM) {
                  dom = dom.parentNode;
                }
                domAfter = dom.nextSibling;
              }
              while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this)) {
                domAfter = domAfter.nextSibling;
              }
              return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;
            }
          }
          var atEnd;
          if (dom == this.dom && this.contentDOM) {
            atEnd = offset > domIndex(this.contentDOM);
          } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
          } else if (this.dom.firstChild) {
            if (offset == 0)
              for (var search = dom; ; search = search.parentNode) {
                if (search == this.dom) {
                  atEnd = false;
                  break;
                }
                if (search.previousSibling)
                  break;
              }
            if (atEnd == null && offset == dom.childNodes.length)
              for (var _search = dom; ; _search = _search.parentNode) {
                if (_search == this.dom) {
                  atEnd = true;
                  break;
                }
                if (_search.nextSibling)
                  break;
              }
          }
          return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
        }
      }, {
        key: "nearestDesc",
        value: function nearestDesc(dom) {
          var onlyNodes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          for (var first = true, cur = dom; cur; cur = cur.parentNode) {
            var desc = this.getDesc(cur), nodeDOM = void 0;
            if (desc && (!onlyNodes || desc.node)) {
              if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
                first = false;
              else
                return desc;
            }
          }
        }
      }, {
        key: "getDesc",
        value: function getDesc(dom) {
          var desc = dom.pmViewDesc;
          for (var cur = desc; cur; cur = cur.parent) {
            if (cur == this)
              return desc;
          }
        }
      }, {
        key: "posFromDOM",
        value: function posFromDOM(dom, offset, bias) {
          for (var scan = dom; scan; scan = scan.parentNode) {
            var desc = this.getDesc(scan);
            if (desc)
              return desc.localPosFromDOM(dom, offset, bias);
          }
          return -1;
        }
      }, {
        key: "descAt",
        value: function descAt(pos) {
          for (var i = 0, offset = 0; i < this.children.length; i++) {
            var child = this.children[i], end = offset + child.size;
            if (offset == pos && end != offset) {
              while (!child.border && child.children.length) {
                child = child.children[0];
              }
              return child;
            }
            if (pos < end)
              return child.descAt(pos - offset - child.border);
            offset = end;
          }
        }
      }, {
        key: "domFromPos",
        value: function domFromPos(pos, side) {
          if (!this.contentDOM)
            return {
              node: this.dom,
              offset: 0,
              atom: pos + 1
            };
          var i = 0, offset = 0;
          for (var curPos = 0; i < this.children.length; i++) {
            var child = this.children[i], end = curPos + child.size;
            if (end > pos || child instanceof TrailingHackViewDesc) {
              offset = pos - curPos;
              break;
            }
            curPos = end;
          }
          if (offset)
            return this.children[i].domFromPos(offset - this.children[i].border, side);
          for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
          }
          if (side <= 0) {
            var _prev, enter = true;
            for (; ; i--, enter = false) {
              _prev = i ? this.children[i - 1] : null;
              if (!_prev || _prev.dom.parentNode == this.contentDOM)
                break;
            }
            if (_prev && side && enter && !_prev.border && !_prev.domAtom)
              return _prev.domFromPos(_prev.size, side);
            return {
              node: this.contentDOM,
              offset: _prev ? domIndex(_prev.dom) + 1 : 0
            };
          } else {
            var next, _enter = true;
            for (; ; i++, _enter = false) {
              next = i < this.children.length ? this.children[i] : null;
              if (!next || next.dom.parentNode == this.contentDOM)
                break;
            }
            if (next && _enter && !next.border && !next.domAtom)
              return next.domFromPos(0, side);
            return {
              node: this.contentDOM,
              offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length
            };
          }
        }
      }, {
        key: "parseRange",
        value: function parseRange(from, to) {
          var base = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          if (this.children.length == 0)
            return {
              node: this.contentDOM,
              from,
              to,
              fromOffset: 0,
              toOffset: this.contentDOM.childNodes.length
            };
          var fromOffset = -1, toOffset = -1;
          for (var offset = base, i = 0; ; i++) {
            var child = this.children[i], end = offset + child.size;
            if (fromOffset == -1 && from <= end) {
              var childBase = offset + child.border;
              if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
                return child.parseRange(from, to, childBase);
              from = offset;
              for (var j = i; j > 0; j--) {
                var prev = this.children[j - 1];
                if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
                  fromOffset = domIndex(prev.dom) + 1;
                  break;
                }
                from -= prev.size;
              }
              if (fromOffset == -1)
                fromOffset = 0;
            }
            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
              to = end;
              for (var _j = i + 1; _j < this.children.length; _j++) {
                var next = this.children[_j];
                if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
                  toOffset = domIndex(next.dom);
                  break;
                }
                to += next.size;
              }
              if (toOffset == -1)
                toOffset = this.contentDOM.childNodes.length;
              break;
            }
            offset = end;
          }
          return {
            node: this.contentDOM,
            from,
            to,
            fromOffset,
            toOffset
          };
        }
      }, {
        key: "emptyChildAt",
        value: function emptyChildAt(side) {
          if (this.border || !this.contentDOM || !this.children.length)
            return false;
          var child = this.children[side < 0 ? 0 : this.children.length - 1];
          return child.size == 0 || child.emptyChildAt(side);
        }
      }, {
        key: "domAfterPos",
        value: function domAfterPos(pos) {
          var _this$domFromPos = this.domFromPos(pos, 0), node = _this$domFromPos.node, offset = _this$domFromPos.offset;
          if (node.nodeType != 1 || offset == node.childNodes.length)
            throw new RangeError("No node after pos " + pos);
          return node.childNodes[offset];
        }
      }, {
        key: "setSelection",
        value: function setSelection(anchor, head, root) {
          var force = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
          var from = Math.min(anchor, head), to = Math.max(anchor, head);
          for (var i = 0, offset = 0; i < this.children.length; i++) {
            var child = this.children[i], end = offset + child.size;
            if (from > offset && to < end)
              return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
            offset = end;
          }
          var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
          var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
          var domSel = root.getSelection();
          var brKludge = false;
          if ((gecko || safari) && anchor == head) {
            var _anchorDOM = anchorDOM, node = _anchorDOM.node, _offset = _anchorDOM.offset;
            if (node.nodeType == 3) {
              brKludge = !!(_offset && node.nodeValue[_offset - 1] == "\n");
              if (brKludge && _offset == node.nodeValue.length) {
                for (var scan = node, after; scan; scan = scan.parentNode) {
                  if (after = scan.nextSibling) {
                    if (after.nodeName == "BR")
                      anchorDOM = headDOM = {
                        node: after.parentNode,
                        offset: domIndex(after) + 1
                      };
                    break;
                  }
                  var desc = scan.pmViewDesc;
                  if (desc && desc.node && desc.node.isBlock)
                    break;
                }
              }
            } else {
              var prev = node.childNodes[_offset - 1];
              brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
            }
          }
          if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
            var _after2 = domSel.focusNode.childNodes[domSel.focusOffset];
            if (_after2 && _after2.contentEditable == "false")
              force = true;
          }
          if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
            return;
          var domSelExtended = false;
          if ((domSel.extend || anchor == head) && !brKludge) {
            domSel.collapse(anchorDOM.node, anchorDOM.offset);
            try {
              if (anchor != head)
                domSel.extend(headDOM.node, headDOM.offset);
              domSelExtended = true;
            } catch (_) {
            }
          }
          if (!domSelExtended) {
            if (anchor > head) {
              var tmp = anchorDOM;
              anchorDOM = headDOM;
              headDOM = tmp;
            }
            var range = document.createRange();
            range.setEnd(headDOM.node, headDOM.offset);
            range.setStart(anchorDOM.node, anchorDOM.offset);
            domSel.removeAllRanges();
            domSel.addRange(range);
          }
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return !this.contentDOM && mutation.type != "selection";
        }
      }, {
        key: "contentLost",
        get: function get() {
          return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
        }
      }, {
        key: "markDirty",
        value: function markDirty(from, to) {
          for (var offset = 0, i = 0; i < this.children.length; i++) {
            var child = this.children[i], end = offset + child.size;
            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
              var startInside = offset + child.border, endInside = end - child.border;
              if (from >= startInside && to <= endInside) {
                this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
                if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
                  child.dirty = NODE_DIRTY;
                else
                  child.markDirty(from - startInside, to - startInside);
                return;
              } else {
                child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
              }
            }
            offset = end;
          }
          this.dirty = CONTENT_DIRTY;
        }
      }, {
        key: "markParentsDirty",
        value: function markParentsDirty() {
          var level = 1;
          for (var node = this.parent; node; node = node.parent, level++) {
            var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
            if (node.dirty < dirty)
              node.dirty = dirty;
          }
        }
      }, {
        key: "domAtom",
        get: function get() {
          return false;
        }
      }, {
        key: "ignoreForCoords",
        get: function get() {
          return false;
        }
      }]);
      return ViewDesc2;
    }();
    var WidgetViewDesc = function(_ViewDesc) {
      _inherits(WidgetViewDesc2, _ViewDesc);
      var _super = _createSuper(WidgetViewDesc2);
      function WidgetViewDesc2(parent, widget, view, pos) {
        var _this;
        _classCallCheck(this, WidgetViewDesc2);
        var self, dom = widget.type.toDOM;
        if (typeof dom == "function")
          dom = dom(view, function() {
            if (!self)
              return pos;
            if (self.parent)
              return self.parent.posBeforeChild(self);
          });
        if (!widget.type.spec.raw) {
          if (dom.nodeType != 1) {
            var wrap = document.createElement("span");
            wrap.appendChild(dom);
            dom = wrap;
          }
          dom.contentEditable = "false";
          dom.classList.add("ProseMirror-widget");
        }
        _this = _super.call(this, parent, [], dom, null);
        _this.widget = widget;
        _this.widget = widget;
        self = _assertThisInitialized(_this);
        return _this;
      }
      _createClass(WidgetViewDesc2, [{
        key: "matchesWidget",
        value: function matchesWidget(widget) {
          return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
        }
      }, {
        key: "parseRule",
        value: function parseRule() {
          return {
            ignore: true
          };
        }
      }, {
        key: "stopEvent",
        value: function stopEvent(event) {
          var stop = this.widget.spec.stopEvent;
          return stop ? stop(event) : false;
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return mutation.type != "selection" || this.widget.spec.ignoreSelection;
        }
      }, {
        key: "destroy",
        value: function destroy() {
          this.widget.type.destroy(this.dom);
          _get(_getPrototypeOf(WidgetViewDesc2.prototype), "destroy", this).call(this);
        }
      }, {
        key: "domAtom",
        get: function get() {
          return true;
        }
      }, {
        key: "side",
        get: function get() {
          return this.widget.type.side;
        }
      }]);
      return WidgetViewDesc2;
    }(ViewDesc);
    var CompositionViewDesc = function(_ViewDesc2) {
      _inherits(CompositionViewDesc2, _ViewDesc2);
      var _super2 = _createSuper(CompositionViewDesc2);
      function CompositionViewDesc2(parent, dom, textDOM, text) {
        var _this2;
        _classCallCheck(this, CompositionViewDesc2);
        _this2 = _super2.call(this, parent, [], dom, null);
        _this2.textDOM = textDOM;
        _this2.text = text;
        return _this2;
      }
      _createClass(CompositionViewDesc2, [{
        key: "size",
        get: function get() {
          return this.text.length;
        }
      }, {
        key: "localPosFromDOM",
        value: function localPosFromDOM(dom, offset) {
          if (dom != this.textDOM)
            return this.posAtStart + (offset ? this.size : 0);
          return this.posAtStart + offset;
        }
      }, {
        key: "domFromPos",
        value: function domFromPos(pos) {
          return {
            node: this.textDOM,
            offset: pos
          };
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mut) {
          return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
        }
      }]);
      return CompositionViewDesc2;
    }(ViewDesc);
    var MarkViewDesc = function(_ViewDesc3) {
      _inherits(MarkViewDesc2, _ViewDesc3);
      var _super3 = _createSuper(MarkViewDesc2);
      function MarkViewDesc2(parent, mark, dom, contentDOM) {
        var _this3;
        _classCallCheck(this, MarkViewDesc2);
        _this3 = _super3.call(this, parent, [], dom, contentDOM);
        _this3.mark = mark;
        return _this3;
      }
      _createClass(MarkViewDesc2, [{
        key: "parseRule",
        value: function parseRule() {
          if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
            return null;
          return {
            mark: this.mark.type.name,
            attrs: this.mark.attrs,
            contentElement: this.contentDOM || void 0
          };
        }
      }, {
        key: "matchesMark",
        value: function matchesMark(mark) {
          return this.dirty != NODE_DIRTY && this.mark.eq(mark);
        }
      }, {
        key: "markDirty",
        value: function markDirty(from, to) {
          _get(_getPrototypeOf(MarkViewDesc2.prototype), "markDirty", this).call(this, from, to);
          if (this.dirty != NOT_DIRTY) {
            var parent = this.parent;
            while (!parent.node) {
              parent = parent.parent;
            }
            if (parent.dirty < this.dirty)
              parent.dirty = this.dirty;
            this.dirty = NOT_DIRTY;
          }
        }
      }, {
        key: "slice",
        value: function slice(from, to, view) {
          var copy = MarkViewDesc2.create(this.parent, this.mark, true, view);
          var nodes = this.children, size = this.size;
          if (to < size)
            nodes = replaceNodes(nodes, to, size, view);
          if (from > 0)
            nodes = replaceNodes(nodes, 0, from, view);
          for (var i = 0; i < nodes.length; i++) {
            nodes[i].parent = copy;
          }
          copy.children = nodes;
          return copy;
        }
      }], [{
        key: "create",
        value: function create(parent, mark, inline, view) {
          var custom = view.nodeViews[mark.type.name];
          var spec = custom && custom(mark, view, inline);
          if (!spec || !spec.dom)
            spec = prosemirrorModel.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
          return new MarkViewDesc2(parent, mark, spec.dom, spec.contentDOM || spec.dom);
        }
      }]);
      return MarkViewDesc2;
    }(ViewDesc);
    var NodeViewDesc = function(_ViewDesc4) {
      _inherits(NodeViewDesc2, _ViewDesc4);
      var _super4 = _createSuper(NodeViewDesc2);
      function NodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
        var _this4;
        _classCallCheck(this, NodeViewDesc2);
        _this4 = _super4.call(this, parent, [], dom, contentDOM);
        _this4.node = node;
        _this4.outerDeco = outerDeco;
        _this4.innerDeco = innerDeco;
        _this4.nodeDOM = nodeDOM;
        if (contentDOM)
          _this4.updateChildren(view, pos);
        return _this4;
      }
      _createClass(NodeViewDesc2, [{
        key: "parseRule",
        value: function parseRule() {
          var _this5 = this;
          if (this.node.type.spec.reparseInView)
            return null;
          var rule = {
            node: this.node.type.name,
            attrs: this.node.attrs
          };
          if (this.node.type.whitespace == "pre")
            rule.preserveWhitespace = "full";
          if (!this.contentDOM) {
            rule.getContent = function() {
              return _this5.node.content;
            };
          } else if (!this.contentLost) {
            rule.contentElement = this.contentDOM;
          } else {
            for (var i = this.children.length - 1; i >= 0; i--) {
              var child = this.children[i];
              if (this.dom.contains(child.dom.parentNode)) {
                rule.contentElement = child.dom.parentNode;
                break;
              }
            }
            if (!rule.contentElement)
              rule.getContent = function() {
                return prosemirrorModel.Fragment.empty;
              };
          }
          return rule;
        }
      }, {
        key: "matchesNode",
        value: function matchesNode(node, outerDeco, innerDeco) {
          return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
        }
      }, {
        key: "size",
        get: function get() {
          return this.node.nodeSize;
        }
      }, {
        key: "border",
        get: function get() {
          return this.node.isLeaf ? 0 : 1;
        }
      }, {
        key: "updateChildren",
        value: function updateChildren(view, pos) {
          var _this6 = this;
          var inline = this.node.inlineContent, off = pos;
          var composition = view.composing ? this.localCompositionInfo(view, pos) : null;
          var localComposition = composition && composition.pos > -1 ? composition : null;
          var compositionInChild = composition && composition.pos < 0;
          var updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
          iterDeco(this.node, this.innerDeco, function(widget, i, insideNode) {
            if (widget.spec.marks)
              updater.syncToMarks(widget.spec.marks, inline, view);
            else if (widget.type.side >= 0 && !insideNode)
              updater.syncToMarks(i == _this6.node.childCount ? prosemirrorModel.Mark.none : _this6.node.child(i).marks, inline, view);
            updater.placeWidget(widget, view, off);
          }, function(child, outerDeco, innerDeco, i) {
            updater.syncToMarks(child.marks, inline, view);
            var compIndex;
            if (updater.findNodeMatch(child, outerDeco, innerDeco, i))
              ;
            else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
              ;
            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i))
              ;
            else {
              updater.addNode(child, outerDeco, innerDeco, view, off);
            }
            off += child.nodeSize;
          });
          updater.syncToMarks([], inline, view);
          if (this.node.isTextblock)
            updater.addTextblockHacks();
          updater.destroyRest();
          if (updater.changed || this.dirty == CONTENT_DIRTY) {
            if (localComposition)
              this.protectLocalComposition(view, localComposition);
            renderDescs(this.contentDOM, this.children, view);
            if (ios)
              iosHacks(this.dom);
          }
        }
      }, {
        key: "localCompositionInfo",
        value: function localCompositionInfo(view, pos) {
          var _view$state$selection = view.state.selection, from = _view$state$selection.from, to = _view$state$selection.to;
          if (!(view.state.selection instanceof prosemirrorState.TextSelection) || from < pos || to > pos + this.node.content.size)
            return null;
          var sel = view.domSelectionRange();
          var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
          if (!textNode || !this.dom.contains(textNode.parentNode))
            return null;
          if (this.node.inlineContent) {
            var text = textNode.nodeValue;
            var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
            return textPos < 0 ? null : {
              node: textNode,
              pos: textPos,
              text
            };
          } else {
            return {
              node: textNode,
              pos: -1,
              text: ""
            };
          }
        }
      }, {
        key: "protectLocalComposition",
        value: function protectLocalComposition(view, _ref2) {
          var node = _ref2.node, pos = _ref2.pos, text = _ref2.text;
          if (this.getDesc(node))
            return;
          var topNode = node;
          for (; ; topNode = topNode.parentNode) {
            if (topNode.parentNode == this.contentDOM)
              break;
            while (topNode.previousSibling) {
              topNode.parentNode.removeChild(topNode.previousSibling);
            }
            while (topNode.nextSibling) {
              topNode.parentNode.removeChild(topNode.nextSibling);
            }
            if (topNode.pmViewDesc)
              topNode.pmViewDesc = void 0;
          }
          var desc = new CompositionViewDesc(this, topNode, node, text);
          view.input.compositionNodes.push(desc);
          this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
        }
      }, {
        key: "update",
        value: function update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
            return false;
          this.updateInner(node, outerDeco, innerDeco, view);
          return true;
        }
      }, {
        key: "updateInner",
        value: function updateInner(node, outerDeco, innerDeco, view) {
          this.updateOuterDeco(outerDeco);
          this.node = node;
          this.innerDeco = innerDeco;
          if (this.contentDOM)
            this.updateChildren(view, this.posAtStart);
          this.dirty = NOT_DIRTY;
        }
      }, {
        key: "updateOuterDeco",
        value: function updateOuterDeco(outerDeco) {
          if (sameOuterDeco(outerDeco, this.outerDeco))
            return;
          var needsWrap = this.nodeDOM.nodeType != 1;
          var oldDOM = this.dom;
          this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
          if (this.dom != oldDOM) {
            oldDOM.pmViewDesc = void 0;
            this.dom.pmViewDesc = this;
          }
          this.outerDeco = outerDeco;
        }
      }, {
        key: "selectNode",
        value: function selectNode() {
          if (this.nodeDOM.nodeType == 1)
            this.nodeDOM.classList.add("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable)
            this.dom.draggable = true;
        }
      }, {
        key: "deselectNode",
        value: function deselectNode() {
          if (this.nodeDOM.nodeType == 1)
            this.nodeDOM.classList.remove("ProseMirror-selectednode");
          if (this.contentDOM || !this.node.type.spec.draggable)
            this.dom.removeAttribute("draggable");
        }
      }, {
        key: "domAtom",
        get: function get() {
          return this.node.isAtom;
        }
      }], [{
        key: "create",
        value: function create(parent, node, outerDeco, innerDeco, view, pos) {
          var custom = view.nodeViews[node.type.name], descObj;
          var spec = custom && custom(node, view, function() {
            if (!descObj)
              return pos;
            if (descObj.parent)
              return descObj.parent.posBeforeChild(descObj);
          }, outerDeco, innerDeco);
          var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
          if (node.isText) {
            if (!dom)
              dom = document.createTextNode(node.text);
            else if (dom.nodeType != 3)
              throw new RangeError("Text must be rendered as a DOM text node");
          } else if (!dom) {
            var _prosemirrorModel$DOM = prosemirrorModel.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node));
            dom = _prosemirrorModel$DOM.dom;
            contentDOM = _prosemirrorModel$DOM.contentDOM;
          }
          if (!contentDOM && !node.isText && dom.nodeName != "BR") {
            if (!dom.hasAttribute("contenteditable"))
              dom.contentEditable = "false";
            if (node.type.spec.draggable)
              dom.draggable = true;
          }
          var nodeDOM = dom;
          dom = applyOuterDeco(dom, outerDeco, node);
          if (spec)
            return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
          else if (node.isText)
            return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
          else
            return new NodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
        }
      }]);
      return NodeViewDesc2;
    }(ViewDesc);
    function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
      applyOuterDeco(dom, outerDeco, doc2);
      return new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
    }
    var TextViewDesc = function(_NodeViewDesc) {
      _inherits(TextViewDesc2, _NodeViewDesc);
      var _super5 = _createSuper(TextViewDesc2);
      function TextViewDesc2(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
        _classCallCheck(this, TextViewDesc2);
        return _super5.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
      }
      _createClass(TextViewDesc2, [{
        key: "parseRule",
        value: function parseRule() {
          var skip = this.nodeDOM.parentNode;
          while (skip && skip != this.dom && !skip.pmIsDeco) {
            skip = skip.parentNode;
          }
          return {
            skip: skip || true
          };
        }
      }, {
        key: "update",
        value: function update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
            return false;
          this.updateOuterDeco(outerDeco);
          if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
            this.nodeDOM.nodeValue = node.text;
            if (view.trackWrites == this.nodeDOM)
              view.trackWrites = null;
          }
          this.node = node;
          this.dirty = NOT_DIRTY;
          return true;
        }
      }, {
        key: "inParent",
        value: function inParent() {
          var parentDOM = this.parent.contentDOM;
          for (var n = this.nodeDOM; n; n = n.parentNode) {
            if (n == parentDOM)
              return true;
          }
          return false;
        }
      }, {
        key: "domFromPos",
        value: function domFromPos(pos) {
          return {
            node: this.nodeDOM,
            offset: pos
          };
        }
      }, {
        key: "localPosFromDOM",
        value: function localPosFromDOM(dom, offset, bias) {
          if (dom == this.nodeDOM)
            return this.posAtStart + Math.min(offset, this.node.text.length);
          return _get(_getPrototypeOf(TextViewDesc2.prototype), "localPosFromDOM", this).call(this, dom, offset, bias);
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return mutation.type != "characterData" && mutation.type != "selection";
        }
      }, {
        key: "slice",
        value: function slice(from, to, view) {
          var node = this.node.cut(from, to), dom = document.createTextNode(node.text);
          return new TextViewDesc2(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
        }
      }, {
        key: "markDirty",
        value: function markDirty(from, to) {
          _get(_getPrototypeOf(TextViewDesc2.prototype), "markDirty", this).call(this, from, to);
          if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))
            this.dirty = NODE_DIRTY;
        }
      }, {
        key: "domAtom",
        get: function get() {
          return false;
        }
      }]);
      return TextViewDesc2;
    }(NodeViewDesc);
    var TrailingHackViewDesc = function(_ViewDesc5) {
      _inherits(TrailingHackViewDesc2, _ViewDesc5);
      var _super6 = _createSuper(TrailingHackViewDesc2);
      function TrailingHackViewDesc2() {
        _classCallCheck(this, TrailingHackViewDesc2);
        return _super6.apply(this, arguments);
      }
      _createClass(TrailingHackViewDesc2, [{
        key: "parseRule",
        value: function parseRule() {
          return {
            ignore: true
          };
        }
      }, {
        key: "matchesHack",
        value: function matchesHack(nodeName) {
          return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
        }
      }, {
        key: "domAtom",
        get: function get() {
          return true;
        }
      }, {
        key: "ignoreForCoords",
        get: function get() {
          return this.dom.nodeName == "IMG";
        }
      }]);
      return TrailingHackViewDesc2;
    }(ViewDesc);
    var CustomNodeViewDesc = function(_NodeViewDesc2) {
      _inherits(CustomNodeViewDesc2, _NodeViewDesc2);
      var _super7 = _createSuper(CustomNodeViewDesc2);
      function CustomNodeViewDesc2(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
        var _this7;
        _classCallCheck(this, CustomNodeViewDesc2);
        _this7 = _super7.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
        _this7.spec = spec;
        return _this7;
      }
      _createClass(CustomNodeViewDesc2, [{
        key: "update",
        value: function update(node, outerDeco, innerDeco, view) {
          if (this.dirty == NODE_DIRTY)
            return false;
          if (this.spec.update) {
            var result = this.spec.update(node, outerDeco, innerDeco);
            if (result)
              this.updateInner(node, outerDeco, innerDeco, view);
            return result;
          } else if (!this.contentDOM && !node.isLeaf) {
            return false;
          } else {
            return _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "update", this).call(this, node, outerDeco, innerDeco, view);
          }
        }
      }, {
        key: "selectNode",
        value: function selectNode() {
          this.spec.selectNode ? this.spec.selectNode() : _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "selectNode", this).call(this);
        }
      }, {
        key: "deselectNode",
        value: function deselectNode() {
          this.spec.deselectNode ? this.spec.deselectNode() : _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "deselectNode", this).call(this);
        }
      }, {
        key: "setSelection",
        value: function setSelection(anchor, head, root, force) {
          this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "setSelection", this).call(this, anchor, head, root, force);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (this.spec.destroy)
            this.spec.destroy();
          _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "destroy", this).call(this);
        }
      }, {
        key: "stopEvent",
        value: function stopEvent(event) {
          return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
        }
      }, {
        key: "ignoreMutation",
        value: function ignoreMutation(mutation) {
          return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _get(_getPrototypeOf(CustomNodeViewDesc2.prototype), "ignoreMutation", this).call(this, mutation);
        }
      }]);
      return CustomNodeViewDesc2;
    }(NodeViewDesc);
    function renderDescs(parentDOM, descs, view) {
      var dom = parentDOM.firstChild, written = false;
      for (var i = 0; i < descs.length; i++) {
        var desc = descs[i], childDOM = desc.dom;
        if (childDOM.parentNode == parentDOM) {
          while (childDOM != dom) {
            dom = rm(dom);
            written = true;
          }
          dom = dom.nextSibling;
        } else {
          written = true;
          parentDOM.insertBefore(childDOM, dom);
        }
        if (desc instanceof MarkViewDesc) {
          var pos = dom ? dom.previousSibling : parentDOM.lastChild;
          renderDescs(desc.contentDOM, desc.children, view);
          dom = pos ? pos.nextSibling : parentDOM.firstChild;
        }
      }
      while (dom) {
        dom = rm(dom);
        written = true;
      }
      if (written && view.trackWrites == parentDOM)
        view.trackWrites = null;
    }
    var OuterDecoLevel = function OuterDecoLevel2(nodeName) {
      if (nodeName)
        this.nodeName = nodeName;
    };
    OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
    var noDeco = [new OuterDecoLevel()];
    function computeOuterDeco(outerDeco, node, needsWrap) {
      if (outerDeco.length == 0)
        return noDeco;
      var top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];
      for (var i = 0; i < outerDeco.length; i++) {
        var attrs = outerDeco[i].type.attrs;
        if (!attrs)
          continue;
        if (attrs.nodeName)
          result.push(top = new OuterDecoLevel(attrs.nodeName));
        for (var name in attrs) {
          var val = attrs[name];
          if (val == null)
            continue;
          if (needsWrap && result.length == 1)
            result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
          if (name == "class")
            top["class"] = (top["class"] ? top["class"] + " " : "") + val;
          else if (name == "style")
            top.style = (top.style ? top.style + ";" : "") + val;
          else if (name != "nodeName")
            top[name] = val;
        }
      }
      return result;
    }
    function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
      if (prevComputed == noDeco && curComputed == noDeco)
        return nodeDOM;
      var curDOM = nodeDOM;
      for (var i = 0; i < curComputed.length; i++) {
        var deco = curComputed[i], prev = prevComputed[i];
        if (i) {
          var parent = void 0;
          if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
            curDOM = parent;
          } else {
            parent = document.createElement(deco.nodeName);
            parent.pmIsDeco = true;
            parent.appendChild(curDOM);
            prev = noDeco[0];
            curDOM = parent;
          }
        }
        patchAttributes(curDOM, prev || noDeco[0], deco);
      }
      return curDOM;
    }
    function patchAttributes(dom, prev, cur) {
      for (var name in prev) {
        if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
          dom.removeAttribute(name);
      }
      for (var _name in cur) {
        if (_name != "class" && _name != "style" && _name != "nodeName" && cur[_name] != prev[_name])
          dom.setAttribute(_name, cur[_name]);
      }
      if (prev["class"] != cur["class"]) {
        var prevList = prev["class"] ? prev["class"].split(" ").filter(Boolean) : [];
        var curList = cur["class"] ? cur["class"].split(" ").filter(Boolean) : [];
        for (var i = 0; i < prevList.length; i++) {
          if (curList.indexOf(prevList[i]) == -1)
            dom.classList.remove(prevList[i]);
        }
        for (var _i = 0; _i < curList.length; _i++) {
          if (prevList.indexOf(curList[_i]) == -1)
            dom.classList.add(curList[_i]);
        }
        if (dom.classList.length == 0)
          dom.removeAttribute("class");
      }
      if (prev.style != cur.style) {
        if (prev.style) {
          var prop2 = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
          while (m = prop2.exec(prev.style)) {
            dom.style.removeProperty(m[1]);
          }
        }
        if (cur.style)
          dom.style.cssText += cur.style;
      }
    }
    function applyOuterDeco(dom, deco, node) {
      return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
    }
    function sameOuterDeco(a, b) {
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; i++) {
        if (!a[i].type.eq(b[i].type))
          return false;
      }
      return true;
    }
    function rm(dom) {
      var next = dom.nextSibling;
      dom.parentNode.removeChild(dom);
      return next;
    }
    var ViewTreeUpdater = function() {
      function ViewTreeUpdater2(top, lock, view) {
        _classCallCheck(this, ViewTreeUpdater2);
        this.lock = lock;
        this.view = view;
        this.index = 0;
        this.stack = [];
        this.changed = false;
        this.top = top;
        this.preMatch = preMatch(top.node.content, top);
      }
      _createClass(ViewTreeUpdater2, [{
        key: "destroyBetween",
        value: function destroyBetween(start, end) {
          if (start == end)
            return;
          for (var i = start; i < end; i++) {
            this.top.children[i].destroy();
          }
          this.top.children.splice(start, end - start);
          this.changed = true;
        }
      }, {
        key: "destroyRest",
        value: function destroyRest() {
          this.destroyBetween(this.index, this.top.children.length);
        }
      }, {
        key: "syncToMarks",
        value: function syncToMarks(marks, inline, view) {
          var keep = 0, depth = this.stack.length >> 1;
          var maxKeep = Math.min(depth, marks.length);
          while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) {
            keep++;
          }
          while (keep < depth) {
            this.destroyRest();
            this.top.dirty = NOT_DIRTY;
            this.index = this.stack.pop();
            this.top = this.stack.pop();
            depth--;
          }
          while (depth < marks.length) {
            this.stack.push(this.top, this.index + 1);
            var found = -1;
            for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
              if (this.top.children[i].matchesMark(marks[depth])) {
                found = i;
                break;
              }
            }
            if (found > -1) {
              if (found > this.index) {
                this.changed = true;
                this.destroyBetween(this.index, found);
              }
              this.top = this.top.children[this.index];
            } else {
              var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
              this.top.children.splice(this.index, 0, markDesc);
              this.top = markDesc;
              this.changed = true;
            }
            this.index = 0;
            depth++;
          }
        }
      }, {
        key: "findNodeMatch",
        value: function findNodeMatch(node, outerDeco, innerDeco, index) {
          var found = -1, targetDesc;
          if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
            found = this.top.children.indexOf(targetDesc, this.index);
          } else {
            for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
              var child = this.top.children[i];
              if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
                found = i;
                break;
              }
            }
          }
          if (found < 0)
            return false;
          this.destroyBetween(this.index, found);
          this.index++;
          return true;
        }
      }, {
        key: "updateNodeAt",
        value: function updateNodeAt(node, outerDeco, innerDeco, index, view) {
          var child = this.top.children[index];
          if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
            child.dirty = CONTENT_DIRTY;
          if (!child.update(node, outerDeco, innerDeco, view))
            return false;
          this.destroyBetween(this.index, index);
          this.index++;
          return true;
        }
      }, {
        key: "findIndexWithChild",
        value: function findIndexWithChild(domNode) {
          for (; ; ) {
            var parent = domNode.parentNode;
            if (!parent)
              return -1;
            if (parent == this.top.contentDOM) {
              var desc = domNode.pmViewDesc;
              if (desc)
                for (var i = this.index; i < this.top.children.length; i++) {
                  if (this.top.children[i] == desc)
                    return i;
                }
              return -1;
            }
            domNode = parent;
          }
        }
      }, {
        key: "updateNextNode",
        value: function updateNextNode(node, outerDeco, innerDeco, view, index) {
          for (var i = this.index; i < this.top.children.length; i++) {
            var next = this.top.children[i];
            if (next instanceof NodeViewDesc) {
              var _preMatch = this.preMatch.matched.get(next);
              if (_preMatch != null && _preMatch != index)
                return false;
              var nextDOM = next.dom;
              var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
              if (!locked && next.update(node, outerDeco, innerDeco, view)) {
                this.destroyBetween(this.index, i);
                if (next.dom != nextDOM)
                  this.changed = true;
                this.index++;
                return true;
              }
              break;
            }
          }
          return false;
        }
      }, {
        key: "addNode",
        value: function addNode(node, outerDeco, innerDeco, view, pos) {
          this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
          this.changed = true;
        }
      }, {
        key: "placeWidget",
        value: function placeWidget(widget, view, pos) {
          var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
          if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
            this.index++;
          } else {
            var desc = new WidgetViewDesc(this.top, widget, view, pos);
            this.top.children.splice(this.index++, 0, desc);
            this.changed = true;
          }
        }
      }, {
        key: "addTextblockHacks",
        value: function addTextblockHacks() {
          var lastChild = this.top.children[this.index - 1], parent = this.top;
          while (lastChild instanceof MarkViewDesc) {
            parent = lastChild;
            lastChild = parent.children[parent.children.length - 1];
          }
          if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
              this.addHackNode("IMG", parent);
            this.addHackNode("BR", this.top);
          }
        }
      }, {
        key: "addHackNode",
        value: function addHackNode(nodeName, parent) {
          if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
            this.index++;
          } else {
            var dom = document.createElement(nodeName);
            if (nodeName == "IMG") {
              dom.className = "ProseMirror-separator";
              dom.alt = "";
            }
            if (nodeName == "BR")
              dom.className = "ProseMirror-trailingBreak";
            var hack = new TrailingHackViewDesc(this.top, [], dom, null);
            if (parent != this.top)
              parent.children.push(hack);
            else
              parent.children.splice(this.index++, 0, hack);
            this.changed = true;
          }
        }
      }]);
      return ViewTreeUpdater2;
    }();
    function preMatch(frag, parentDesc) {
      var curDesc = parentDesc, descI = curDesc.children.length;
      var fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches = [];
      outer:
        while (fI > 0) {
          var desc = void 0;
          for (; ; ) {
            if (descI) {
              var next = curDesc.children[descI - 1];
              if (next instanceof MarkViewDesc) {
                curDesc = next;
                descI = next.children.length;
              } else {
                desc = next;
                descI--;
                break;
              }
            } else if (curDesc == parentDesc) {
              break outer;
            } else {
              descI = curDesc.parent.children.indexOf(curDesc);
              curDesc = curDesc.parent;
            }
          }
          var node = desc.node;
          if (!node)
            continue;
          if (node != frag.child(fI - 1))
            break;
          --fI;
          matched.set(desc, fI);
          matches.push(desc);
        }
      return {
        index: fI,
        matched,
        matches: matches.reverse()
      };
    }
    function compareSide(a, b) {
      return a.type.side - b.type.side;
    }
    function iterDeco(parent, deco, onWidget, onNode) {
      var locals = deco.locals(parent), offset = 0;
      if (locals.length == 0) {
        for (var i = 0; i < parent.childCount; i++) {
          var child = parent.child(i);
          onNode(child, locals, deco.forChild(offset, child), i);
          offset += child.nodeSize;
        }
        return;
      }
      var decoIndex = 0, active = [], restNode = null;
      for (var parentIndex = 0; ; ) {
        if (decoIndex < locals.length && locals[decoIndex].to == offset) {
          var widget = locals[decoIndex++], widgets = void 0;
          while (decoIndex < locals.length && locals[decoIndex].to == offset) {
            (widgets || (widgets = [widget])).push(locals[decoIndex++]);
          }
          if (widgets) {
            widgets.sort(compareSide);
            for (var _i2 = 0; _i2 < widgets.length; _i2++) {
              onWidget(widgets[_i2], parentIndex, !!restNode);
            }
          } else {
            onWidget(widget, parentIndex, !!restNode);
          }
        }
        var _child = void 0, index = void 0;
        if (restNode) {
          index = -1;
          _child = restNode;
          restNode = null;
        } else if (parentIndex < parent.childCount) {
          index = parentIndex;
          _child = parent.child(parentIndex++);
        } else {
          break;
        }
        for (var _i3 = 0; _i3 < active.length; _i3++) {
          if (active[_i3].to <= offset)
            active.splice(_i3--, 1);
        }
        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) {
          active.push(locals[decoIndex++]);
        }
        var end = offset + _child.nodeSize;
        if (_child.isText) {
          var cutAt = end;
          if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
            cutAt = locals[decoIndex].from;
          for (var _i4 = 0; _i4 < active.length; _i4++) {
            if (active[_i4].to < cutAt)
              cutAt = active[_i4].to;
          }
          if (cutAt < end) {
            restNode = _child.cut(cutAt - offset);
            _child = _child.cut(0, cutAt - offset);
            end = cutAt;
            index = -1;
          }
        }
        var outerDeco = _child.isInline && !_child.isLeaf ? active.filter(function(d) {
          return !d.inline;
        }) : active.slice();
        onNode(_child, outerDeco, deco.forChild(offset, _child), index);
        offset = end;
      }
    }
    function iosHacks(dom) {
      if (dom.nodeName == "UL" || dom.nodeName == "OL") {
        var oldCSS = dom.style.cssText;
        dom.style.cssText = oldCSS + "; list-style: square !important";
        window.getComputedStyle(dom).listStyle;
        dom.style.cssText = oldCSS;
      }
    }
    function nearbyTextNode(node, offset) {
      for (; ; ) {
        if (node.nodeType == 3)
          return node;
        if (node.nodeType == 1 && offset > 0) {
          if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)
            return node.childNodes[offset];
          node = node.childNodes[offset - 1];
          offset = nodeSize(node);
        } else if (node.nodeType == 1 && offset < node.childNodes.length) {
          node = node.childNodes[offset];
          offset = 0;
        } else {
          return null;
        }
      }
    }
    function findTextInFragment(frag, text, from, to) {
      for (var i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
        var child = frag.child(i++), childStart = pos;
        pos += child.nodeSize;
        if (!child.isText)
          continue;
        var str = child.text;
        while (i < frag.childCount) {
          var next = frag.child(i++);
          pos += next.nodeSize;
          if (!next.isText)
            break;
          str += next.text;
        }
        if (pos >= from) {
          var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
          if (found >= 0 && found + text.length + childStart >= from)
            return childStart + found;
          if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
            return to;
        }
      }
      return -1;
    }
    function replaceNodes(nodes, from, to, view, replacement) {
      var result = [];
      for (var i = 0, off = 0; i < nodes.length; i++) {
        var child = nodes[i], start = off, end = off += child.size;
        if (start >= to || end <= from) {
          result.push(child);
        } else {
          if (start < from)
            result.push(child.slice(0, from - start, view));
          if (replacement) {
            result.push(replacement);
            replacement = void 0;
          }
          if (end > to)
            result.push(child.slice(to - start, child.size, view));
        }
      }
      return result;
    }
    function selectionFromDOM(view) {
      var origin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      var domSel = view.domSelectionRange(), doc2 = view.state.doc;
      if (!domSel.focusNode)
        return null;
      var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
      var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
      if (head < 0)
        return null;
      var $head = doc2.resolve(head), $anchor, selection;
      if (selectionCollapsed(domSel)) {
        $anchor = $head;
        while (nearestDesc && !nearestDesc.node) {
          nearestDesc = nearestDesc.parent;
        }
        var nearestDescNode = nearestDesc.node;
        if (nearestDesc && nearestDescNode.isAtom && prosemirrorState.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
          var pos = nearestDesc.posBefore;
          selection = new prosemirrorState.NodeSelection(head == pos ? $head : doc2.resolve(pos));
        }
      } else {
        var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
        if (anchor < 0)
          return null;
        $anchor = doc2.resolve(anchor);
      }
      if (!selection) {
        var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
        selection = selectionBetween(view, $anchor, $head, bias);
      }
      return selection;
    }
    function editorOwnsSelection(view) {
      return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
    }
    function selectionToDOM(view) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var sel = view.state.selection;
      syncNodeSelection(view, sel);
      if (!editorOwnsSelection(view))
        return;
      if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
        var domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
        if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
          view.input.mouseDown.delayedSelectionSync = true;
          view.domObserver.setCurSelection();
          return;
        }
      }
      view.domObserver.disconnectSelection();
      if (view.cursorWrapper) {
        selectCursorWrapper(view);
      } else {
        var anchor = sel.anchor, head = sel.head, resetEditableFrom, resetEditableTo;
        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState.TextSelection)) {
          if (!sel.$from.parent.inlineContent)
            resetEditableFrom = temporarilyEditableNear(view, sel.from);
          if (!sel.empty && !sel.$from.parent.inlineContent)
            resetEditableTo = temporarilyEditableNear(view, sel.to);
        }
        view.docView.setSelection(anchor, head, view.root, force);
        if (brokenSelectBetweenUneditable) {
          if (resetEditableFrom)
            resetEditable(resetEditableFrom);
          if (resetEditableTo)
            resetEditable(resetEditableTo);
        }
        if (sel.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        } else {
          view.dom.classList.add("ProseMirror-hideselection");
          if ("onselectionchange" in document)
            removeClassOnSelectionChange(view);
        }
      }
      view.domObserver.setCurSelection();
      view.domObserver.connectSelection();
    }
    var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
    function temporarilyEditableNear(view, pos) {
      var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0), node = _view$docView$domFrom3.node, offset = _view$docView$domFrom3.offset;
      var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
      var before = offset ? node.childNodes[offset - 1] : null;
      if (safari && after && after.contentEditable == "false")
        return setEditable(after);
      if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
        if (after)
          return setEditable(after);
        else if (before)
          return setEditable(before);
      }
    }
    function setEditable(element) {
      element.contentEditable = "true";
      if (safari && element.draggable) {
        element.draggable = false;
        element.wasDraggable = true;
      }
      return element;
    }
    function resetEditable(element) {
      element.contentEditable = "false";
      if (element.wasDraggable) {
        element.draggable = true;
        element.wasDraggable = null;
      }
    }
    function removeClassOnSelectionChange(view) {
      var doc2 = view.dom.ownerDocument;
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      var domSel = view.domSelectionRange();
      var node = domSel.anchorNode, offset = domSel.anchorOffset;
      doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = function() {
        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
          doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
          setTimeout(function() {
            if (!editorOwnsSelection(view) || view.state.selection.visible)
              view.dom.classList.remove("ProseMirror-hideselection");
          }, 20);
        }
      });
    }
    function selectCursorWrapper(view) {
      var domSel = view.domSelection(), range = document.createRange();
      var node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
      if (img)
        range.setEnd(node.parentNode, domIndex(node) + 1);
      else
        range.setEnd(node, 0);
      range.collapse(false);
      domSel.removeAllRanges();
      domSel.addRange(range);
      if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
        node.disabled = true;
        node.disabled = false;
      }
    }
    function syncNodeSelection(view, sel) {
      if (sel instanceof prosemirrorState.NodeSelection) {
        var desc = view.docView.descAt(sel.from);
        if (desc != view.lastSelectedViewDesc) {
          clearNodeSelection(view);
          if (desc)
            desc.selectNode();
          view.lastSelectedViewDesc = desc;
        }
      } else {
        clearNodeSelection(view);
      }
    }
    function clearNodeSelection(view) {
      if (view.lastSelectedViewDesc) {
        if (view.lastSelectedViewDesc.parent)
          view.lastSelectedViewDesc.deselectNode();
        view.lastSelectedViewDesc = void 0;
      }
    }
    function selectionBetween(view, $anchor, $head, bias) {
      return view.someProp("createSelectionBetween", function(f) {
        return f(view, $anchor, $head);
      }) || prosemirrorState.TextSelection.between($anchor, $head, bias);
    }
    function hasFocusAndSelection(view) {
      if (view.editable && !view.hasFocus())
        return false;
      return hasSelection(view);
    }
    function hasSelection(view) {
      var sel = view.domSelectionRange();
      if (!sel.anchorNode)
        return false;
      try {
        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
      } catch (_) {
        return false;
      }
    }
    function anchorInRightPlace(view) {
      var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
      var domSel = view.domSelectionRange();
      return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
    }
    function moveSelectionBlock(state, dir) {
      var _state$selection = state.selection, $anchor = _state$selection.$anchor, $head = _state$selection.$head;
      var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
      var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
      return $start && prosemirrorState.Selection.findFrom($start, dir);
    }
    function apply(view, sel) {
      view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
      return true;
    }
    function selectHorizontally(view, dir, mods) {
      var sel = view.state.selection;
      if (sel instanceof prosemirrorState.TextSelection) {
        if (!sel.empty || mods.indexOf("s") > -1) {
          return false;
        } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
          var next = moveSelectionBlock(view.state, dir);
          if (next && next instanceof prosemirrorState.NodeSelection)
            return apply(view, next);
          return false;
        } else if (!(mac && mods.indexOf("m") > -1)) {
          var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
          if (!node || node.isText)
            return false;
          var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
          if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
            return false;
          if (prosemirrorState.NodeSelection.isSelectable(node)) {
            return apply(view, new prosemirrorState.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
          } else if (webkit) {
            return apply(view, new prosemirrorState.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
          } else {
            return false;
          }
        }
      } else if (sel instanceof prosemirrorState.NodeSelection && sel.node.isInline) {
        return apply(view, new prosemirrorState.TextSelection(dir > 0 ? sel.$to : sel.$from));
      } else {
        var _next = moveSelectionBlock(view.state, dir);
        if (_next)
          return apply(view, _next);
        return false;
      }
    }
    function nodeLen(node) {
      return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
    }
    function isIgnorable(dom) {
      var desc = dom.pmViewDesc;
      return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
    }
    function skipIgnoredNodesLeft(view) {
      var sel = view.domSelectionRange();
      var node = sel.focusNode, offset = sel.focusOffset;
      if (!node)
        return;
      var moveNode, moveOffset, force = false;
      if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset]))
        force = true;
      for (; ; ) {
        if (offset > 0) {
          if (node.nodeType != 1) {
            break;
          } else {
            var before = node.childNodes[offset - 1];
            if (isIgnorable(before)) {
              moveNode = node;
              moveOffset = --offset;
            } else if (before.nodeType == 3) {
              node = before;
              offset = node.nodeValue.length;
            } else
              break;
          }
        } else if (isBlockNode(node)) {
          break;
        } else {
          var prev = node.previousSibling;
          while (prev && isIgnorable(prev)) {
            moveNode = node.parentNode;
            moveOffset = domIndex(prev);
            prev = prev.previousSibling;
          }
          if (!prev) {
            node = node.parentNode;
            if (node == view.dom)
              break;
            offset = 0;
          } else {
            node = prev;
            offset = nodeLen(node);
          }
        }
      }
      if (force)
        setSelFocus(view, node, offset);
      else if (moveNode)
        setSelFocus(view, moveNode, moveOffset);
    }
    function skipIgnoredNodesRight(view) {
      var sel = view.domSelectionRange();
      var node = sel.focusNode, offset = sel.focusOffset;
      if (!node)
        return;
      var len = nodeLen(node);
      var moveNode, moveOffset;
      for (; ; ) {
        if (offset < len) {
          if (node.nodeType != 1)
            break;
          var after = node.childNodes[offset];
          if (isIgnorable(after)) {
            moveNode = node;
            moveOffset = ++offset;
          } else
            break;
        } else if (isBlockNode(node)) {
          break;
        } else {
          var next = node.nextSibling;
          while (next && isIgnorable(next)) {
            moveNode = next.parentNode;
            moveOffset = domIndex(next) + 1;
            next = next.nextSibling;
          }
          if (!next) {
            node = node.parentNode;
            if (node == view.dom)
              break;
            offset = len = 0;
          } else {
            node = next;
            offset = 0;
            len = nodeLen(node);
          }
        }
      }
      if (moveNode)
        setSelFocus(view, moveNode, moveOffset);
    }
    function isBlockNode(dom) {
      var desc = dom.pmViewDesc;
      return desc && desc.node && desc.node.isBlock;
    }
    function setSelFocus(view, node, offset) {
      var sel = view.domSelection();
      if (selectionCollapsed(sel)) {
        var range = document.createRange();
        range.setEnd(node, offset);
        range.setStart(node, offset);
        sel.removeAllRanges();
        sel.addRange(range);
      } else if (sel.extend) {
        sel.extend(node, offset);
      }
      view.domObserver.setCurSelection();
      var state = view.state;
      setTimeout(function() {
        if (view.state == state)
          selectionToDOM(view);
      }, 50);
    }
    function selectVertically(view, dir, mods) {
      var sel = view.state.selection;
      if (sel instanceof prosemirrorState.TextSelection && !sel.empty || mods.indexOf("s") > -1)
        return false;
      if (mac && mods.indexOf("m") > -1)
        return false;
      var $from = sel.$from, $to = sel.$to;
      if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
        var next = moveSelectionBlock(view.state, dir);
        if (next && next instanceof prosemirrorState.NodeSelection)
          return apply(view, next);
      }
      if (!$from.parent.inlineContent) {
        var side = dir < 0 ? $from : $to;
        var beyond = sel instanceof prosemirrorState.AllSelection ? prosemirrorState.Selection.near(side, dir) : prosemirrorState.Selection.findFrom(side, dir);
        return beyond ? apply(view, beyond) : false;
      }
      return false;
    }
    function stopNativeHorizontalDelete(view, dir) {
      if (!(view.state.selection instanceof prosemirrorState.TextSelection))
        return true;
      var _view$state$selection2 = view.state.selection, $head = _view$state$selection2.$head, $anchor = _view$state$selection2.$anchor, empty2 = _view$state$selection2.empty;
      if (!$head.sameParent($anchor))
        return true;
      if (!empty2)
        return false;
      if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
        return true;
      var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
      if (nextNode && !nextNode.isText) {
        var tr = view.state.tr;
        if (dir < 0)
          tr["delete"]($head.pos - nextNode.nodeSize, $head.pos);
        else
          tr["delete"]($head.pos, $head.pos + nextNode.nodeSize);
        view.dispatch(tr);
        return true;
      }
      return false;
    }
    function switchEditable(view, node, state) {
      view.domObserver.stop();
      node.contentEditable = state;
      view.domObserver.start();
    }
    function safariDownArrowBug(view) {
      if (!safari || view.state.selection.$head.parentOffset > 0)
        return false;
      var _view$domSelectionRan3 = view.domSelectionRange(), focusNode = _view$domSelectionRan3.focusNode, focusOffset = _view$domSelectionRan3.focusOffset;
      if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
        var child = focusNode.firstChild;
        switchEditable(view, child, "true");
        setTimeout(function() {
          return switchEditable(view, child, "false");
        }, 20);
      }
      return false;
    }
    function getMods(event) {
      var result = "";
      if (event.ctrlKey)
        result += "c";
      if (event.metaKey)
        result += "m";
      if (event.altKey)
        result += "a";
      if (event.shiftKey)
        result += "s";
      return result;
    }
    function captureKeyDown(view, event) {
      var code = event.keyCode, mods = getMods(event);
      if (code == 8 || mac && code == 72 && mods == "c") {
        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
      } else if (code == 46 || mac && code == 68 && mods == "c") {
        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
      } else if (code == 13 || code == 27) {
        return true;
      } else if (code == 37 || mac && code == 66 && mods == "c") {
        return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
      } else if (code == 39 || mac && code == 70 && mods == "c") {
        return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
      } else if (code == 38 || mac && code == 80 && mods == "c") {
        return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
      } else if (code == 40 || mac && code == 78 && mods == "c") {
        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
      } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
        return true;
      }
      return false;
    }
    function serializeForClipboard(view, slice) {
      view.someProp("transformCopied", function(f) {
        slice = f(slice, view);
      });
      var context = [], _slice = slice, content = _slice.content, openStart = _slice.openStart, openEnd = _slice.openEnd;
      while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
        openStart--;
        openEnd--;
        var node = content.firstChild;
        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
        content = node.content;
      }
      var serializer = view.someProp("clipboardSerializer") || prosemirrorModel.DOMSerializer.fromSchema(view.state.schema);
      var doc2 = detachedDoc(), wrap = doc2.createElement("div");
      wrap.appendChild(serializer.serializeFragment(content, {
        document: doc2
      }));
      var firstChild = wrap.firstChild, needsWrap, wrappers = 0;
      while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
        for (var i = needsWrap.length - 1; i >= 0; i--) {
          var wrapper = doc2.createElement(needsWrap[i]);
          while (wrap.firstChild) {
            wrapper.appendChild(wrap.firstChild);
          }
          wrap.appendChild(wrapper);
          wrappers++;
        }
        firstChild = wrap.firstChild;
      }
      if (firstChild && firstChild.nodeType == 1)
        firstChild.setAttribute("data-pm-slice", "".concat(openStart, " ").concat(openEnd).concat(wrappers ? " -".concat(wrappers) : "", " ").concat(JSON.stringify(context)));
      var text = view.someProp("clipboardTextSerializer", function(f) {
        return f(slice, view);
      }) || slice.content.textBetween(0, slice.content.size, "\n\n");
      return {
        dom: wrap,
        text
      };
    }
    function parseFromClipboard(view, text, html, plainText, $context) {
      var inCode = $context.parent.type.spec.code;
      var dom, slice;
      if (!html && !text)
        return null;
      var asText = text && (plainText || inCode || !html);
      if (asText) {
        view.someProp("transformPastedText", function(f) {
          text = f(text, inCode || plainText, view);
        });
        if (inCode)
          return text ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirrorModel.Slice.empty;
        var parsed = view.someProp("clipboardTextParser", function(f) {
          return f(text, $context, plainText, view);
        });
        if (parsed) {
          slice = parsed;
        } else {
          var marks = $context.marks();
          var schema = view.state.schema, serializer = prosemirrorModel.DOMSerializer.fromSchema(schema);
          dom = document.createElement("div");
          text.split(/(?:\r\n?|\n)+/).forEach(function(block) {
            var p = dom.appendChild(document.createElement("p"));
            if (block)
              p.appendChild(serializer.serializeNode(schema.text(block, marks)));
          });
        }
      } else {
        view.someProp("transformPastedHTML", function(f) {
          html = f(html, view);
        });
        dom = readHTML(html);
        if (webkit)
          restoreReplacedSpaces(dom);
      }
      var contextNode = dom && dom.querySelector("[data-pm-slice]");
      var sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
      if (sliceData && sliceData[3])
        for (var i = +sliceData[3]; i > 0; i--) {
          var child = dom.firstChild;
          while (child && child.nodeType != 1) {
            child = child.nextSibling;
          }
          if (!child)
            break;
          dom = child;
        }
      if (!slice) {
        var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
        slice = parser.parseSlice(dom, {
          preserveWhitespace: !!(asText || sliceData),
          context: $context,
          ruleFromNode: function ruleFromNode2(dom2) {
            if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
              return {
                ignore: true
              };
            return null;
          }
        });
      }
      if (sliceData) {
        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
      } else {
        slice = prosemirrorModel.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
        if (slice.openStart || slice.openEnd) {
          var openStart = 0, openEnd = 0;
          for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
          }
          for (var _node = slice.content.lastChild; openEnd < slice.openEnd && !_node.type.spec.isolating; openEnd++, _node = _node.lastChild) {
          }
          slice = closeSlice(slice, openStart, openEnd);
        }
      }
      view.someProp("transformPasted", function(f) {
        slice = f(slice, view);
      });
      return slice;
    }
    var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
    function normalizeSiblings(fragment, $context) {
      if (fragment.childCount < 2)
        return fragment;
      var _loop = function _loop2(d2) {
        var parent = $context.node(d2);
        var match = parent.contentMatchAt($context.index(d2));
        var lastWrap = void 0, result = [];
        fragment.forEach(function(node) {
          if (!result)
            return;
          var wrap = match.findWrapping(node.type), inLast;
          if (!wrap)
            return result = null;
          if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
            result[result.length - 1] = inLast;
          } else {
            if (result.length)
              result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
            var wrapped = withWrappers(node, wrap);
            result.push(wrapped);
            match = match.matchType(wrapped.type);
            lastWrap = wrap;
          }
        });
        if (result)
          return {
            v: prosemirrorModel.Fragment.from(result)
          };
      };
      for (var d = $context.depth; d >= 0; d--) {
        var _ret = _loop(d);
        if (_typeof(_ret) === "object")
          return _ret.v;
      }
      return fragment;
    }
    function withWrappers(node, wrap) {
      var from = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      for (var i = wrap.length - 1; i >= from; i--) {
        node = wrap[i].create(null, prosemirrorModel.Fragment.from(node));
      }
      return node;
    }
    function addToSibling(wrap, lastWrap, node, sibling, depth) {
      if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
        var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
        if (inner)
          return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
        var match = sibling.contentMatchAt(sibling.childCount);
        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
          return sibling.copy(sibling.content.append(prosemirrorModel.Fragment.from(withWrappers(node, wrap, depth + 1))));
      }
    }
    function closeRight(node, depth) {
      if (depth == 0)
        return node;
      var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
      var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);
      return node.copy(fragment.append(fill));
    }
    function closeRange(fragment, side, from, to, depth, openEnd) {
      var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
      if (depth < to - 1)
        inner = closeRange(inner, side, from, to, depth + 1, openEnd);
      if (depth >= from)
        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true));
      return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
    }
    function closeSlice(slice, openStart, openEnd) {
      if (openStart < slice.openStart)
        slice = new prosemirrorModel.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
      if (openEnd < slice.openEnd)
        slice = new prosemirrorModel.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
      return slice;
    }
    var wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    var _detachedDoc = null;
    function detachedDoc() {
      return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
    }
    function readHTML(html) {
      var metas = /^(\s*<meta [^>]*>)*/.exec(html);
      if (metas)
        html = html.slice(metas[0].length);
      var elt = detachedDoc().createElement("div");
      var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
      if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])
        html = wrap.map(function(n) {
          return "<" + n + ">";
        }).join("") + html + wrap.map(function(n) {
          return "</" + n + ">";
        }).reverse().join("");
      elt.innerHTML = html;
      if (wrap)
        for (var i = 0; i < wrap.length; i++) {
          elt = elt.querySelector(wrap[i]) || elt;
        }
      return elt;
    }
    function restoreReplacedSpaces(dom) {
      var nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode)
          node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
      }
    }
    function addContext(slice, context) {
      if (!slice.size)
        return slice;
      var schema = slice.content.firstChild.type.schema, array;
      try {
        array = JSON.parse(context);
      } catch (e) {
        return slice;
      }
      var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;
      for (var i = array.length - 2; i >= 0; i -= 2) {
        var type = schema.nodes[array[i]];
        if (!type || type.hasRequiredAttrs())
          break;
        content = prosemirrorModel.Fragment.from(type.create(array[i + 1], content));
        openStart++;
        openEnd++;
      }
      return new prosemirrorModel.Slice(content, openStart, openEnd);
    }
    var handlers = {};
    var editHandlers = {};
    var passiveHandlers = {
      touchstart: true,
      touchmove: true
    };
    var InputState = _createClass(function InputState2() {
      _classCallCheck(this, InputState2);
      this.shiftKey = false;
      this.mouseDown = null;
      this.lastKeyCode = null;
      this.lastKeyCodeTime = 0;
      this.lastClick = {
        time: 0,
        x: 0,
        y: 0,
        type: ""
      };
      this.lastSelectionOrigin = null;
      this.lastSelectionTime = 0;
      this.lastIOSEnter = 0;
      this.lastIOSEnterFallbackTimeout = -1;
      this.lastFocus = 0;
      this.lastTouch = 0;
      this.lastAndroidDelete = 0;
      this.composing = false;
      this.composingTimeout = -1;
      this.compositionNodes = [];
      this.compositionEndedAt = -2e8;
      this.domChangeCount = 0;
      this.eventHandlers = /* @__PURE__ */ Object.create(null);
      this.hideSelectionGuard = null;
    });
    function initInput(view) {
      var _loop2 = function _loop22(event2) {
        var handler = handlers[event2];
        view.dom.addEventListener(event2, view.input.eventHandlers[event2] = function(event3) {
          if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers)))
            handler(view, event3);
        }, passiveHandlers[event2] ? {
          passive: true
        } : void 0);
      };
      for (var event in handlers) {
        _loop2(event);
      }
      if (safari)
        view.dom.addEventListener("input", function() {
          return null;
        });
      ensureListeners(view);
    }
    function setSelectionOrigin(view, origin) {
      view.input.lastSelectionOrigin = origin;
      view.input.lastSelectionTime = Date.now();
    }
    function destroyInput(view) {
      view.domObserver.stop();
      for (var type in view.input.eventHandlers) {
        view.dom.removeEventListener(type, view.input.eventHandlers[type]);
      }
      clearTimeout(view.input.composingTimeout);
      clearTimeout(view.input.lastIOSEnterFallbackTimeout);
    }
    function ensureListeners(view) {
      view.someProp("handleDOMEvents", function(currentHandlers) {
        for (var type in currentHandlers) {
          if (!view.input.eventHandlers[type])
            view.dom.addEventListener(type, view.input.eventHandlers[type] = function(event) {
              return runCustomHandler(view, event);
            });
        }
      });
    }
    function runCustomHandler(view, event) {
      return view.someProp("handleDOMEvents", function(handlers2) {
        var handler = handlers2[event.type];
        return handler ? handler(view, event) || event.defaultPrevented : false;
      });
    }
    function eventBelongsToView(view, event) {
      if (!event.bubbles)
        return true;
      if (event.defaultPrevented)
        return false;
      for (var node = event.target; node != view.dom; node = node.parentNode) {
        if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
          return false;
      }
      return true;
    }
    function _dispatchEvent(view, event) {
      if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
        handlers[event.type](view, event);
    }
    editHandlers.keydown = function(view, _event) {
      var event = _event;
      view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event))
        return;
      view.input.lastKeyCode = event.keyCode;
      view.input.lastKeyCodeTime = Date.now();
      if (android && chrome && event.keyCode == 13)
        return;
      if (event.keyCode != 229)
        view.domObserver.forceFlush();
      if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        var now = Date.now();
        view.input.lastIOSEnter = now;
        view.input.lastIOSEnterFallbackTimeout = setTimeout(function() {
          if (view.input.lastIOSEnter == now) {
            view.someProp("handleKeyDown", function(f) {
              return f(view, keyEvent(13, "Enter"));
            });
            view.input.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", function(f) {
        return f(view, event);
      }) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = function(view, event) {
      if (event.keyCode == 16)
        view.input.shiftKey = false;
    };
    editHandlers.keypress = function(view, _event) {
      var event = _event;
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)
        return;
      if (view.someProp("handleKeyPress", function(f) {
        return f(view, event);
      })) {
        event.preventDefault();
        return;
      }
      var sel = view.state.selection;
      if (!(sel instanceof prosemirrorState.TextSelection) || !sel.$from.sameParent(sel.$to)) {
        var text = String.fromCharCode(event.charCode);
        if (!view.someProp("handleTextInput", function(f) {
          return f(view, sel.$from.pos, sel.$to.pos, text);
        }))
          view.dispatch(view.state.tr.insertText(text).scrollIntoView());
        event.preventDefault();
      }
    };
    function eventCoords(event) {
      return {
        left: event.clientX,
        top: event.clientY
      };
    }
    function isNear(event, click) {
      var dx = click.x - event.clientX, dy = click.y - event.clientY;
      return dx * dx + dy * dy < 100;
    }
    function runHandlerOnContext(view, propName, pos, inside, event) {
      if (inside == -1)
        return false;
      var $pos = view.state.doc.resolve(inside);
      var _loop3 = function _loop32(i2) {
        if (view.someProp(propName, function(f) {
          return i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false);
        }))
          return {
            v: true
          };
      };
      for (var i = $pos.depth + 1; i > 0; i--) {
        var _ret2 = _loop3(i);
        if (_typeof(_ret2) === "object")
          return _ret2.v;
      }
      return false;
    }
    function updateSelection(view, selection, origin) {
      if (!view.focused)
        view.focus();
      var tr = view.state.tr.setSelection(selection);
      if (origin == "pointer")
        tr.setMeta("pointer", true);
      view.dispatch(tr);
    }
    function selectClickedLeaf(view, inside) {
      if (inside == -1)
        return false;
      var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
      if (node && node.isAtom && prosemirrorState.NodeSelection.isSelectable(node)) {
        updateSelection(view, new prosemirrorState.NodeSelection($pos), "pointer");
        return true;
      }
      return false;
    }
    function selectClickedNode(view, inside) {
      if (inside == -1)
        return false;
      var sel = view.state.selection, selectedNode, selectAt;
      if (sel instanceof prosemirrorState.NodeSelection)
        selectedNode = sel.node;
      var $pos = view.state.doc.resolve(inside);
      for (var i = $pos.depth + 1; i > 0; i--) {
        var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        if (prosemirrorState.NodeSelection.isSelectable(node)) {
          if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
            selectAt = $pos.before(sel.$from.depth);
          else
            selectAt = $pos.before(i);
          break;
        }
      }
      if (selectAt != null) {
        updateSelection(view, prosemirrorState.NodeSelection.create(view.state.doc, selectAt), "pointer");
        return true;
      } else {
        return false;
      }
    }
    function handleSingleClick(view, pos, inside, event, selectNode) {
      return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f) {
        return f(view, pos, event);
      }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
    }
    function handleDoubleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f) {
        return f(view, pos, event);
      });
    }
    function handleTripleClick(view, pos, inside, event) {
      return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f) {
        return f(view, pos, event);
      }) || defaultTripleClick(view, inside, event);
    }
    function defaultTripleClick(view, inside, event) {
      if (event.button != 0)
        return false;
      var doc2 = view.state.doc;
      if (inside == -1) {
        if (doc2.inlineContent) {
          updateSelection(view, prosemirrorState.TextSelection.create(doc2, 0, doc2.content.size), "pointer");
          return true;
        }
        return false;
      }
      var $pos = doc2.resolve(inside);
      for (var i = $pos.depth + 1; i > 0; i--) {
        var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
        var nodePos = $pos.before(i);
        if (node.inlineContent)
          updateSelection(view, prosemirrorState.TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size), "pointer");
        else if (prosemirrorState.NodeSelection.isSelectable(node))
          updateSelection(view, prosemirrorState.NodeSelection.create(doc2, nodePos), "pointer");
        else
          continue;
        return true;
      }
    }
    function forceDOMFlush(view) {
      return endComposition(view);
    }
    var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
    handlers.mousedown = function(view, _event) {
      var event = _event;
      view.input.shiftKey = event.shiftKey;
      var flushed = forceDOMFlush(view);
      var now = Date.now(), type = "singleClick";
      if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
        if (view.input.lastClick.type == "singleClick")
          type = "doubleClick";
        else if (view.input.lastClick.type == "doubleClick")
          type = "tripleClick";
      }
      view.input.lastClick = {
        time: now,
        x: event.clientX,
        y: event.clientY,
        type
      };
      var pos = view.posAtCoords(eventCoords(event));
      if (!pos)
        return;
      if (type == "singleClick") {
        if (view.input.mouseDown)
          view.input.mouseDown.done();
        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
      } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    var MouseDown = function() {
      function MouseDown2(view, pos, event, flushed) {
        var _this8 = this;
        _classCallCheck(this, MouseDown2);
        this.view = view;
        this.pos = pos;
        this.event = event;
        this.flushed = flushed;
        this.delayedSelectionSync = false;
        this.mightDrag = null;
        this.startDoc = view.state.doc;
        this.selectNode = !!event[selectNodeModifier];
        this.allowDefault = event.shiftKey;
        var targetNode, targetPos;
        if (pos.inside > -1) {
          targetNode = view.state.doc.nodeAt(pos.inside);
          targetPos = pos.inside;
        } else {
          var $pos = view.state.doc.resolve(pos.pos);
          targetNode = $pos.parent;
          targetPos = $pos.depth ? $pos.before() : 0;
        }
        var target = flushed ? null : event.target;
        var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
        this.target = targetDesc ? targetDesc.dom : null;
        var selection = view.state.selection;
        if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirrorState.NodeSelection && selection.from <= targetPos && selection.to > targetPos)
          this.mightDrag = {
            node: targetNode,
            pos: targetPos,
            addAttr: !!(this.target && !this.target.draggable),
            setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
          };
        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
          this.view.domObserver.stop();
          if (this.mightDrag.addAttr)
            this.target.draggable = true;
          if (this.mightDrag.setUneditable)
            setTimeout(function() {
              if (_this8.view.input.mouseDown == _this8)
                _this8.target.setAttribute("contentEditable", "false");
            }, 20);
          this.view.domObserver.start();
        }
        view.root.addEventListener("mouseup", this.up = this.up.bind(this));
        view.root.addEventListener("mousemove", this.move = this.move.bind(this));
        setSelectionOrigin(view, "pointer");
      }
      _createClass(MouseDown2, [{
        key: "done",
        value: function done() {
          var _this9 = this;
          this.view.root.removeEventListener("mouseup", this.up);
          this.view.root.removeEventListener("mousemove", this.move);
          if (this.mightDrag && this.target) {
            this.view.domObserver.stop();
            if (this.mightDrag.addAttr)
              this.target.removeAttribute("draggable");
            if (this.mightDrag.setUneditable)
              this.target.removeAttribute("contentEditable");
            this.view.domObserver.start();
          }
          if (this.delayedSelectionSync)
            setTimeout(function() {
              return selectionToDOM(_this9.view);
            });
          this.view.input.mouseDown = null;
        }
      }, {
        key: "up",
        value: function up(event) {
          this.done();
          if (!this.view.dom.contains(event.target))
            return;
          var pos = this.pos;
          if (this.view.state.doc != this.startDoc)
            pos = this.view.posAtCoords(eventCoords(event));
          this.updateAllowDefault(event);
          if (this.allowDefault || !pos) {
            setSelectionOrigin(this.view, "pointer");
          } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
            event.preventDefault();
          } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
            updateSelection(this.view, prosemirrorState.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
            event.preventDefault();
          } else {
            setSelectionOrigin(this.view, "pointer");
          }
        }
      }, {
        key: "move",
        value: function move(event) {
          this.updateAllowDefault(event);
          setSelectionOrigin(this.view, "pointer");
          if (event.buttons == 0)
            this.done();
        }
      }, {
        key: "updateAllowDefault",
        value: function updateAllowDefault(event) {
          if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
            this.allowDefault = true;
        }
      }]);
      return MouseDown2;
    }();
    handlers.touchstart = function(view) {
      view.input.lastTouch = Date.now();
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.touchmove = function(view) {
      view.input.lastTouch = Date.now();
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = function(view) {
      return forceDOMFlush(view);
    };
    function inOrNearComposition(view, event) {
      if (view.composing)
        return true;
      if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
        view.input.compositionEndedAt = -2e8;
        return true;
      }
      return false;
    }
    var timeoutComposition = android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
      if (!view.composing) {
        view.domObserver.flush();
        var state = view.state, $pos = state.selection.$from;
        if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m) {
          return m.type.spec.inclusive === false;
        }))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view);
          if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            var sel = view.domSelectionRange();
            for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {
              var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
              if (!before)
                break;
              if (before.nodeType == 3) {
                view.domSelection().collapse(before, before.nodeValue.length);
                break;
              } else {
                node = before;
                offset = -1;
              }
            }
          }
        }
        view.input.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = function(view, event) {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = event.timeStamp;
        scheduleComposeEnd(view, 20);
      }
    };
    function scheduleComposeEnd(view, delay) {
      clearTimeout(view.input.composingTimeout);
      if (delay > -1)
        view.input.composingTimeout = setTimeout(function() {
          return endComposition(view);
        }, delay);
    }
    function clearComposition(view) {
      if (view.composing) {
        view.input.composing = false;
        view.input.compositionEndedAt = timestampFromCustomEvent();
      }
      while (view.input.compositionNodes.length > 0) {
        view.input.compositionNodes.pop().markParentsDirty();
      }
    }
    function timestampFromCustomEvent() {
      var event = document.createEvent("Event");
      event.initEvent("event", true, true);
      return event.timeStamp;
    }
    function endComposition(view) {
      var forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (android && view.domObserver.flushingSoon >= 0)
        return;
      view.domObserver.forceFlush();
      clearComposition(view);
      if (forceUpdate || view.docView && view.docView.dirty) {
        var sel = selectionFromDOM(view);
        if (sel && !sel.eq(view.state.selection))
          view.dispatch(view.state.tr.setSelection(sel));
        else
          view.updateState(view.state);
        return true;
      }
      return false;
    }
    function captureCopy(view, dom) {
      if (!view.dom.parentNode)
        return;
      var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
      wrap.appendChild(dom);
      wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
      var sel = getSelection(), range = document.createRange();
      range.selectNodeContents(dom);
      view.dom.blur();
      sel.removeAllRanges();
      sel.addRange(range);
      setTimeout(function() {
        if (wrap.parentNode)
          wrap.parentNode.removeChild(wrap);
        view.focus();
      }, 50);
    }
    var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
    handlers.copy = editHandlers.cut = function(view, _event) {
      var event = _event;
      var sel = view.state.selection, cut = event.type == "cut";
      if (sel.empty)
        return;
      var data = brokenClipboardAPI ? null : event.clipboardData;
      var slice = sel.content(), _serializeForClipboar = serializeForClipboard(view, slice), dom = _serializeForClipboar.dom, text = _serializeForClipboar.text;
      if (data) {
        event.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text);
      } else {
        captureCopy(view, dom);
      }
      if (cut)
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    };
    function sliceSingleNode(slice) {
      return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
    }
    function capturePaste(view, event) {
      if (!view.dom.parentNode)
        return;
      var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
      var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
      if (!plainText)
        target.contentEditable = "true";
      target.style.cssText = "position: fixed; left: -10000px; top: 10px";
      target.focus();
      setTimeout(function() {
        view.focus();
        if (target.parentNode)
          target.parentNode.removeChild(target);
        if (plainText)
          doPaste(view, target.value, null, event);
        else
          doPaste(view, target.textContent, target.innerHTML, event);
      }, 50);
    }
    function doPaste(view, text, html, event) {
      var slice = parseFromClipboard(view, text, html, view.input.shiftKey, view.state.selection.$from);
      if (view.someProp("handlePaste", function(f) {
        return f(view, event, slice || prosemirrorModel.Slice.empty);
      }))
        return true;
      if (!slice)
        return false;
      var singleNode = sliceSingleNode(slice);
      var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice);
      view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
      return true;
    }
    editHandlers.paste = function(view, _event) {
      var event = _event;
      if (view.composing && !android)
        return;
      var data = brokenClipboardAPI ? null : event.clipboardData;
      if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), event))
        event.preventDefault();
      else
        capturePaste(view, event);
    };
    var Dragging = _createClass(function Dragging2(slice, move) {
      _classCallCheck(this, Dragging2);
      this.slice = slice;
      this.move = move;
    });
    var dragCopyModifier = mac ? "altKey" : "ctrlKey";
    handlers.dragstart = function(view, _event) {
      var event = _event;
      var mouseDown = view.input.mouseDown;
      if (mouseDown)
        mouseDown.done();
      if (!event.dataTransfer)
        return;
      var sel = view.state.selection;
      var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState.NodeSelection ? sel.to - 1 : sel.to))
        ;
      else if (mouseDown && mouseDown.mightDrag) {
        view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
      } else if (event.target && event.target.nodeType == 1) {
        var desc = view.docView.nearestDesc(event.target, true);
        if (desc && desc.node.type.spec.draggable && desc != view.docView)
          view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, desc.posBefore)));
      }
      var slice = view.state.selection.content(), _serializeForClipboar2 = serializeForClipboard(view, slice), dom = _serializeForClipboar2.dom, text = _serializeForClipboar2.text;
      event.dataTransfer.clearData();
      event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      event.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI)
        event.dataTransfer.setData("text/plain", text);
      view.dragging = new Dragging(slice, !event[dragCopyModifier]);
    };
    handlers.dragend = function(view) {
      var dragging = view.dragging;
      window.setTimeout(function() {
        if (view.dragging == dragging)
          view.dragging = null;
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = function(_, e) {
      return e.preventDefault();
    };
    editHandlers.drop = function(view, _event) {
      var event = _event;
      var dragging = view.dragging;
      view.dragging = null;
      if (!event.dataTransfer)
        return;
      var eventPos = view.posAtCoords(eventCoords(event));
      if (!eventPos)
        return;
      var $mouse = view.state.doc.resolve(eventPos.pos);
      var slice = dragging && dragging.slice;
      if (slice) {
        view.someProp("transformPasted", function(f) {
          slice = f(slice, view);
        });
      } else {
        slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
      }
      var move = !!(dragging && !event[dragCopyModifier]);
      if (view.someProp("handleDrop", function(f) {
        return f(view, event, slice || prosemirrorModel.Slice.empty, move);
      })) {
        event.preventDefault();
        return;
      }
      if (!slice)
        return;
      event.preventDefault();
      var insertPos = slice ? prosemirrorTransform.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
      if (insertPos == null)
        insertPos = $mouse.pos;
      var tr = view.state.tr;
      if (move)
        tr.deleteSelection();
      var pos = tr.mapping.map(insertPos);
      var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
      var beforeInsert = tr.doc;
      if (isNode)
        tr.replaceRangeWith(pos, pos, slice.content.firstChild);
      else
        tr.replaceRange(pos, pos, slice);
      if (tr.doc.eq(beforeInsert))
        return;
      var $pos = tr.doc.resolve(pos);
      if (isNode && prosemirrorState.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
        tr.setSelection(new prosemirrorState.NodeSelection($pos));
      } else {
        var end = tr.mapping.map(insertPos);
        tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
          return end = newTo;
        });
        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
      }
      view.focus();
      view.dispatch(tr.setMeta("uiEvent", "drop"));
    };
    handlers.focus = function(view) {
      view.input.lastFocus = Date.now();
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(function() {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
            selectionToDOM(view);
        }, 20);
      }
    };
    handlers.blur = function(view, _event) {
      var event = _event;
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        if (event.relatedTarget && view.dom.contains(event.relatedTarget))
          view.domObserver.currentSelection.clear();
        view.focused = false;
      }
    };
    handlers.beforeinput = function(view, _event) {
      var event = _event;
      if (chrome && android && event.inputType == "deleteContentBackward") {
        view.domObserver.flushSoon();
        var domChangeCount = view.input.domChangeCount;
        setTimeout(function() {
          if (view.input.domChangeCount != domChangeCount)
            return;
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(8, "Backspace"));
          }))
            return;
          var $cursor = view.state.selection.$cursor;
          if ($cursor && $cursor.pos > 0)
            view.dispatch(view.state.tr["delete"]($cursor.pos - 1, $cursor.pos).scrollIntoView());
        }, 50);
      }
    };
    for (prop in editHandlers) {
      handlers[prop] = editHandlers[prop];
    }
    var prop;
    function compareObjs(a, b) {
      if (a == b)
        return true;
      for (var p in a) {
        if (a[p] !== b[p])
          return false;
      }
      for (var _p in b) {
        if (!(_p in a))
          return false;
      }
      return true;
    }
    var WidgetType = function() {
      function WidgetType2(toDOM, spec) {
        _classCallCheck(this, WidgetType2);
        this.toDOM = toDOM;
        this.spec = spec || noSpec;
        this.side = this.spec.side || 0;
      }
      _createClass(WidgetType2, [{
        key: "map",
        value: function map(mapping, span, offset, oldOffset) {
          var _mapping$mapResult = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1), pos = _mapping$mapResult.pos, deleted = _mapping$mapResult.deleted;
          return deleted ? null : new Decoration(pos - offset, pos - offset, this);
        }
      }, {
        key: "valid",
        value: function valid() {
          return true;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || other instanceof WidgetType2 && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
        }
      }, {
        key: "destroy",
        value: function destroy(node) {
          if (this.spec.destroy)
            this.spec.destroy(node);
        }
      }]);
      return WidgetType2;
    }();
    var InlineType = function() {
      function InlineType2(attrs, spec) {
        _classCallCheck(this, InlineType2);
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      _createClass(InlineType2, [{
        key: "map",
        value: function map(mapping, span, offset, oldOffset) {
          var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
          var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
          return from >= to ? null : new Decoration(from, to, this);
        }
      }, {
        key: "valid",
        value: function valid(_, span) {
          return span.from < span.to;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || other instanceof InlineType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }], [{
        key: "is",
        value: function is(span) {
          return span.type instanceof InlineType2;
        }
      }]);
      return InlineType2;
    }();
    var NodeType = function() {
      function NodeType2(attrs, spec) {
        _classCallCheck(this, NodeType2);
        this.attrs = attrs;
        this.spec = spec || noSpec;
      }
      _createClass(NodeType2, [{
        key: "map",
        value: function map(mapping, span, offset, oldOffset) {
          var from = mapping.mapResult(span.from + oldOffset, 1);
          if (from.deleted)
            return null;
          var to = mapping.mapResult(span.to + oldOffset, -1);
          if (to.deleted || to.pos <= from.pos)
            return null;
          return new Decoration(from.pos - offset, to.pos - offset, this);
        }
      }, {
        key: "valid",
        value: function valid(node, span) {
          var _node$content$findInd = node.content.findIndex(span.from), index = _node$content$findInd.index, offset = _node$content$findInd.offset, child;
          return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
        }
      }, {
        key: "destroy",
        value: function destroy() {
        }
      }]);
      return NodeType2;
    }();
    var Decoration = function() {
      function Decoration2(from, to, type) {
        _classCallCheck(this, Decoration2);
        this.from = from;
        this.to = to;
        this.type = type;
      }
      _createClass(Decoration2, [{
        key: "copy",
        value: function copy(from, to) {
          return new Decoration2(from, to, this.type);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
        }
      }, {
        key: "map",
        value: function map(mapping, offset, oldOffset) {
          return this.type.map(mapping, this, offset, oldOffset);
        }
      }, {
        key: "spec",
        get: function get() {
          return this.type.spec;
        }
      }, {
        key: "inline",
        get: function get() {
          return this.type instanceof InlineType;
        }
      }], [{
        key: "widget",
        value: function widget(pos, toDOM, spec) {
          return new Decoration2(pos, pos, new WidgetType(toDOM, spec));
        }
      }, {
        key: "inline",
        value: function inline(from, to, attrs, spec) {
          return new Decoration2(from, to, new InlineType(attrs, spec));
        }
      }, {
        key: "node",
        value: function node(from, to, attrs, spec) {
          return new Decoration2(from, to, new NodeType(attrs, spec));
        }
      }]);
      return Decoration2;
    }();
    var none = [];
    var noSpec = {};
    var DecorationSet = function() {
      function DecorationSet2(local, children) {
        _classCallCheck(this, DecorationSet2);
        this.local = local.length ? local : none;
        this.children = children.length ? children : none;
      }
      _createClass(DecorationSet2, [{
        key: "find",
        value: function find(start, end, predicate) {
          var result = [];
          this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
          return result;
        }
      }, {
        key: "findInner",
        value: function findInner(start, end, result, offset, predicate) {
          for (var i = 0; i < this.local.length; i++) {
            var span = this.local[i];
            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
              result.push(span.copy(span.from + offset, span.to + offset));
          }
          for (var _i5 = 0; _i5 < this.children.length; _i5 += 3) {
            if (this.children[_i5] < end && this.children[_i5 + 1] > start) {
              var childOff = this.children[_i5] + 1;
              this.children[_i5 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
            }
          }
        }
      }, {
        key: "map",
        value: function map(mapping, doc2, options) {
          if (this == empty || mapping.maps.length == 0)
            return this;
          return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
        }
      }, {
        key: "mapInner",
        value: function mapInner(mapping, node, offset, oldOffset, options) {
          var newLocal;
          for (var i = 0; i < this.local.length; i++) {
            var mapped = this.local[i].map(mapping, offset, oldOffset);
            if (mapped && mapped.type.valid(node, mapped))
              (newLocal || (newLocal = [])).push(mapped);
            else if (options.onRemove)
              options.onRemove(this.local[i].spec);
          }
          if (this.children.length)
            return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);
          else
            return newLocal ? new DecorationSet2(newLocal.sort(byPos), none) : empty;
        }
      }, {
        key: "add",
        value: function add(doc2, decorations) {
          if (!decorations.length)
            return this;
          if (this == empty)
            return DecorationSet2.create(doc2, decorations);
          return this.addInner(doc2, decorations, 0);
        }
      }, {
        key: "addInner",
        value: function addInner(doc2, decorations, offset) {
          var _this10 = this;
          var children, childIndex = 0;
          doc2.forEach(function(childNode, childOffset) {
            var baseOffset = childOffset + offset, found;
            if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))
              return;
            if (!children)
              children = _this10.children.slice();
            while (childIndex < children.length && children[childIndex] < childOffset) {
              childIndex += 3;
            }
            if (children[childIndex] == childOffset)
              children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
            else
              children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
            childIndex += 3;
          });
          var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
          for (var i = 0; i < local.length; i++) {
            if (!local[i].type.valid(doc2, local[i]))
              local.splice(i--, 1);
          }
          return new DecorationSet2(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
        }
      }, {
        key: "remove",
        value: function remove(decorations) {
          if (decorations.length == 0 || this == empty)
            return this;
          return this.removeInner(decorations, 0);
        }
      }, {
        key: "removeInner",
        value: function removeInner(decorations, offset) {
          var children = this.children, local = this.local;
          for (var i = 0; i < children.length; i += 3) {
            var found = void 0;
            var from = children[i] + offset, to = children[i + 1] + offset;
            for (var j = 0, span; j < decorations.length; j++) {
              if (span = decorations[j]) {
                if (span.from > from && span.to < to) {
                  decorations[j] = null;
                  (found || (found = [])).push(span);
                }
              }
            }
            if (!found)
              continue;
            if (children == this.children)
              children = this.children.slice();
            var removed = children[i + 2].removeInner(found, from + 1);
            if (removed != empty) {
              children[i + 2] = removed;
            } else {
              children.splice(i, 3);
              i -= 3;
            }
          }
          if (local.length)
            for (var _i6 = 0, _span; _i6 < decorations.length; _i6++) {
              if (_span = decorations[_i6]) {
                for (var _j2 = 0; _j2 < local.length; _j2++) {
                  if (local[_j2].eq(_span, offset)) {
                    if (local == this.local)
                      local = this.local.slice();
                    local.splice(_j2--, 1);
                  }
                }
              }
            }
          if (children == this.children && local == this.local)
            return this;
          return local.length || children.length ? new DecorationSet2(local, children) : empty;
        }
      }, {
        key: "forChild",
        value: function forChild(offset, node) {
          if (this == empty)
            return this;
          if (node.isLeaf)
            return DecorationSet2.empty;
          var child, local;
          for (var i = 0; i < this.children.length; i += 3) {
            if (this.children[i] >= offset) {
              if (this.children[i] == offset)
                child = this.children[i + 2];
              break;
            }
          }
          var start = offset + 1, end = start + node.content.size;
          for (var _i7 = 0; _i7 < this.local.length; _i7++) {
            var dec = this.local[_i7];
            if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
              var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
              if (from < to)
                (local || (local = [])).push(dec.copy(from, to));
            }
          }
          if (local) {
            var localSet = new DecorationSet2(local.sort(byPos), none);
            return child ? new DecorationGroup([localSet, child]) : localSet;
          }
          return child || empty;
        }
      }, {
        key: "eq",
        value: function eq(other) {
          if (this == other)
            return true;
          if (!(other instanceof DecorationSet2) || this.local.length != other.local.length || this.children.length != other.children.length)
            return false;
          for (var i = 0; i < this.local.length; i++) {
            if (!this.local[i].eq(other.local[i]))
              return false;
          }
          for (var _i8 = 0; _i8 < this.children.length; _i8 += 3) {
            if (this.children[_i8] != other.children[_i8] || this.children[_i8 + 1] != other.children[_i8 + 1] || !this.children[_i8 + 2].eq(other.children[_i8 + 2]))
              return false;
          }
          return true;
        }
      }, {
        key: "locals",
        value: function locals(node) {
          return removeOverlap(this.localsInner(node));
        }
      }, {
        key: "localsInner",
        value: function localsInner(node) {
          if (this == empty)
            return none;
          if (node.inlineContent || !this.local.some(InlineType.is))
            return this.local;
          var result = [];
          for (var i = 0; i < this.local.length; i++) {
            if (!(this.local[i].type instanceof InlineType))
              result.push(this.local[i]);
          }
          return result;
        }
      }], [{
        key: "create",
        value: function create(doc2, decorations) {
          return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
        }
      }]);
      return DecorationSet2;
    }();
    DecorationSet.empty = new DecorationSet([], []);
    DecorationSet.removeOverlap = removeOverlap;
    var empty = DecorationSet.empty;
    var DecorationGroup = function() {
      function DecorationGroup2(members) {
        _classCallCheck(this, DecorationGroup2);
        this.members = members;
      }
      _createClass(DecorationGroup2, [{
        key: "map",
        value: function map(mapping, doc2) {
          var mappedDecos = this.members.map(function(member) {
            return member.map(mapping, doc2, noSpec);
          });
          return DecorationGroup2.from(mappedDecos);
        }
      }, {
        key: "forChild",
        value: function forChild(offset, child) {
          if (child.isLeaf)
            return DecorationSet.empty;
          var found = [];
          for (var i = 0; i < this.members.length; i++) {
            var result = this.members[i].forChild(offset, child);
            if (result == empty)
              continue;
            if (result instanceof DecorationGroup2)
              found = found.concat(result.members);
            else
              found.push(result);
          }
          return DecorationGroup2.from(found);
        }
      }, {
        key: "eq",
        value: function eq(other) {
          if (!(other instanceof DecorationGroup2) || other.members.length != this.members.length)
            return false;
          for (var i = 0; i < this.members.length; i++) {
            if (!this.members[i].eq(other.members[i]))
              return false;
          }
          return true;
        }
      }, {
        key: "locals",
        value: function locals(node) {
          var result, sorted = true;
          for (var i = 0; i < this.members.length; i++) {
            var locals2 = this.members[i].localsInner(node);
            if (!locals2.length)
              continue;
            if (!result) {
              result = locals2;
            } else {
              if (sorted) {
                result = result.slice();
                sorted = false;
              }
              for (var j = 0; j < locals2.length; j++) {
                result.push(locals2[j]);
              }
            }
          }
          return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
        }
      }], [{
        key: "from",
        value: function from(members) {
          switch (members.length) {
            case 0:
              return empty;
            case 1:
              return members[0];
            default:
              return new DecorationGroup2(members);
          }
        }
      }]);
      return DecorationGroup2;
    }();
    function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
      var children = oldChildren.slice();
      var _loop4 = function _loop42(i2, _baseOffset) {
        var moved = 0;
        mapping.maps[i2].forEach(function(oldStart, oldEnd, newStart, newEnd) {
          var dSize = newEnd - newStart - (oldEnd - oldStart);
          for (var _i12 = 0; _i12 < children.length; _i12 += 3) {
            var end = children[_i12 + 1];
            if (end < 0 || oldStart > end + _baseOffset - moved)
              continue;
            var start = children[_i12] + _baseOffset - moved;
            if (oldEnd >= start) {
              children[_i12 + 1] = oldStart <= start ? -2 : -1;
            } else if (newStart >= offset && dSize) {
              children[_i12] += dSize;
              children[_i12 + 1] += dSize;
            }
          }
          moved += dSize;
        });
        _baseOffset = mapping.maps[i2].map(_baseOffset, -1);
        baseOffset = _baseOffset;
      };
      for (var i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
        _loop4(i, baseOffset);
      }
      var mustRebuild = false;
      for (var _i9 = 0; _i9 < children.length; _i9 += 3) {
        if (children[_i9 + 1] < 0) {
          if (children[_i9 + 1] == -2) {
            mustRebuild = true;
            children[_i9 + 1] = -1;
            continue;
          }
          var from = mapping.map(oldChildren[_i9] + oldOffset), fromLocal = from - offset;
          if (fromLocal < 0 || fromLocal >= node.content.size) {
            mustRebuild = true;
            continue;
          }
          var to = mapping.map(oldChildren[_i9 + 1] + oldOffset, -1), toLocal = to - offset;
          var _node$content$findInd2 = node.content.findIndex(fromLocal), index = _node$content$findInd2.index, childOffset = _node$content$findInd2.offset;
          var childNode = node.maybeChild(index);
          if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
            var mapped = children[_i9 + 2].mapInner(mapping, childNode, from + 1, oldChildren[_i9] + oldOffset + 1, options);
            if (mapped != empty) {
              children[_i9] = fromLocal;
              children[_i9 + 1] = toLocal;
              children[_i9 + 2] = mapped;
            } else {
              children[_i9 + 1] = -2;
              mustRebuild = true;
            }
          } else {
            mustRebuild = true;
          }
        }
      }
      if (mustRebuild) {
        var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
        var built = buildTree(decorations, node, 0, options);
        newLocal = built.local;
        for (var _i10 = 0; _i10 < children.length; _i10 += 3) {
          if (children[_i10 + 1] < 0) {
            children.splice(_i10, 3);
            _i10 -= 3;
          }
        }
        for (var _i11 = 0, j = 0; _i11 < built.children.length; _i11 += 3) {
          var _from2 = built.children[_i11];
          while (j < children.length && children[j] < _from2) {
            j += 3;
          }
          children.splice(j, 0, built.children[_i11], built.children[_i11 + 1], built.children[_i11 + 2]);
        }
      }
      return new DecorationSet(newLocal.sort(byPos), children);
    }
    function moveSpans(spans, offset) {
      if (!offset || !spans.length)
        return spans;
      var result = [];
      for (var i = 0; i < spans.length; i++) {
        var span = spans[i];
        result.push(new Decoration(span.from + offset, span.to + offset, span.type));
      }
      return result;
    }
    function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
      function gather(set, oldOffset2) {
        for (var i2 = 0; i2 < set.local.length; i2++) {
          var mapped = set.local[i2].map(mapping, offset, oldOffset2);
          if (mapped)
            decorations.push(mapped);
          else if (options.onRemove)
            options.onRemove(set.local[i2].spec);
        }
        for (var _i13 = 0; _i13 < set.children.length; _i13 += 3) {
          gather(set.children[_i13 + 2], set.children[_i13] + oldOffset2 + 1);
        }
      }
      for (var i = 0; i < children.length; i += 3) {
        if (children[i + 1] == -1)
          gather(children[i + 2], oldChildren[i] + oldOffset + 1);
      }
      return decorations;
    }
    function takeSpansForNode(spans, node, offset) {
      if (node.isLeaf)
        return null;
      var end = offset + node.nodeSize, found = null;
      for (var i = 0, span; i < spans.length; i++) {
        if ((span = spans[i]) && span.from > offset && span.to < end) {
          (found || (found = [])).push(span);
          spans[i] = null;
        }
      }
      return found;
    }
    function withoutNulls(array) {
      var result = [];
      for (var i = 0; i < array.length; i++) {
        if (array[i] != null)
          result.push(array[i]);
      }
      return result;
    }
    function buildTree(spans, node, offset, options) {
      var children = [], hasNulls = false;
      node.forEach(function(childNode, localStart) {
        var found = takeSpansForNode(spans, childNode, localStart + offset);
        if (found) {
          hasNulls = true;
          var subtree = buildTree(found, childNode, offset + localStart + 1, options);
          if (subtree != empty)
            children.push(localStart, localStart + childNode.nodeSize, subtree);
        }
      });
      var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
      for (var i = 0; i < locals.length; i++) {
        if (!locals[i].type.valid(node, locals[i])) {
          if (options.onRemove)
            options.onRemove(locals[i].spec);
          locals.splice(i--, 1);
        }
      }
      return locals.length || children.length ? new DecorationSet(locals, children) : empty;
    }
    function byPos(a, b) {
      return a.from - b.from || a.to - b.to;
    }
    function removeOverlap(spans) {
      var working = spans;
      for (var i = 0; i < working.length - 1; i++) {
        var span = working[i];
        if (span.from != span.to)
          for (var j = i + 1; j < working.length; j++) {
            var next = working[j];
            if (next.from == span.from) {
              if (next.to != span.to) {
                if (working == spans)
                  working = spans.slice();
                working[j] = next.copy(next.from, span.to);
                insertAhead(working, j + 1, next.copy(span.to, next.to));
              }
              continue;
            } else {
              if (next.from < span.to) {
                if (working == spans)
                  working = spans.slice();
                working[i] = span.copy(span.from, next.from);
                insertAhead(working, j, span.copy(next.from, span.to));
              }
              break;
            }
          }
      }
      return working;
    }
    function insertAhead(array, i, deco) {
      while (i < array.length && byPos(deco, array[i]) > 0) {
        i++;
      }
      array.splice(i, 0, deco);
    }
    function viewDecorations(view) {
      var found = [];
      view.someProp("decorations", function(f) {
        var result = f(view.state);
        if (result && result != empty)
          found.push(result);
      });
      if (view.cursorWrapper)
        found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
      return DecorationGroup.from(found);
    }
    var observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    var useCharData = ie && ie_version <= 11;
    var SelectionState = function() {
      function SelectionState2() {
        _classCallCheck(this, SelectionState2);
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
      }
      _createClass(SelectionState2, [{
        key: "set",
        value: function set(sel) {
          this.anchorNode = sel.anchorNode;
          this.anchorOffset = sel.anchorOffset;
          this.focusNode = sel.focusNode;
          this.focusOffset = sel.focusOffset;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.anchorNode = this.focusNode = null;
        }
      }, {
        key: "eq",
        value: function eq(sel) {
          return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
        }
      }]);
      return SelectionState2;
    }();
    var DOMObserver = function() {
      function DOMObserver2(view, handleDOMChange) {
        var _this11 = this;
        _classCallCheck(this, DOMObserver2);
        this.view = view;
        this.handleDOMChange = handleDOMChange;
        this.queue = [];
        this.flushingSoon = -1;
        this.observer = null;
        this.currentSelection = new SelectionState();
        this.onCharData = null;
        this.suppressingSelectionUpdates = false;
        this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
          for (var i = 0; i < mutations.length; i++) {
            _this11.queue.push(mutations[i]);
          }
          if (ie && ie_version <= 11 && mutations.some(function(m) {
            return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
          }))
            _this11.flushSoon();
          else
            _this11.flush();
        });
        if (useCharData) {
          this.onCharData = function(e) {
            _this11.queue.push({
              target: e.target,
              type: "characterData",
              oldValue: e.prevValue
            });
            _this11.flushSoon();
          };
        }
        this.onSelectionChange = this.onSelectionChange.bind(this);
      }
      _createClass(DOMObserver2, [{
        key: "flushSoon",
        value: function flushSoon() {
          var _this12 = this;
          if (this.flushingSoon < 0)
            this.flushingSoon = window.setTimeout(function() {
              _this12.flushingSoon = -1;
              _this12.flush();
            }, 20);
        }
      }, {
        key: "forceFlush",
        value: function forceFlush() {
          if (this.flushingSoon > -1) {
            window.clearTimeout(this.flushingSoon);
            this.flushingSoon = -1;
            this.flush();
          }
        }
      }, {
        key: "start",
        value: function start() {
          if (this.observer) {
            this.observer.takeRecords();
            this.observer.observe(this.view.dom, observeOptions);
          }
          if (this.onCharData)
            this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
          this.connectSelection();
        }
      }, {
        key: "stop",
        value: function stop() {
          var _this13 = this;
          if (this.observer) {
            var take = this.observer.takeRecords();
            if (take.length) {
              for (var i = 0; i < take.length; i++) {
                this.queue.push(take[i]);
              }
              window.setTimeout(function() {
                return _this13.flush();
              }, 20);
            }
            this.observer.disconnect();
          }
          if (this.onCharData)
            this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
          this.disconnectSelection();
        }
      }, {
        key: "connectSelection",
        value: function connectSelection() {
          this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
        }
      }, {
        key: "disconnectSelection",
        value: function disconnectSelection() {
          this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
        }
      }, {
        key: "suppressSelectionUpdates",
        value: function suppressSelectionUpdates() {
          var _this14 = this;
          this.suppressingSelectionUpdates = true;
          setTimeout(function() {
            return _this14.suppressingSelectionUpdates = false;
          }, 50);
        }
      }, {
        key: "onSelectionChange",
        value: function onSelectionChange() {
          if (!hasFocusAndSelection(this.view))
            return;
          if (this.suppressingSelectionUpdates)
            return selectionToDOM(this.view);
          if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
            var sel = this.view.domSelectionRange();
            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
              return this.flushSoon();
          }
          this.flush();
        }
      }, {
        key: "setCurSelection",
        value: function setCurSelection() {
          this.currentSelection.set(this.view.domSelectionRange());
        }
      }, {
        key: "ignoreSelectionChange",
        value: function ignoreSelectionChange(sel) {
          if (!sel.focusNode)
            return true;
          var ancestors = /* @__PURE__ */ new Set(), container;
          for (var scan = sel.focusNode; scan; scan = parentNode(scan)) {
            ancestors.add(scan);
          }
          for (var _scan = sel.anchorNode; _scan; _scan = parentNode(_scan)) {
            if (ancestors.has(_scan)) {
              container = _scan;
              break;
            }
          }
          var desc = container && this.view.docView.nearestDesc(container);
          if (desc && desc.ignoreMutation({
            type: "selection",
            target: container.nodeType == 3 ? container.parentNode : container
          })) {
            this.setCurSelection();
            return true;
          }
        }
      }, {
        key: "flush",
        value: function flush() {
          var view = this.view;
          if (!view.docView || this.flushingSoon > -1)
            return;
          var mutations = this.observer ? this.observer.takeRecords() : [];
          if (this.queue.length) {
            mutations = this.queue.concat(mutations);
            this.queue.length = 0;
          }
          var sel = view.domSelectionRange();
          var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
          var from = -1, to = -1, typeOver = false, added = [];
          if (view.editable) {
            for (var i = 0; i < mutations.length; i++) {
              var result = this.registerMutation(mutations[i], added);
              if (result) {
                from = from < 0 ? result.from : Math.min(result.from, from);
                to = to < 0 ? result.to : Math.max(result.to, to);
                if (result.typeOver)
                  typeOver = true;
              }
            }
          }
          if (gecko && added.length > 1) {
            var brs = added.filter(function(n) {
              return n.nodeName == "BR";
            });
            if (brs.length == 2) {
              var a = brs[0], b = brs[1];
              if (a.parentNode && a.parentNode.parentNode == b.parentNode)
                b.remove();
              else
                a.remove();
            }
          }
          var readSel = null;
          if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && view.input.lastTouch < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirrorState.Selection.near(view.state.doc.resolve(0), 1))) {
            view.input.lastFocus = 0;
            selectionToDOM(view);
            this.currentSelection.set(sel);
            view.scrollToSelection();
          } else if (from > -1 || newSel) {
            if (from > -1) {
              view.docView.markDirty(from, to);
              checkCSS(view);
            }
            this.handleDOMChange(from, to, typeOver, added);
            if (view.docView && view.docView.dirty)
              view.updateState(view.state);
            else if (!this.currentSelection.eq(sel))
              selectionToDOM(view);
            this.currentSelection.set(sel);
          }
        }
      }, {
        key: "registerMutation",
        value: function registerMutation(mut, added) {
          if (added.indexOf(mut.target) > -1)
            return null;
          var desc = this.view.docView.nearestDesc(mut.target);
          if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
            return null;
          if (!desc || desc.ignoreMutation(mut))
            return null;
          if (mut.type == "childList") {
            for (var i = 0; i < mut.addedNodes.length; i++) {
              added.push(mut.addedNodes[i]);
            }
            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
              return {
                from: desc.posBefore,
                to: desc.posAfter
              };
            var prev = mut.previousSibling, next = mut.nextSibling;
            if (ie && ie_version <= 11 && mut.addedNodes.length) {
              for (var _i14 = 0; _i14 < mut.addedNodes.length; _i14++) {
                var _mut$addedNodes$_i = mut.addedNodes[_i14], previousSibling = _mut$addedNodes$_i.previousSibling, nextSibling = _mut$addedNodes$_i.nextSibling;
                if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
                  prev = previousSibling;
                if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
                  next = nextSibling;
              }
            }
            var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
            var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
            var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
            var to = desc.localPosFromDOM(mut.target, toOffset, 1);
            return {
              from,
              to
            };
          } else if (mut.type == "attributes") {
            return {
              from: desc.posAtStart - desc.border,
              to: desc.posAtEnd + desc.border
            };
          } else {
            return {
              from: desc.posAtStart,
              to: desc.posAtEnd,
              typeOver: mut.target.nodeValue == mut.oldValue
            };
          }
        }
      }]);
      return DOMObserver2;
    }();
    var cssChecked = /* @__PURE__ */ new WeakMap();
    var cssCheckWarned = false;
    function checkCSS(view) {
      if (cssChecked.has(view))
        return;
      cssChecked.set(view, null);
      if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
        view.requiresGeckoHackNode = gecko;
        if (cssCheckWarned)
          return;
        console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
        cssCheckWarned = true;
      }
    }
    function safariShadowSelectionRange(view) {
      var found;
      function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
      }
      view.dom.addEventListener("beforeinput", read, true);
      document.execCommand("indent");
      view.dom.removeEventListener("beforeinput", read, true);
      var anchorNode = found.startContainer, anchorOffset = found.startOffset;
      var focusNode = found.endContainer, focusOffset = found.endOffset;
      var currentAnchor = view.domAtPos(view.state.selection.anchor);
      if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) {
        var _ref3 = [focusNode, focusOffset, anchorNode, anchorOffset];
        anchorNode = _ref3[0];
        anchorOffset = _ref3[1];
        focusNode = _ref3[2];
        focusOffset = _ref3[3];
      }
      return {
        anchorNode,
        anchorOffset,
        focusNode,
        focusOffset
      };
    }
    function parseBetween(view, from_, to_) {
      var _view$docView$parseRa = view.docView.parseRange(from_, to_), parent = _view$docView$parseRa.node, fromOffset = _view$docView$parseRa.fromOffset, toOffset = _view$docView$parseRa.toOffset, from = _view$docView$parseRa.from, to = _view$docView$parseRa.to;
      var domSel = view.domSelectionRange();
      var find;
      var anchor = domSel.anchorNode;
      if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
        find = [{
          node: anchor,
          offset: domSel.anchorOffset
        }];
        if (!selectionCollapsed(domSel))
          find.push({
            node: domSel.focusNode,
            offset: domSel.focusOffset
          });
      }
      if (chrome && view.input.lastKeyCode === 8) {
        for (var off = toOffset; off > fromOffset; off--) {
          var node = parent.childNodes[off - 1], desc = node.pmViewDesc;
          if (node.nodeName == "BR" && !desc) {
            toOffset = off;
            break;
          }
          if (!desc || desc.size)
            break;
        }
      }
      var startDoc = view.state.doc;
      var parser = view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
      var $from = startDoc.resolve(from);
      var sel = null, doc2 = parser.parse(parent, {
        topNode: $from.parent,
        topMatch: $from.parent.contentMatchAt($from.index()),
        topOpen: true,
        from: fromOffset,
        to: toOffset,
        preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
        findPositions: find,
        ruleFromNode,
        context: $from
      });
      if (find && find[0].pos != null) {
        var _anchor = find[0].pos, head = find[1] && find[1].pos;
        if (head == null)
          head = _anchor;
        sel = {
          anchor: _anchor + from,
          head: head + from
        };
      }
      return {
        doc: doc2,
        sel,
        from,
        to
      };
    }
    function ruleFromNode(dom) {
      var desc = dom.pmViewDesc;
      if (desc) {
        return desc.parseRule();
      } else if (dom.nodeName == "BR" && dom.parentNode) {
        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
          var skip = document.createElement("div");
          skip.appendChild(document.createElement("li"));
          return {
            skip
          };
        } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
          return {
            ignore: true
          };
        }
      } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
        return {
          ignore: true
        };
      }
      return null;
    }
    function readDOMChange(view, from, to, typeOver, addedNodes) {
      if (from < 0) {
        var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
        var newSel = selectionFromDOM(view, origin);
        if (newSel && !view.state.selection.eq(newSel)) {
          var _tr = view.state.tr.setSelection(newSel);
          if (origin == "pointer")
            _tr.setMeta("pointer", true);
          else if (origin == "key")
            _tr.scrollIntoView();
          view.dispatch(_tr);
        }
        return;
      }
      var $before = view.state.doc.resolve(from);
      var shared = $before.sharedDepth(to);
      from = $before.before(shared + 1);
      to = view.state.doc.resolve(to).after(shared + 1);
      var sel = view.state.selection;
      var parse = parseBetween(view, from, to);
      var doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
      var preferredPos, preferredSide;
      if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
        preferredPos = view.state.selection.to;
        preferredSide = "end";
      } else {
        preferredPos = view.state.selection.from;
        preferredSide = "start";
      }
      view.input.lastKeyCode = null;
      var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
      if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function(n) {
        return n.nodeName == "DIV" || n.nodeName == "P" || n.nodeName == "LI";
      }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      })) {
        view.input.lastIOSEnter = 0;
        return;
      }
      if (!change) {
        if (typeOver && sel instanceof prosemirrorState.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
          change = {
            start: sel.from,
            endA: sel.to,
            endB: sel.to
          };
        } else {
          if (parse.sel) {
            var _sel = resolveSelection(view, view.state.doc, parse.sel);
            if (_sel && !_sel.eq(view.state.selection))
              view.dispatch(view.state.tr.setSelection(_sel));
          }
          return;
        }
      }
      if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {
        var size = change.endB - change.start;
        parse.sel = {
          anchor: parse.sel.anchor + size,
          head: parse.sel.anchor + size
        };
      }
      view.input.domChangeCount++;
      if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirrorState.TextSelection) {
        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
          change.start = view.state.selection.from;
        } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
          change.endB += view.state.selection.to - change.endA;
          change.endA = view.state.selection.to;
        }
      }
      if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
        change.start--;
        change.endA--;
        change.endB--;
      }
      var $from = parse.doc.resolveNoCache(change.start - parse.from);
      var $to = parse.doc.resolveNoCache(change.endB - parse.from);
      var $fromA = doc2.resolve(change.start);
      var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
      var nextSel;
      if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n) {
        return n.nodeName == "DIV" || n.nodeName == "P";
      })) || !inlineChange && $from.pos < parse.doc.content.size && (nextSel = prosemirrorState.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      })) {
        view.input.lastIOSEnter = 0;
        return;
      }
      if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(8, "Backspace"));
      })) {
        if (android && chrome)
          view.domObserver.suppressSelectionUpdates();
        return;
      }
      if (chrome && android && change.endB == change.start)
        view.input.lastAndroidDelete = Date.now();
      if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
        change.endB -= 2;
        $to = parse.doc.resolveNoCache(change.endB - parse.from);
        setTimeout(function() {
          view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(13, "Enter"));
          });
        }, 20);
      }
      var chFrom = change.start, chTo = change.endA;
      var tr, storedMarks, markChange;
      if (inlineChange) {
        if ($from.pos == $to.pos) {
          if (ie && ie_version <= 11 && $from.parentOffset == 0) {
            view.domObserver.suppressSelectionUpdates();
            setTimeout(function() {
              return selectionToDOM(view);
            }, 20);
          }
          tr = view.state.tr["delete"](chFrom, chTo);
          storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
        } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
          tr = view.state.tr;
          if (markChange.type == "add")
            tr.addMark(chFrom, chTo, markChange.mark);
          else
            tr.removeMark(chFrom, chTo, markChange.mark);
        } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
          var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
          if (view.someProp("handleTextInput", function(f) {
            return f(view, chFrom, chTo, text);
          }))
            return;
          tr = view.state.tr.insertText(text, chFrom, chTo);
        }
      }
      if (!tr)
        tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
      if (parse.sel) {
        var _sel2 = resolveSelection(view, tr.doc, parse.sel);
        if (_sel2 && !(chrome && android && view.composing && _sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (_sel2.head == chFrom || _sel2.head == tr.mapping.map(chTo) - 1) || ie && _sel2.empty && _sel2.head == chFrom))
          tr.setSelection(_sel2);
      }
      if (storedMarks)
        tr.ensureMarks(storedMarks);
      view.dispatch(tr.scrollIntoView());
    }
    function resolveSelection(view, doc2, parsedSel) {
      if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
        return null;
      return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
    }
    function isMarkChange(cur, prev) {
      var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
      var added = curMarks, removed = prevMarks, type, mark, update;
      for (var i = 0; i < prevMarks.length; i++) {
        added = prevMarks[i].removeFromSet(added);
      }
      for (var _i15 = 0; _i15 < curMarks.length; _i15++) {
        removed = curMarks[_i15].removeFromSet(removed);
      }
      if (added.length == 1 && removed.length == 0) {
        mark = added[0];
        type = "add";
        update = function update2(node) {
          return node.mark(mark.addToSet(node.marks));
        };
      } else if (added.length == 0 && removed.length == 1) {
        mark = removed[0];
        type = "remove";
        update = function update2(node) {
          return node.mark(mark.removeFromSet(node.marks));
        };
      } else {
        return null;
      }
      var updated = [];
      for (var _i16 = 0; _i16 < prev.childCount; _i16++) {
        updated.push(update(prev.child(_i16)));
      }
      if (prosemirrorModel.Fragment.from(updated).eq(cur))
        return {
          mark,
          type
        };
    }
    function looksLikeJoin(old, start, end, $newStart, $newEnd) {
      if (!$newStart.parent.isTextblock || end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
        return false;
      var $start = old.resolve(start);
      if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
        return false;
      var $next = old.resolve(skipClosingAndOpening($start, true, true));
      if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)
        return false;
      return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
    }
    function skipClosingAndOpening($pos, fromEnd, mayOpen) {
      var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
      while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
        depth--;
        end++;
        fromEnd = false;
      }
      if (mayOpen) {
        var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
        while (next && !next.isLeaf) {
          next = next.firstChild;
          end++;
        }
      }
      return end;
    }
    function findDiff(a, b, pos, preferredPos, preferredSide) {
      var start = a.findDiffStart(b, pos);
      if (start == null)
        return null;
      var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size), endA = _a$findDiffEnd.a, endB = _a$findDiffEnd.b;
      if (preferredSide == "end") {
        var adjust = Math.max(0, start - Math.min(endA, endB));
        preferredPos -= endA + adjust - start;
      }
      if (endA < start && a.size < b.size) {
        var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
        start -= move;
        endB = start + (endB - endA);
        endA = start;
      } else if (endB < start) {
        var _move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
        start -= _move;
        endA = start + (endA - endB);
        endB = start;
      }
      return {
        start,
        endA,
        endB
      };
    }
    var __serializeForClipboard = serializeForClipboard;
    var __parseFromClipboard = parseFromClipboard;
    var __endComposition = endComposition;
    var EditorView = function() {
      function EditorView2(place, props) {
        var _this15 = this;
        _classCallCheck(this, EditorView2);
        this._root = null;
        this.focused = false;
        this.trackWrites = null;
        this.mounted = false;
        this.markCursor = null;
        this.cursorWrapper = null;
        this.lastSelectedViewDesc = void 0;
        this.input = new InputState();
        this.prevDirectPlugins = [];
        this.pluginViews = [];
        this.requiresGeckoHackNode = false;
        this.dragging = null;
        this._props = props;
        this.state = props.state;
        this.directPlugins = props.plugins || [];
        this.directPlugins.forEach(checkStateComponent);
        this.dispatch = this.dispatch.bind(this);
        this.dom = place && place.mount || document.createElement("div");
        if (place) {
          if (place.appendChild)
            place.appendChild(this.dom);
          else if (typeof place == "function")
            place(this.dom);
          else if (place.mount)
            this.mounted = true;
        }
        this.editable = getEditable(this);
        updateCursorWrapper(this);
        this.nodeViews = buildNodeViews(this);
        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
        this.domObserver = new DOMObserver(this, function(from, to, typeOver, added) {
          return readDOMChange(_this15, from, to, typeOver, added);
        });
        this.domObserver.start();
        initInput(this);
        this.updatePluginViews();
      }
      _createClass(EditorView2, [{
        key: "composing",
        get: function get() {
          return this.input.composing;
        }
      }, {
        key: "props",
        get: function get() {
          if (this._props.state != this.state) {
            var prev = this._props;
            this._props = {};
            for (var name in prev) {
              this._props[name] = prev[name];
            }
            this._props.state = this.state;
          }
          return this._props;
        }
      }, {
        key: "update",
        value: function update(props) {
          if (props.handleDOMEvents != this._props.handleDOMEvents)
            ensureListeners(this);
          var prevProps = this._props;
          this._props = props;
          if (props.plugins) {
            props.plugins.forEach(checkStateComponent);
            this.directPlugins = props.plugins;
          }
          this.updateStateInner(props.state, prevProps);
        }
      }, {
        key: "setProps",
        value: function setProps(props) {
          var updated = {};
          for (var name in this._props) {
            updated[name] = this._props[name];
          }
          updated.state = this.state;
          for (var _name2 in props) {
            updated[_name2] = props[_name2];
          }
          this.update(updated);
        }
      }, {
        key: "updateState",
        value: function updateState(state) {
          this.updateStateInner(state, this._props);
        }
      }, {
        key: "updateStateInner",
        value: function updateStateInner(state, prevProps) {
          var prev = this.state, redraw = false, updateSel = false;
          if (state.storedMarks && this.composing) {
            clearComposition(this);
            updateSel = true;
          }
          this.state = state;
          var pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
          if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
            var nodeViews = buildNodeViews(this);
            if (changedNodeViews(nodeViews, this.nodeViews)) {
              this.nodeViews = nodeViews;
              redraw = true;
            }
          }
          if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
            ensureListeners(this);
          }
          this.editable = getEditable(this);
          updateCursorWrapper(this);
          var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
          var scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
          var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
          if (updateDoc || !state.selection.eq(prev.selection))
            updateSel = true;
          var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
          if (updateSel) {
            this.domObserver.stop();
            var forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
            if (updateDoc) {
              var chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
              if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
                this.docView.updateOuterDeco([]);
                this.docView.destroy();
                this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
              }
              if (chromeKludge && !this.trackWrites)
                forceSelUpdate = true;
            }
            if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
              selectionToDOM(this, forceSelUpdate);
            } else {
              syncNodeSelection(this, state.selection);
              this.domObserver.setCurSelection();
            }
            this.domObserver.start();
          }
          this.updatePluginViews(prev);
          if (scroll == "reset") {
            this.dom.scrollTop = 0;
          } else if (scroll == "to selection") {
            this.scrollToSelection();
          } else if (oldScrollPos) {
            resetScrollPos(oldScrollPos);
          }
        }
      }, {
        key: "scrollToSelection",
        value: function scrollToSelection() {
          var _this16 = this;
          var startDOM = this.domSelectionRange().focusNode;
          if (this.someProp("handleScrollToSelection", function(f) {
            return f(_this16);
          }))
            ;
          else if (this.state.selection instanceof prosemirrorState.NodeSelection) {
            var target = this.docView.domAfterPos(this.state.selection.from);
            if (target.nodeType == 1)
              scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
          } else {
            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
          }
        }
      }, {
        key: "destroyPluginViews",
        value: function destroyPluginViews() {
          var view;
          while (view = this.pluginViews.pop()) {
            if (view.destroy)
              view.destroy();
          }
        }
      }, {
        key: "updatePluginViews",
        value: function updatePluginViews(prevState) {
          if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
            this.prevDirectPlugins = this.directPlugins;
            this.destroyPluginViews();
            for (var i = 0; i < this.directPlugins.length; i++) {
              var plugin = this.directPlugins[i];
              if (plugin.spec.view)
                this.pluginViews.push(plugin.spec.view(this));
            }
            for (var _i17 = 0; _i17 < this.state.plugins.length; _i17++) {
              var _plugin = this.state.plugins[_i17];
              if (_plugin.spec.view)
                this.pluginViews.push(_plugin.spec.view(this));
            }
          } else {
            for (var _i18 = 0; _i18 < this.pluginViews.length; _i18++) {
              var pluginView = this.pluginViews[_i18];
              if (pluginView.update)
                pluginView.update(this, prevState);
            }
          }
        }
      }, {
        key: "someProp",
        value: function someProp(propName, f) {
          var prop2 = this._props && this._props[propName], value;
          if (prop2 != null && (value = f ? f(prop2) : prop2))
            return value;
          for (var i = 0; i < this.directPlugins.length; i++) {
            var _prop = this.directPlugins[i].props[propName];
            if (_prop != null && (value = f ? f(_prop) : _prop))
              return value;
          }
          var plugins = this.state.plugins;
          if (plugins)
            for (var _i19 = 0; _i19 < plugins.length; _i19++) {
              var _prop2 = plugins[_i19].props[propName];
              if (_prop2 != null && (value = f ? f(_prop2) : _prop2))
                return value;
            }
        }
      }, {
        key: "hasFocus",
        value: function hasFocus() {
          if (ie) {
            var node = this.root.activeElement;
            if (node == this.dom)
              return true;
            if (!node || !this.dom.contains(node))
              return false;
            while (node && this.dom != node && this.dom.contains(node)) {
              if (node.contentEditable == "false")
                return false;
              node = node.parentElement;
            }
            return true;
          }
          return this.root.activeElement == this.dom;
        }
      }, {
        key: "focus",
        value: function focus() {
          this.domObserver.stop();
          if (this.editable)
            focusPreventScroll(this.dom);
          selectionToDOM(this);
          this.domObserver.start();
        }
      }, {
        key: "root",
        get: function get() {
          var _this17 = this;
          var cached = this._root;
          if (cached == null) {
            var _loop5 = function _loop52(search2) {
              if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
                if (!search2.getSelection)
                  Object.getPrototypeOf(search2).getSelection = function() {
                    return search2.ownerDocument.getSelection();
                  };
                return {
                  v: _this17._root = search2
                };
              }
            };
            for (var search = this.dom.parentNode; search; search = search.parentNode) {
              var _ret3 = _loop5(search);
              if (_typeof(_ret3) === "object")
                return _ret3.v;
            }
          }
          return cached || document;
        }
      }, {
        key: "posAtCoords",
        value: function posAtCoords(coords) {
          return _posAtCoords(this, coords);
        }
      }, {
        key: "coordsAtPos",
        value: function coordsAtPos(pos) {
          var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return _coordsAtPos(this, pos, side);
        }
      }, {
        key: "domAtPos",
        value: function domAtPos(pos) {
          var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return this.docView.domFromPos(pos, side);
        }
      }, {
        key: "nodeDOM",
        value: function nodeDOM(pos) {
          var desc = this.docView.descAt(pos);
          return desc ? desc.nodeDOM : null;
        }
      }, {
        key: "posAtDOM",
        value: function posAtDOM(node, offset) {
          var bias = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
          var pos = this.docView.posFromDOM(node, offset, bias);
          if (pos == null)
            throw new RangeError("DOM position not inside the editor");
          return pos;
        }
      }, {
        key: "endOfTextblock",
        value: function endOfTextblock(dir, state) {
          return _endOfTextblock(this, state || this.state, dir);
        }
      }, {
        key: "destroy",
        value: function destroy() {
          if (!this.docView)
            return;
          destroyInput(this);
          this.destroyPluginViews();
          if (this.mounted) {
            this.docView.update(this.state.doc, [], viewDecorations(this), this);
            this.dom.textContent = "";
          } else if (this.dom.parentNode) {
            this.dom.parentNode.removeChild(this.dom);
          }
          this.docView.destroy();
          this.docView = null;
        }
      }, {
        key: "isDestroyed",
        get: function get() {
          return this.docView == null;
        }
      }, {
        key: "dispatchEvent",
        value: function dispatchEvent(event) {
          return _dispatchEvent(this, event);
        }
      }, {
        key: "dispatch",
        value: function dispatch(tr) {
          var dispatchTransaction = this._props.dispatchTransaction;
          if (dispatchTransaction)
            dispatchTransaction.call(this, tr);
          else
            this.updateState(this.state.apply(tr));
        }
      }, {
        key: "domSelectionRange",
        value: function domSelectionRange() {
          return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
        }
      }, {
        key: "domSelection",
        value: function domSelection() {
          return this.root.getSelection();
        }
      }]);
      return EditorView2;
    }();
    function computeDocDeco(view) {
      var attrs = /* @__PURE__ */ Object.create(null);
      attrs["class"] = "ProseMirror";
      attrs.contenteditable = String(view.editable);
      attrs.translate = "no";
      view.someProp("attributes", function(value) {
        if (typeof value == "function")
          value = value(view.state);
        if (value)
          for (var attr in value) {
            if (attr == "class")
              attrs["class"] += " " + value[attr];
            if (attr == "style") {
              attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
            } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
              attrs[attr] = String(value[attr]);
          }
      });
      return [Decoration.node(0, view.state.doc.content.size, attrs)];
    }
    function updateCursorWrapper(view) {
      if (view.markCursor) {
        var dom = document.createElement("img");
        dom.className = "ProseMirror-separator";
        dom.setAttribute("mark-placeholder", "true");
        dom.setAttribute("alt", "");
        view.cursorWrapper = {
          dom,
          deco: Decoration.widget(view.state.selection.head, dom, {
            raw: true,
            marks: view.markCursor
          })
        };
      } else {
        view.cursorWrapper = null;
      }
    }
    function getEditable(view) {
      return !view.someProp("editable", function(value) {
        return value(view.state) === false;
      });
    }
    function selectionContextChanged(sel1, sel2) {
      var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
      return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
    }
    function buildNodeViews(view) {
      var result = /* @__PURE__ */ Object.create(null);
      function add(obj) {
        for (var _prop3 in obj) {
          if (!Object.prototype.hasOwnProperty.call(result, _prop3))
            result[_prop3] = obj[_prop3];
        }
      }
      view.someProp("nodeViews", add);
      view.someProp("markViews", add);
      return result;
    }
    function changedNodeViews(a, b) {
      var nA = 0, nB = 0;
      for (var _prop4 in a) {
        if (a[_prop4] != b[_prop4])
          return true;
        nA++;
      }
      for (var _ in b) {
        nB++;
      }
      return nA != nB;
    }
    function checkStateComponent(plugin) {
      if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
        throw new RangeError("Plugins passed directly to the view must not have a state component");
    }
    exports.Decoration = Decoration;
    exports.DecorationSet = DecorationSet;
    exports.EditorView = EditorView;
    exports.__endComposition = __endComposition;
    exports.__parseFromClipboard = __parseFromClipboard;
    exports.__serializeForClipboard = __serializeForClipboard;
  }
});

// node_modules/prosemirror-tables/dist/index.cjs
var require_dist7 = __commonJS({
  "node_modules/prosemirror-tables/dist/index.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorState = require_dist4();
    var prosemirrorModel = require_dist2();
    var prosemirrorKeymap = require_dist5();
    var prosemirrorView = require_dist6();
    var prosemirrorTransform = require_dist3();
    var readFromCache;
    var addToCache;
    if (typeof WeakMap != "undefined") {
      let cache = /* @__PURE__ */ new WeakMap();
      readFromCache = (key2) => cache.get(key2);
      addToCache = (key2, value) => {
        cache.set(key2, value);
        return value;
      };
    } else {
      let cache = [], cacheSize = 10, cachePos = 0;
      readFromCache = (key2) => {
        for (let i = 0; i < cache.length; i += 2)
          if (cache[i] == key2)
            return cache[i + 1];
      };
      addToCache = (key2, value) => {
        if (cachePos == cacheSize)
          cachePos = 0;
        cache[cachePos++] = key2;
        return cache[cachePos++] = value;
      };
    }
    var Rect = class {
      constructor(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
      }
    };
    var TableMap = class {
      constructor(width, height, map, problems) {
        this.width = width;
        this.height = height;
        this.map = map;
        this.problems = problems;
      }
      findCell(pos) {
        for (let i = 0; i < this.map.length; i++) {
          let curPos = this.map[i];
          if (curPos != pos)
            continue;
          let left = i % this.width, top = i / this.width | 0;
          let right = left + 1, bottom = top + 1;
          for (let j = 1; right < this.width && this.map[i + j] == curPos; j++)
            right++;
          for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++)
            bottom++;
          return new Rect(left, top, right, bottom);
        }
        throw new RangeError("No cell with offset " + pos + " found");
      }
      colCount(pos) {
        for (let i = 0; i < this.map.length; i++)
          if (this.map[i] == pos)
            return i % this.width;
        throw new RangeError("No cell with offset " + pos + " found");
      }
      nextCell(pos, axis, dir) {
        let { left, right, top, bottom } = this.findCell(pos);
        if (axis == "horiz") {
          if (dir < 0 ? left == 0 : right == this.width)
            return null;
          return this.map[top * this.width + (dir < 0 ? left - 1 : right)];
        } else {
          if (dir < 0 ? top == 0 : bottom == this.height)
            return null;
          return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];
        }
      }
      rectBetween(a, b) {
        let {
          left: leftA,
          right: rightA,
          top: topA,
          bottom: bottomA
        } = this.findCell(a);
        let {
          left: leftB,
          right: rightB,
          top: topB,
          bottom: bottomB
        } = this.findCell(b);
        return new Rect(
          Math.min(leftA, leftB),
          Math.min(topA, topB),
          Math.max(rightA, rightB),
          Math.max(bottomA, bottomB)
        );
      }
      cellsInRect(rect) {
        let result = [], seen = {};
        for (let row = rect.top; row < rect.bottom; row++) {
          for (let col = rect.left; col < rect.right; col++) {
            let index = row * this.width + col, pos = this.map[index];
            if (seen[pos])
              continue;
            seen[pos] = true;
            if ((col != rect.left || !col || this.map[index - 1] != pos) && (row != rect.top || !row || this.map[index - this.width] != pos))
              result.push(pos);
          }
        }
        return result;
      }
      positionAt(row, col, table) {
        for (let i = 0, rowStart = 0; ; i++) {
          let rowEnd = rowStart + table.child(i).nodeSize;
          if (i == row) {
            let index = col + row * this.width, rowEndIndex = (row + 1) * this.width;
            while (index < rowEndIndex && this.map[index] < rowStart)
              index++;
            return index == rowEndIndex ? rowEnd - 1 : this.map[index];
          }
          rowStart = rowEnd;
        }
      }
      static get(table) {
        return readFromCache(table) || addToCache(table, computeMap(table));
      }
    };
    function computeMap(table) {
      if (table.type.spec.tableRole != "table")
        throw new RangeError("Not a table node: " + table.type.name);
      let width = findWidth(table), height = table.childCount;
      let map = [], mapPos = 0, problems = null, colWidths = [];
      for (let i = 0, e = width * height; i < e; i++)
        map[i] = 0;
      for (let row = 0, pos = 0; row < height; row++) {
        let rowNode = table.child(row);
        pos++;
        for (let i = 0; ; i++) {
          while (mapPos < map.length && map[mapPos] != 0)
            mapPos++;
          if (i == rowNode.childCount)
            break;
          let cellNode = rowNode.child(i), { colspan, rowspan, colwidth } = cellNode.attrs;
          for (let h = 0; h < rowspan; h++) {
            if (h + row >= height) {
              (problems || (problems = [])).push({
                type: "overlong_rowspan",
                pos,
                n: rowspan - h
              });
              break;
            }
            let start = mapPos + h * width;
            for (let w = 0; w < colspan; w++) {
              if (map[start + w] == 0)
                map[start + w] = pos;
              else
                (problems || (problems = [])).push({
                  type: "collision",
                  row,
                  pos,
                  n: colspan - w
                });
              let colW = colwidth && colwidth[w];
              if (colW) {
                let widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];
                if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
                  colWidths[widthIndex] = colW;
                  colWidths[widthIndex + 1] = 1;
                } else if (prev == colW) {
                  colWidths[widthIndex + 1]++;
                }
              }
            }
          }
          mapPos += colspan;
          pos += cellNode.nodeSize;
        }
        let expectedPos = (row + 1) * width, missing = 0;
        while (mapPos < expectedPos)
          if (map[mapPos++] == 0)
            missing++;
        if (missing)
          (problems || (problems = [])).push({ type: "missing", row, n: missing });
        pos++;
      }
      let tableMap = new TableMap(width, height, map, problems), badWidths = false;
      for (let i = 0; !badWidths && i < colWidths.length; i += 2)
        if (colWidths[i] != null && colWidths[i + 1] < height)
          badWidths = true;
      if (badWidths)
        findBadColWidths(tableMap, colWidths, table);
      return tableMap;
    }
    function findWidth(table) {
      let width = -1, hasRowSpan = false;
      for (let row = 0; row < table.childCount; row++) {
        let rowNode = table.child(row), rowWidth = 0;
        if (hasRowSpan)
          for (let j = 0; j < row; j++) {
            let prevRow = table.child(j);
            for (let i = 0; i < prevRow.childCount; i++) {
              let cell = prevRow.child(i);
              if (j + cell.attrs.rowspan > row)
                rowWidth += cell.attrs.colspan;
            }
          }
        for (let i = 0; i < rowNode.childCount; i++) {
          let cell = rowNode.child(i);
          rowWidth += cell.attrs.colspan;
          if (cell.attrs.rowspan > 1)
            hasRowSpan = true;
        }
        if (width == -1)
          width = rowWidth;
        else if (width != rowWidth)
          width = Math.max(width, rowWidth);
      }
      return width;
    }
    function findBadColWidths(map, colWidths, table) {
      if (!map.problems)
        map.problems = [];
      for (let i = 0, seen = {}; i < map.map.length; i++) {
        let pos = map.map[i];
        if (seen[pos])
          continue;
        seen[pos] = true;
        let node = table.nodeAt(pos), updated = null;
        for (let j = 0; j < node.attrs.colspan; j++) {
          let col = (i + j) % map.width, colWidth = colWidths[col * 2];
          if (colWidth != null && (!node.attrs.colwidth || node.attrs.colwidth[j] != colWidth))
            (updated || (updated = freshColWidth(node.attrs)))[j] = colWidth;
        }
        if (updated)
          map.problems.unshift({
            type: "colwidth mismatch",
            pos,
            colwidth: updated
          });
      }
    }
    function freshColWidth(attrs) {
      if (attrs.colwidth)
        return attrs.colwidth.slice();
      let result = [];
      for (let i = 0; i < attrs.colspan; i++)
        result.push(0);
      return result;
    }
    function getCellAttrs(dom, extraAttrs) {
      let widthAttr = dom.getAttribute("data-colwidth");
      let widths = widthAttr && /^\d+(,\d+)*$/.test(widthAttr) ? widthAttr.split(",").map((s) => Number(s)) : null;
      let colspan = Number(dom.getAttribute("colspan") || 1);
      let result = {
        colspan,
        rowspan: Number(dom.getAttribute("rowspan") || 1),
        colwidth: widths && widths.length == colspan ? widths : null
      };
      for (let prop in extraAttrs) {
        let getter = extraAttrs[prop].getFromDOM;
        let value = getter && getter(dom);
        if (value != null)
          result[prop] = value;
      }
      return result;
    }
    function setCellAttrs(node, extraAttrs) {
      let attrs = {};
      if (node.attrs.colspan != 1)
        attrs.colspan = node.attrs.colspan;
      if (node.attrs.rowspan != 1)
        attrs.rowspan = node.attrs.rowspan;
      if (node.attrs.colwidth)
        attrs["data-colwidth"] = node.attrs.colwidth.join(",");
      for (let prop in extraAttrs) {
        let setter = extraAttrs[prop].setDOMAttr;
        if (setter)
          setter(node.attrs[prop], attrs);
      }
      return attrs;
    }
    function tableNodes(options) {
      let extraAttrs = options.cellAttributes || {};
      let cellAttrs = {
        colspan: { default: 1 },
        rowspan: { default: 1 },
        colwidth: { default: null }
      };
      for (let prop in extraAttrs)
        cellAttrs[prop] = { default: extraAttrs[prop].default };
      return {
        table: {
          content: "table_row+",
          tableRole: "table",
          isolating: true,
          group: options.tableGroup,
          parseDOM: [{ tag: "table" }],
          toDOM() {
            return ["table", ["tbody", 0]];
          }
        },
        table_row: {
          content: "(table_cell | table_header)*",
          tableRole: "row",
          parseDOM: [{ tag: "tr" }],
          toDOM() {
            return ["tr", 0];
          }
        },
        table_cell: {
          content: options.cellContent,
          attrs: cellAttrs,
          tableRole: "cell",
          isolating: true,
          parseDOM: [
            { tag: "td", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }
          ],
          toDOM(node) {
            return ["td", setCellAttrs(node, extraAttrs), 0];
          }
        },
        table_header: {
          content: options.cellContent,
          attrs: cellAttrs,
          tableRole: "header_cell",
          isolating: true,
          parseDOM: [
            { tag: "th", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }
          ],
          toDOM(node) {
            return ["th", setCellAttrs(node, extraAttrs), 0];
          }
        }
      };
    }
    function tableNodeTypes(schema) {
      let result = schema.cached.tableNodeTypes;
      if (!result) {
        result = schema.cached.tableNodeTypes = {};
        for (let name in schema.nodes) {
          let type = schema.nodes[name], role = type.spec.tableRole;
          if (role)
            result[role] = type;
        }
      }
      return result;
    }
    var key$1 = new prosemirrorState.PluginKey("selectingCells");
    function cellAround($pos) {
      for (let d = $pos.depth - 1; d > 0; d--)
        if ($pos.node(d).type.spec.tableRole == "row")
          return $pos.node(0).resolve($pos.before(d + 1));
      return null;
    }
    function cellWrapping($pos) {
      for (let d = $pos.depth; d > 0; d--) {
        const role = $pos.node(d).type.spec.tableRole;
        if (role === "cell" || role === "header_cell")
          return $pos.node(d);
      }
      return null;
    }
    function isInTable(state) {
      let $head = state.selection.$head;
      for (let d = $head.depth; d > 0; d--)
        if ($head.node(d).type.spec.tableRole == "row")
          return true;
      return false;
    }
    function selectionCell(state) {
      let sel = state.selection;
      if (sel.$anchorCell) {
        return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
      } else if (sel.node && sel.node.type.spec.tableRole == "cell") {
        return sel.$anchor;
      }
      return cellAround(sel.$head) || cellNear(sel.$head);
    }
    function cellNear($pos) {
      for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
        let role = after.type.spec.tableRole;
        if (role == "cell" || role == "header_cell")
          return $pos.doc.resolve(pos);
      }
      for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
        let role = before.type.spec.tableRole;
        if (role == "cell" || role == "header_cell")
          return $pos.doc.resolve(pos - before.nodeSize);
      }
    }
    function pointsAtCell($pos) {
      return $pos.parent.type.spec.tableRole == "row" && $pos.nodeAfter;
    }
    function moveCellForward($pos) {
      return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
    }
    function inSameTable($a, $b) {
      return $a.depth == $b.depth && $a.pos >= $b.start(-1) && $a.pos <= $b.end(-1);
    }
    function findCell($pos) {
      return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));
    }
    function colCount($pos) {
      return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));
    }
    function nextCell($pos, axis, dir) {
      let start = $pos.start(-1), map = TableMap.get($pos.node(-1));
      let moved = map.nextCell($pos.pos - start, axis, dir);
      return moved == null ? null : $pos.node(0).resolve(start + moved);
    }
    function setAttr(attrs, name, value) {
      let result = {};
      for (let prop in attrs)
        result[prop] = attrs[prop];
      result[name] = value;
      return result;
    }
    function removeColSpan(attrs, pos, n = 1) {
      let result = setAttr(attrs, "colspan", attrs.colspan - n);
      if (result.colwidth) {
        result.colwidth = result.colwidth.slice();
        result.colwidth.splice(pos, n);
        if (!result.colwidth.some((w) => w > 0))
          result.colwidth = null;
      }
      return result;
    }
    function addColSpan(attrs, pos, n = 1) {
      let result = setAttr(attrs, "colspan", attrs.colspan + n);
      if (result.colwidth) {
        result.colwidth = result.colwidth.slice();
        for (let i = 0; i < n; i++)
          result.colwidth.splice(pos, 0, 0);
      }
      return result;
    }
    function columnIsHeader(map, table, col) {
      let headerCell = tableNodeTypes(table.type.schema).header_cell;
      for (let row = 0; row < map.height; row++)
        if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)
          return false;
      return true;
    }
    var CellSelection = class extends prosemirrorState.Selection {
      constructor($anchorCell, $headCell = $anchorCell) {
        let table = $anchorCell.node(-1), map = TableMap.get(table), start = $anchorCell.start(-1);
        let rect = map.rectBetween($anchorCell.pos - start, $headCell.pos - start);
        let doc = $anchorCell.node(0);
        let cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - start);
        cells.unshift($headCell.pos - start);
        let ranges = cells.map((pos) => {
          let cell = table.nodeAt(pos), from = pos + start + 1;
          return new prosemirrorState.SelectionRange(
            doc.resolve(from),
            doc.resolve(from + cell.content.size)
          );
        });
        super(ranges[0].$from, ranges[0].$to, ranges);
        this.$anchorCell = $anchorCell;
        this.$headCell = $headCell;
      }
      map(doc, mapping) {
        let $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));
        let $headCell = doc.resolve(mapping.map(this.$headCell.pos));
        if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
          let tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
          if (tableChanged && this.isRowSelection())
            return CellSelection.rowSelection($anchorCell, $headCell);
          else if (tableChanged && this.isColSelection())
            return CellSelection.colSelection($anchorCell, $headCell);
          else
            return new CellSelection($anchorCell, $headCell);
        }
        return prosemirrorState.TextSelection.between($anchorCell, $headCell);
      }
      content() {
        let table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1);
        let rect = map.rectBetween(
          this.$anchorCell.pos - start,
          this.$headCell.pos - start
        );
        let seen = {}, rows = [];
        for (let row = rect.top; row < rect.bottom; row++) {
          let rowContent = [];
          for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {
            let pos = map.map[index];
            if (!seen[pos]) {
              seen[pos] = true;
              let cellRect = map.findCell(pos), cell = table.nodeAt(pos);
              let extraLeft = rect.left - cellRect.left, extraRight = cellRect.right - rect.right;
              if (extraLeft > 0 || extraRight > 0) {
                let attrs = cell.attrs;
                if (extraLeft > 0)
                  attrs = removeColSpan(attrs, 0, extraLeft);
                if (extraRight > 0)
                  attrs = removeColSpan(
                    attrs,
                    attrs.colspan - extraRight,
                    extraRight
                  );
                if (cellRect.left < rect.left)
                  cell = cell.type.createAndFill(attrs);
                else
                  cell = cell.type.create(attrs, cell.content);
              }
              if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
                let attrs = setAttr(
                  cell.attrs,
                  "rowspan",
                  Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
                );
                if (cellRect.top < rect.top)
                  cell = cell.type.createAndFill(attrs);
                else
                  cell = cell.type.create(attrs, cell.content);
              }
              rowContent.push(cell);
            }
          }
          rows.push(table.child(row).copy(prosemirrorModel.Fragment.from(rowContent)));
        }
        const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
        return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(fragment), 1, 1);
      }
      replace(tr, content = prosemirrorModel.Slice.empty) {
        let mapFrom = tr.steps.length, ranges = this.ranges;
        for (let i = 0; i < ranges.length; i++) {
          let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
          tr.replace(
            mapping.map($from.pos),
            mapping.map($to.pos),
            i ? prosemirrorModel.Slice.empty : content
          );
        }
        let sel = prosemirrorState.Selection.findFrom(
          tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),
          -1
        );
        if (sel)
          tr.setSelection(sel);
      }
      replaceWith(tr, node) {
        this.replace(tr, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));
      }
      forEachCell(f) {
        let table = this.$anchorCell.node(-1), map = TableMap.get(table), start = this.$anchorCell.start(-1);
        let cells = map.cellsInRect(
          map.rectBetween(this.$anchorCell.pos - start, this.$headCell.pos - start)
        );
        for (let i = 0; i < cells.length; i++)
          f(table.nodeAt(cells[i]), start + cells[i]);
      }
      isColSelection() {
        let anchorTop = this.$anchorCell.index(-1), headTop = this.$headCell.index(-1);
        if (Math.min(anchorTop, headTop) > 0)
          return false;
        let anchorBot = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan, headBot = headTop + this.$headCell.nodeAfter.attrs.rowspan;
        return Math.max(anchorBot, headBot) == this.$headCell.node(-1).childCount;
      }
      static colSelection($anchorCell, $headCell = $anchorCell) {
        let map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1);
        let anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start);
        let doc = $anchorCell.node(0);
        if (anchorRect.top <= headRect.top) {
          if (anchorRect.top > 0)
            $anchorCell = doc.resolve(start + map.map[anchorRect.left]);
          if (headRect.bottom < map.height)
            $headCell = doc.resolve(
              start + map.map[map.width * (map.height - 1) + headRect.right - 1]
            );
        } else {
          if (headRect.top > 0)
            $headCell = doc.resolve(start + map.map[headRect.left]);
          if (anchorRect.bottom < map.height)
            $anchorCell = doc.resolve(
              start + map.map[map.width * (map.height - 1) + anchorRect.right - 1]
            );
        }
        return new CellSelection($anchorCell, $headCell);
      }
      isRowSelection() {
        let map = TableMap.get(this.$anchorCell.node(-1)), start = this.$anchorCell.start(-1);
        let anchorLeft = map.colCount(this.$anchorCell.pos - start), headLeft = map.colCount(this.$headCell.pos - start);
        if (Math.min(anchorLeft, headLeft) > 0)
          return false;
        let anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan, headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
        return Math.max(anchorRight, headRight) == map.width;
      }
      eq(other) {
        return other instanceof CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
      }
      static rowSelection($anchorCell, $headCell = $anchorCell) {
        let map = TableMap.get($anchorCell.node(-1)), start = $anchorCell.start(-1);
        let anchorRect = map.findCell($anchorCell.pos - start), headRect = map.findCell($headCell.pos - start);
        let doc = $anchorCell.node(0);
        if (anchorRect.left <= headRect.left) {
          if (anchorRect.left > 0)
            $anchorCell = doc.resolve(start + map.map[anchorRect.top * map.width]);
          if (headRect.right < map.width)
            $headCell = doc.resolve(
              start + map.map[map.width * (headRect.top + 1) - 1]
            );
        } else {
          if (headRect.left > 0)
            $headCell = doc.resolve(start + map.map[headRect.top * map.width]);
          if (anchorRect.right < map.width)
            $anchorCell = doc.resolve(
              start + map.map[map.width * (anchorRect.top + 1) - 1]
            );
        }
        return new CellSelection($anchorCell, $headCell);
      }
      toJSON() {
        return {
          type: "cell",
          anchor: this.$anchorCell.pos,
          head: this.$headCell.pos
        };
      }
      static fromJSON(doc, json) {
        return new CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));
      }
      static create(doc, anchorCell, headCell = anchorCell) {
        return new CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));
      }
      getBookmark() {
        return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
      }
    };
    CellSelection.prototype.visible = false;
    prosemirrorState.Selection.jsonID("cell", CellSelection);
    var CellBookmark = class {
      constructor(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      }
      map(mapping) {
        return new CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
      }
      resolve(doc) {
        let $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);
        if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
          return new CellSelection($anchorCell, $headCell);
        else
          return prosemirrorState.Selection.near($headCell, 1);
      }
    };
    function drawCellSelection(state) {
      if (!(state.selection instanceof CellSelection))
        return null;
      let cells = [];
      state.selection.forEachCell((node, pos) => {
        cells.push(
          prosemirrorView.Decoration.node(pos, pos + node.nodeSize, { class: "selectedCell" })
        );
      });
      return prosemirrorView.DecorationSet.create(state.doc, cells);
    }
    function isCellBoundarySelection({ $from, $to }) {
      if ($from.pos == $to.pos || $from.pos < $from.pos - 6)
        return false;
      let afterFrom = $from.pos, beforeTo = $to.pos, depth = $from.depth;
      for (; depth >= 0; depth--, afterFrom++)
        if ($from.after(depth + 1) < $from.end(depth))
          break;
      for (let d = $to.depth; d >= 0; d--, beforeTo--)
        if ($to.before(d + 1) > $to.start(d))
          break;
      return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
    }
    function isTextSelectionAcrossCells({ $from, $to }) {
      let fromCellBoundaryNode;
      let toCellBoundaryNode;
      for (let i = $from.depth; i > 0; i--) {
        let node = $from.node(i);
        if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
          fromCellBoundaryNode = node;
          break;
        }
      }
      for (let i = $to.depth; i > 0; i--) {
        let node = $to.node(i);
        if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
          toCellBoundaryNode = node;
          break;
        }
      }
      return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
    }
    function normalizeSelection(state, tr, allowTableNodeSelection) {
      let sel = (tr || state).selection, doc = (tr || state).doc, normalize, role;
      if (sel instanceof prosemirrorState.NodeSelection && (role = sel.node.type.spec.tableRole)) {
        if (role == "cell" || role == "header_cell") {
          normalize = CellSelection.create(doc, sel.from);
        } else if (role == "row") {
          let $cell = doc.resolve(sel.from + 1);
          normalize = CellSelection.rowSelection($cell, $cell);
        } else if (!allowTableNodeSelection) {
          let map = TableMap.get(sel.node), start = sel.from + 1;
          let lastCell = start + map.map[map.width * map.height - 1];
          normalize = CellSelection.create(doc, start + 1, lastCell);
        }
      } else if (sel instanceof prosemirrorState.TextSelection && isCellBoundarySelection(sel)) {
        normalize = prosemirrorState.TextSelection.create(doc, sel.from);
      } else if (sel instanceof prosemirrorState.TextSelection && isTextSelectionAcrossCells(sel)) {
        normalize = prosemirrorState.TextSelection.create(doc, sel.$from.start(), sel.$from.end());
      }
      if (normalize)
        (tr || (tr = state.tr)).setSelection(normalize);
      return tr;
    }
    function pastedCells(slice) {
      if (!slice.size)
        return null;
      let { content, openStart, openEnd } = slice;
      while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.firstChild.type.spec.tableRole == "table")) {
        openStart--;
        openEnd--;
        content = content.firstChild.content;
      }
      let first = content.firstChild, role = first.type.spec.tableRole;
      let schema = first.type.schema, rows = [];
      if (role == "row") {
        for (let i = 0; i < content.childCount; i++) {
          let cells = content.child(i).content;
          let left = i ? 0 : Math.max(0, openStart - 1);
          let right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
          if (left || right)
            cells = fitSlice(
              tableNodeTypes(schema).row,
              new prosemirrorModel.Slice(cells, left, right)
            ).content;
          rows.push(cells);
        }
      } else if (role == "cell" || role == "header_cell") {
        rows.push(
          openStart || openEnd ? fitSlice(
            tableNodeTypes(schema).row,
            new prosemirrorModel.Slice(content, openStart, openEnd)
          ).content : content
        );
      } else {
        return null;
      }
      return ensureRectangular(schema, rows);
    }
    function ensureRectangular(schema, rows) {
      let widths = [];
      for (let i = 0; i < rows.length; i++) {
        let row = rows[i];
        for (let j = row.childCount - 1; j >= 0; j--) {
          let { rowspan, colspan } = row.child(j).attrs;
          for (let r = i; r < i + rowspan; r++)
            widths[r] = (widths[r] || 0) + colspan;
        }
      }
      let width = 0;
      for (let r = 0; r < widths.length; r++)
        width = Math.max(width, widths[r]);
      for (let r = 0; r < widths.length; r++) {
        if (r >= rows.length)
          rows.push(prosemirrorModel.Fragment.empty);
        if (widths[r] < width) {
          let empty = tableNodeTypes(schema).cell.createAndFill(), cells = [];
          for (let i = widths[r]; i < width; i++)
            cells.push(empty);
          rows[r] = rows[r].append(prosemirrorModel.Fragment.from(cells));
        }
      }
      return { height: rows.length, width, rows };
    }
    function fitSlice(nodeType, slice) {
      let node = nodeType.createAndFill();
      let tr = new prosemirrorTransform.Transform(node).replace(0, node.content.size, slice);
      return tr.doc;
    }
    function clipCells({ width, height, rows }, newWidth, newHeight) {
      if (width != newWidth) {
        let added = [], newRows = [];
        for (let row = 0; row < rows.length; row++) {
          let frag = rows[row], cells = [];
          for (let col = added[row] || 0, i = 0; col < newWidth; i++) {
            let cell = frag.child(i % frag.childCount);
            if (col + cell.attrs.colspan > newWidth)
              cell = cell.type.create(
                removeColSpan(
                  cell.attrs,
                  cell.attrs.colspan,
                  col + cell.attrs.colspan - newWidth
                ),
                cell.content
              );
            cells.push(cell);
            col += cell.attrs.colspan;
            for (let j = 1; j < cell.attrs.rowspan; j++)
              added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
          }
          newRows.push(prosemirrorModel.Fragment.from(cells));
        }
        rows = newRows;
        width = newWidth;
      }
      if (height != newHeight) {
        let newRows = [];
        for (let row = 0, i = 0; row < newHeight; row++, i++) {
          let cells = [], source = rows[i % height];
          for (let j = 0; j < source.childCount; j++) {
            let cell = source.child(j);
            if (row + cell.attrs.rowspan > newHeight)
              cell = cell.type.create(
                setAttr(
                  cell.attrs,
                  "rowspan",
                  Math.max(1, newHeight - cell.attrs.rowspan)
                ),
                cell.content
              );
            cells.push(cell);
          }
          newRows.push(prosemirrorModel.Fragment.from(cells));
        }
        rows = newRows;
        height = newHeight;
      }
      return { width, height, rows };
    }
    function growTable(tr, map, table, start, width, height, mapFrom) {
      let schema = tr.doc.type.schema, types = tableNodeTypes(schema), empty, emptyHead;
      if (width > map.width) {
        for (let row = 0, rowEnd = 0; row < map.height; row++) {
          let rowNode = table.child(row);
          rowEnd += rowNode.nodeSize;
          let cells = [], add;
          if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
            add = empty || (empty = types.cell.createAndFill());
          else
            add = emptyHead || (emptyHead = types.header_cell.createAndFill());
          for (let i = map.width; i < width; i++)
            cells.push(add);
          tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);
        }
      }
      if (height > map.height) {
        let cells = [];
        for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {
          let header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;
          cells.push(
            header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())
          );
        }
        let emptyRow = types.row.create(null, prosemirrorModel.Fragment.from(cells)), rows = [];
        for (let i = map.height; i < height; i++)
          rows.push(emptyRow);
        tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);
      }
      return !!(empty || emptyHead);
    }
    function isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {
      if (top == 0 || top == map.height)
        return false;
      let found = false;
      for (let col = left; col < right; col++) {
        let index = top * map.width + col, pos = map.map[index];
        if (map.map[index - map.width] == pos) {
          found = true;
          let cell = table.nodeAt(pos);
          let { top: cellTop, left: cellLeft } = map.findCell(pos);
          tr.setNodeMarkup(
            tr.mapping.slice(mapFrom).map(pos + start),
            null,
            setAttr(cell.attrs, "rowspan", top - cellTop)
          );
          tr.insert(
            tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),
            cell.type.createAndFill(
              setAttr(cell.attrs, "rowspan", cellTop + cell.attrs.rowspan - top)
            )
          );
          col += cell.attrs.colspan - 1;
        }
      }
      return found;
    }
    function isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {
      if (left == 0 || left == map.width)
        return false;
      let found = false;
      for (let row = top; row < bottom; row++) {
        let index = row * map.width + left, pos = map.map[index];
        if (map.map[index - 1] == pos) {
          found = true;
          let cell = table.nodeAt(pos), cellLeft = map.colCount(pos);
          let updatePos = tr.mapping.slice(mapFrom).map(pos + start);
          tr.setNodeMarkup(
            updatePos,
            null,
            removeColSpan(
              cell.attrs,
              left - cellLeft,
              cell.attrs.colspan - (left - cellLeft)
            )
          );
          tr.insert(
            updatePos + cell.nodeSize,
            cell.type.createAndFill(removeColSpan(cell.attrs, 0, left - cellLeft))
          );
          row += cell.attrs.rowspan - 1;
        }
      }
      return found;
    }
    function insertCells(state, dispatch, tableStart, rect, cells) {
      let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc, map = TableMap.get(table);
      let { top, left } = rect;
      let right = left + cells.width, bottom = top + cells.height;
      let tr = state.tr, mapFrom = 0;
      function recomp() {
        table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
        map = TableMap.get(table);
        mapFrom = tr.mapping.maps.length;
      }
      if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))
        recomp();
      if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))
        recomp();
      if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))
        recomp();
      if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))
        recomp();
      if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))
        recomp();
      for (let row = top; row < bottom; row++) {
        let from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);
        tr.replace(
          tr.mapping.slice(mapFrom).map(from + tableStart),
          tr.mapping.slice(mapFrom).map(to + tableStart),
          new prosemirrorModel.Slice(cells.rows[row - top], 0, 0)
        );
      }
      recomp();
      tr.setSelection(
        new CellSelection(
          tr.doc.resolve(tableStart + map.positionAt(top, left, table)),
          tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))
        )
      );
      dispatch(tr);
    }
    var handleKeyDown = prosemirrorKeymap.keydownHandler({
      ArrowLeft: arrow("horiz", -1),
      ArrowRight: arrow("horiz", 1),
      ArrowUp: arrow("vert", -1),
      ArrowDown: arrow("vert", 1),
      "Shift-ArrowLeft": shiftArrow("horiz", -1),
      "Shift-ArrowRight": shiftArrow("horiz", 1),
      "Shift-ArrowUp": shiftArrow("vert", -1),
      "Shift-ArrowDown": shiftArrow("vert", 1),
      Backspace: deleteCellSelection,
      "Mod-Backspace": deleteCellSelection,
      Delete: deleteCellSelection,
      "Mod-Delete": deleteCellSelection
    });
    function maybeSetSelection(state, dispatch, selection) {
      if (selection.eq(state.selection))
        return false;
      if (dispatch)
        dispatch(state.tr.setSelection(selection).scrollIntoView());
      return true;
    }
    function arrow(axis, dir) {
      return (state, dispatch, view) => {
        let sel = state.selection;
        if (sel instanceof CellSelection) {
          return maybeSetSelection(
            state,
            dispatch,
            prosemirrorState.Selection.near(sel.$headCell, dir)
          );
        }
        if (axis != "horiz" && !sel.empty)
          return false;
        let end = atEndOfCell(view, axis, dir);
        if (end == null)
          return false;
        if (axis == "horiz") {
          return maybeSetSelection(
            state,
            dispatch,
            prosemirrorState.Selection.near(state.doc.resolve(sel.head + dir), dir)
          );
        } else {
          let $cell = state.doc.resolve(end), $next = nextCell($cell, axis, dir), newSel;
          if ($next)
            newSel = prosemirrorState.Selection.near($next, 1);
          else if (dir < 0)
            newSel = prosemirrorState.Selection.near(state.doc.resolve($cell.before(-1)), -1);
          else
            newSel = prosemirrorState.Selection.near(state.doc.resolve($cell.after(-1)), 1);
          return maybeSetSelection(state, dispatch, newSel);
        }
      };
    }
    function shiftArrow(axis, dir) {
      return (state, dispatch, view) => {
        let sel = state.selection;
        if (!(sel instanceof CellSelection)) {
          let end = atEndOfCell(view, axis, dir);
          if (end == null)
            return false;
          sel = new CellSelection(state.doc.resolve(end));
        }
        let $head = nextCell(sel.$headCell, axis, dir);
        if (!$head)
          return false;
        return maybeSetSelection(
          state,
          dispatch,
          new CellSelection(sel.$anchorCell, $head)
        );
      };
    }
    function deleteCellSelection(state, dispatch) {
      let sel = state.selection;
      if (!(sel instanceof CellSelection))
        return false;
      if (dispatch) {
        let tr = state.tr, baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
        sel.forEachCell((cell, pos) => {
          if (!cell.content.eq(baseContent))
            tr.replace(
              tr.mapping.map(pos + 1),
              tr.mapping.map(pos + cell.nodeSize - 1),
              new prosemirrorModel.Slice(baseContent, 0, 0)
            );
        });
        if (tr.docChanged)
          dispatch(tr);
      }
      return true;
    }
    function handleTripleClick(view, pos) {
      let doc = view.state.doc, $cell = cellAround(doc.resolve(pos));
      if (!$cell)
        return false;
      view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
      return true;
    }
    function handlePaste(view, _, slice) {
      if (!isInTable(view.state))
        return false;
      let cells = pastedCells(slice), sel = view.state.selection;
      if (sel instanceof CellSelection) {
        if (!cells)
          cells = {
            width: 1,
            height: 1,
            rows: [
              prosemirrorModel.Fragment.from(
                fitSlice(tableNodeTypes(view.state.schema).cell, slice)
              )
            ]
          };
        let table = sel.$anchorCell.node(-1), start = sel.$anchorCell.start(-1);
        let rect = TableMap.get(table).rectBetween(
          sel.$anchorCell.pos - start,
          sel.$headCell.pos - start
        );
        cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
        insertCells(view.state, view.dispatch, start, rect, cells);
        return true;
      } else if (cells) {
        let $cell = selectionCell(view.state), start = $cell.start(-1);
        insertCells(
          view.state,
          view.dispatch,
          start,
          TableMap.get($cell.node(-1)).findCell($cell.pos - start),
          cells
        );
        return true;
      } else {
        return false;
      }
    }
    function handleMouseDown$1(view, startEvent) {
      if (startEvent.ctrlKey || startEvent.metaKey)
        return;
      let startDOMCell = domInCell(view, startEvent.target), $anchor;
      if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
        setCellSelection(view.state.selection.$anchorCell, startEvent);
        startEvent.preventDefault();
      } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && cellUnderMouse(view, startEvent).pos != $anchor.pos) {
        setCellSelection($anchor, startEvent);
        startEvent.preventDefault();
      } else if (!startDOMCell) {
        return;
      }
      function setCellSelection($anchor2, event) {
        let $head = cellUnderMouse(view, event);
        let starting = key$1.getState(view.state) == null;
        if (!$head || !inSameTable($anchor2, $head)) {
          if (starting)
            $head = $anchor2;
          else
            return;
        }
        let selection = new CellSelection($anchor2, $head);
        if (starting || !view.state.selection.eq(selection)) {
          let tr = view.state.tr.setSelection(selection);
          if (starting)
            tr.setMeta(key$1, $anchor2.pos);
          view.dispatch(tr);
        }
      }
      function stop() {
        view.root.removeEventListener("mouseup", stop);
        view.root.removeEventListener("dragstart", stop);
        view.root.removeEventListener("mousemove", move);
        if (key$1.getState(view.state) != null)
          view.dispatch(view.state.tr.setMeta(key$1, -1));
      }
      function move(event) {
        let anchor = key$1.getState(view.state), $anchor2;
        if (anchor != null) {
          $anchor2 = view.state.doc.resolve(anchor);
        } else if (domInCell(view, event.target) != startDOMCell) {
          $anchor2 = cellUnderMouse(view, startEvent);
          if (!$anchor2)
            return stop();
        }
        if ($anchor2)
          setCellSelection($anchor2, event);
      }
      view.root.addEventListener("mouseup", stop);
      view.root.addEventListener("dragstart", stop);
      view.root.addEventListener("mousemove", move);
    }
    function atEndOfCell(view, axis, dir) {
      if (!(view.state.selection instanceof prosemirrorState.TextSelection))
        return null;
      let { $head } = view.state.selection;
      for (let d = $head.depth - 1; d >= 0; d--) {
        let parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);
        if (index != (dir < 0 ? 0 : parent.childCount))
          return null;
        if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
          let cellPos = $head.before(d);
          let dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
          return view.endOfTextblock(dirStr) ? cellPos : null;
        }
      }
      return null;
    }
    function domInCell(view, dom) {
      for (; dom && dom != view.dom; dom = dom.parentNode)
        if (dom.nodeName == "TD" || dom.nodeName == "TH")
          return dom;
    }
    function cellUnderMouse(view, event) {
      let mousePos = view.posAtCoords({ left: event.clientX, top: event.clientY });
      if (!mousePos)
        return null;
      return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;
    }
    var fixTablesKey = new prosemirrorState.PluginKey("fix-tables");
    function changedDescendants(old, cur, offset, f) {
      let oldSize = old.childCount, curSize = cur.childCount;
      outer:
        for (let i = 0, j = 0; i < curSize; i++) {
          let child = cur.child(i);
          for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
            if (old.child(scan) == child) {
              j = scan + 1;
              offset += child.nodeSize;
              continue outer;
            }
          }
          f(child, offset);
          if (j < oldSize && old.child(j).sameMarkup(child))
            changedDescendants(old.child(j), child, offset + 1, f);
          else
            child.nodesBetween(0, child.content.size, f, offset + 1);
          offset += child.nodeSize;
        }
    }
    function fixTables(state, oldState) {
      let tr, check = (node, pos) => {
        if (node.type.spec.tableRole == "table")
          tr = fixTable(state, node, pos, tr);
      };
      if (!oldState)
        state.doc.descendants(check);
      else if (oldState.doc != state.doc)
        changedDescendants(oldState.doc, state.doc, 0, check);
      return tr;
    }
    function fixTable(state, table, tablePos, tr) {
      let map = TableMap.get(table);
      if (!map.problems)
        return tr;
      if (!tr)
        tr = state.tr;
      let mustAdd = [];
      for (let i = 0; i < map.height; i++)
        mustAdd.push(0);
      for (let i = 0; i < map.problems.length; i++) {
        let prob = map.problems[i];
        if (prob.type == "collision") {
          let cell = table.nodeAt(prob.pos);
          for (let j = 0; j < cell.attrs.rowspan; j++)
            mustAdd[prob.row + j] += prob.n;
          tr.setNodeMarkup(
            tr.mapping.map(tablePos + 1 + prob.pos),
            null,
            removeColSpan(cell.attrs, cell.attrs.colspan - prob.n, prob.n)
          );
        } else if (prob.type == "missing") {
          mustAdd[prob.row] += prob.n;
        } else if (prob.type == "overlong_rowspan") {
          let cell = table.nodeAt(prob.pos);
          tr.setNodeMarkup(
            tr.mapping.map(tablePos + 1 + prob.pos),
            null,
            setAttr(cell.attrs, "rowspan", cell.attrs.rowspan - prob.n)
          );
        } else if (prob.type == "colwidth mismatch") {
          let cell = table.nodeAt(prob.pos);
          tr.setNodeMarkup(
            tr.mapping.map(tablePos + 1 + prob.pos),
            null,
            setAttr(cell.attrs, "colwidth", prob.colwidth)
          );
        }
      }
      let first, last;
      for (let i = 0; i < mustAdd.length; i++)
        if (mustAdd[i]) {
          if (first == null)
            first = i;
          last = i;
        }
      for (let i = 0, pos = tablePos + 1; i < map.height; i++) {
        let row = table.child(i);
        let end = pos + row.nodeSize;
        let add = mustAdd[i];
        if (add > 0) {
          let tableNodeType = "cell";
          if (row.firstChild) {
            tableNodeType = row.firstChild.type.spec.tableRole;
          }
          let nodes = [];
          for (let j = 0; j < add; j++)
            nodes.push(tableNodeTypes(state.schema)[tableNodeType].createAndFill());
          let side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;
          tr.insert(tr.mapping.map(side), nodes);
        }
        pos = end;
      }
      return tr.setMeta(fixTablesKey, { fixTables: true });
    }
    function selectedRect(state) {
      let sel = state.selection, $pos = selectionCell(state);
      let table = $pos.node(-1), tableStart = $pos.start(-1), map = TableMap.get(table);
      let rect;
      if (sel instanceof CellSelection)
        rect = map.rectBetween(
          sel.$anchorCell.pos - tableStart,
          sel.$headCell.pos - tableStart
        );
      else
        rect = map.findCell($pos.pos - tableStart);
      rect.tableStart = tableStart;
      rect.map = map;
      rect.table = table;
      return rect;
    }
    function addColumn(tr, { map, tableStart, table }, col) {
      let refColumn = col > 0 ? -1 : 0;
      if (columnIsHeader(map, table, col + refColumn))
        refColumn = col == 0 || col == map.width ? null : 0;
      for (let row = 0; row < map.height; row++) {
        let index = row * map.width + col;
        if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {
          let pos = map.map[index], cell = table.nodeAt(pos);
          tr.setNodeMarkup(
            tr.mapping.map(tableStart + pos),
            null,
            addColSpan(cell.attrs, col - map.colCount(pos))
          );
          row += cell.attrs.rowspan - 1;
        } else {
          let type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;
          let pos = map.positionAt(row, col, table);
          tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());
        }
      }
      return tr;
    }
    function addColumnBefore(state, dispatch) {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        let rect = selectedRect(state);
        dispatch(addColumn(state.tr, rect, rect.left));
      }
      return true;
    }
    function addColumnAfter(state, dispatch) {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        let rect = selectedRect(state);
        dispatch(addColumn(state.tr, rect, rect.right));
      }
      return true;
    }
    function removeColumn(tr, { map, table, tableStart }, col) {
      let mapStart = tr.mapping.maps.length;
      for (let row = 0; row < map.height; ) {
        let index = row * map.width + col, pos = map.map[index], cell = table.nodeAt(pos);
        if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {
          tr.setNodeMarkup(
            tr.mapping.slice(mapStart).map(tableStart + pos),
            null,
            removeColSpan(cell.attrs, col - map.colCount(pos))
          );
        } else {
          let start = tr.mapping.slice(mapStart).map(tableStart + pos);
          tr.delete(start, start + cell.nodeSize);
        }
        row += cell.attrs.rowspan;
      }
    }
    function deleteColumn(state, dispatch) {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        let rect = selectedRect(state), tr = state.tr;
        if (rect.left == 0 && rect.right == rect.map.width)
          return false;
        for (let i = rect.right - 1; ; i--) {
          removeColumn(tr, rect, i);
          if (i == rect.left)
            break;
          rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
          rect.map = TableMap.get(rect.table);
        }
        dispatch(tr);
      }
      return true;
    }
    function rowIsHeader(map, table, row) {
      let headerCell = tableNodeTypes(table.type.schema).header_cell;
      for (let col = 0; col < map.width; col++)
        if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)
          return false;
      return true;
    }
    function addRow(tr, { map, tableStart, table }, row) {
      let rowPos = tableStart;
      for (let i = 0; i < row; i++)
        rowPos += table.child(i).nodeSize;
      let cells = [], refRow = row > 0 ? -1 : 0;
      if (rowIsHeader(map, table, row + refRow))
        refRow = row == 0 || row == map.height ? null : 0;
      for (let col = 0, index = map.width * row; col < map.width; col++, index++) {
        if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {
          let pos = map.map[index], attrs = table.nodeAt(pos).attrs;
          tr.setNodeMarkup(
            tableStart + pos,
            null,
            setAttr(attrs, "rowspan", attrs.rowspan + 1)
          );
          col += attrs.colspan - 1;
        } else {
          let type = refRow == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refRow * map.width]).type;
          cells.push(type.createAndFill());
        }
      }
      tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
      return tr;
    }
    function addRowBefore(state, dispatch) {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        let rect = selectedRect(state);
        dispatch(addRow(state.tr, rect, rect.top));
      }
      return true;
    }
    function addRowAfter(state, dispatch) {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        let rect = selectedRect(state);
        dispatch(addRow(state.tr, rect, rect.bottom));
      }
      return true;
    }
    function removeRow(tr, { map, table, tableStart }, row) {
      let rowPos = 0;
      for (let i = 0; i < row; i++)
        rowPos += table.child(i).nodeSize;
      let nextRow = rowPos + table.child(row).nodeSize;
      let mapFrom = tr.mapping.maps.length;
      tr.delete(rowPos + tableStart, nextRow + tableStart);
      for (let col = 0, index = row * map.width; col < map.width; col++, index++) {
        let pos = map.map[index];
        if (row > 0 && pos == map.map[index - map.width]) {
          let attrs = table.nodeAt(pos).attrs;
          tr.setNodeMarkup(
            tr.mapping.slice(mapFrom).map(pos + tableStart),
            null,
            setAttr(attrs, "rowspan", attrs.rowspan - 1)
          );
          col += attrs.colspan - 1;
        } else if (row < map.width && pos == map.map[index + map.width]) {
          let cell = table.nodeAt(pos);
          let copy = cell.type.create(
            setAttr(cell.attrs, "rowspan", cell.attrs.rowspan - 1),
            cell.content
          );
          let newPos = map.positionAt(row + 1, col, table);
          tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);
          col += cell.attrs.colspan - 1;
        }
      }
    }
    function deleteRow(state, dispatch) {
      if (!isInTable(state))
        return false;
      if (dispatch) {
        let rect = selectedRect(state), tr = state.tr;
        if (rect.top == 0 && rect.bottom == rect.map.height)
          return false;
        for (let i = rect.bottom - 1; ; i--) {
          removeRow(tr, rect, i);
          if (i == rect.top)
            break;
          rect.table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
          rect.map = TableMap.get(rect.table);
        }
        dispatch(tr);
      }
      return true;
    }
    function isEmpty(cell) {
      let c = cell.content;
      return c.childCount == 1 && c.firstChild.isTextblock && c.firstChild.childCount == 0;
    }
    function cellsOverlapRectangle({ width, height, map }, rect) {
      let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
      let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
      for (let i = rect.top; i < rect.bottom; i++) {
        if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])
          return true;
        indexLeft += width;
        indexRight += width;
      }
      for (let i = rect.left; i < rect.right; i++) {
        if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])
          return true;
        indexTop++;
        indexBottom++;
      }
      return false;
    }
    function mergeCells(state, dispatch) {
      let sel = state.selection;
      if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
        return false;
      let rect = selectedRect(state), { map } = rect;
      if (cellsOverlapRectangle(map, rect))
        return false;
      if (dispatch) {
        let tr = state.tr, seen = {}, content = prosemirrorModel.Fragment.empty, mergedPos, mergedCell;
        for (let row = rect.top; row < rect.bottom; row++) {
          for (let col = rect.left; col < rect.right; col++) {
            let cellPos = map.map[row * map.width + col], cell = rect.table.nodeAt(cellPos);
            if (seen[cellPos])
              continue;
            seen[cellPos] = true;
            if (mergedPos == null) {
              mergedPos = cellPos;
              mergedCell = cell;
            } else {
              if (!isEmpty(cell))
                content = content.append(cell.content);
              let mapped = tr.mapping.map(cellPos + rect.tableStart);
              tr.delete(mapped, mapped + cell.nodeSize);
            }
          }
        }
        tr.setNodeMarkup(
          mergedPos + rect.tableStart,
          null,
          setAttr(
            addColSpan(
              mergedCell.attrs,
              mergedCell.attrs.colspan,
              rect.right - rect.left - mergedCell.attrs.colspan
            ),
            "rowspan",
            rect.bottom - rect.top
          )
        );
        if (content.size) {
          let end = mergedPos + 1 + mergedCell.content.size;
          let start = isEmpty(mergedCell) ? mergedPos + 1 : end;
          tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);
        }
        tr.setSelection(
          new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))
        );
        dispatch(tr);
      }
      return true;
    }
    function splitCell(state, dispatch) {
      const nodeTypes = tableNodeTypes(state.schema);
      return splitCellWithType(({ node }) => {
        return nodeTypes[node.type.spec.tableRole];
      })(state, dispatch);
    }
    function splitCellWithType(getCellType) {
      return (state, dispatch) => {
        let sel = state.selection;
        let cellNode, cellPos;
        if (!(sel instanceof CellSelection)) {
          cellNode = cellWrapping(sel.$from);
          if (!cellNode)
            return false;
          cellPos = cellAround(sel.$from).pos;
        } else {
          if (sel.$anchorCell.pos != sel.$headCell.pos)
            return false;
          cellNode = sel.$anchorCell.nodeAfter;
          cellPos = sel.$anchorCell.pos;
        }
        if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
          return false;
        }
        if (dispatch) {
          let baseAttrs = cellNode.attrs, attrs = [], colwidth = baseAttrs.colwidth;
          if (baseAttrs.rowspan > 1)
            baseAttrs = setAttr(baseAttrs, "rowspan", 1);
          if (baseAttrs.colspan > 1)
            baseAttrs = setAttr(baseAttrs, "colspan", 1);
          let rect = selectedRect(state), tr = state.tr;
          for (let i = 0; i < rect.right - rect.left; i++)
            attrs.push(
              colwidth ? setAttr(
                baseAttrs,
                "colwidth",
                colwidth && colwidth[i] ? [colwidth[i]] : null
              ) : baseAttrs
            );
          let lastCell;
          for (let row = rect.top; row < rect.bottom; row++) {
            let pos = rect.map.positionAt(row, rect.left, rect.table);
            if (row == rect.top)
              pos += cellNode.nodeSize;
            for (let col = rect.left, i = 0; col < rect.right; col++, i++) {
              if (col == rect.left && row == rect.top)
                continue;
              tr.insert(
                lastCell = tr.mapping.map(pos + rect.tableStart, 1),
                getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])
              );
            }
          }
          tr.setNodeMarkup(
            cellPos,
            getCellType({ node: cellNode, row: rect.top, col: rect.left }),
            attrs[0]
          );
          if (sel instanceof CellSelection)
            tr.setSelection(
              new CellSelection(
                tr.doc.resolve(sel.$anchorCell.pos),
                lastCell && tr.doc.resolve(lastCell)
              )
            );
          dispatch(tr);
        }
        return true;
      };
    }
    function setCellAttr(name, value) {
      return function(state, dispatch) {
        if (!isInTable(state))
          return false;
        let $cell = selectionCell(state);
        if ($cell.nodeAfter.attrs[name] === value)
          return false;
        if (dispatch) {
          let tr = state.tr;
          if (state.selection instanceof CellSelection)
            state.selection.forEachCell((node, pos) => {
              if (node.attrs[name] !== value)
                tr.setNodeMarkup(pos, null, setAttr(node.attrs, name, value));
            });
          else
            tr.setNodeMarkup(
              $cell.pos,
              null,
              setAttr($cell.nodeAfter.attrs, name, value)
            );
          dispatch(tr);
        }
        return true;
      };
    }
    function deprecated_toggleHeader(type) {
      return function(state, dispatch) {
        if (!isInTable(state))
          return false;
        if (dispatch) {
          let types = tableNodeTypes(state.schema);
          let rect = selectedRect(state), tr = state.tr;
          let cells = rect.map.cellsInRect(
            type == "column" ? new Rect(rect.left, 0, rect.right, rect.map.height) : type == "row" ? new Rect(0, rect.top, rect.map.width, rect.bottom) : rect
          );
          let nodes = cells.map((pos) => rect.table.nodeAt(pos));
          for (let i = 0; i < cells.length; i++)
            if (nodes[i].type == types.header_cell)
              tr.setNodeMarkup(
                rect.tableStart + cells[i],
                types.cell,
                nodes[i].attrs
              );
          if (tr.steps.length == 0)
            for (let i = 0; i < cells.length; i++)
              tr.setNodeMarkup(
                rect.tableStart + cells[i],
                types.header_cell,
                nodes[i].attrs
              );
          dispatch(tr);
        }
        return true;
      };
    }
    function isHeaderEnabledByType(type, rect, types) {
      const cellPositions = rect.map.cellsInRect({
        left: 0,
        top: 0,
        right: type == "row" ? rect.map.width : 1,
        bottom: type == "column" ? rect.map.height : 1
      });
      for (let i = 0; i < cellPositions.length; i++) {
        const cell = rect.table.nodeAt(cellPositions[i]);
        if (cell && cell.type !== types.header_cell) {
          return false;
        }
      }
      return true;
    }
    function toggleHeader(type, options) {
      options = options || { useDeprecatedLogic: false };
      if (options.useDeprecatedLogic)
        return deprecated_toggleHeader(type);
      return function(state, dispatch) {
        if (!isInTable(state))
          return false;
        if (dispatch) {
          let types = tableNodeTypes(state.schema);
          let rect = selectedRect(state), tr = state.tr;
          let isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
          let isHeaderColumnEnabled = isHeaderEnabledByType("column", rect, types);
          let isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
          let selectionStartsAt = isHeaderEnabled ? 1 : 0;
          let cellsRect = type == "column" ? new Rect(0, selectionStartsAt, 1, rect.map.height) : type == "row" ? new Rect(selectionStartsAt, 0, rect.map.width, 1) : rect;
          let newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
          rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
            const cellPos = relativeCellPos + rect.tableStart;
            const cell = tr.doc.nodeAt(cellPos);
            if (cell) {
              tr.setNodeMarkup(cellPos, newType, cell.attrs);
            }
          });
          dispatch(tr);
        }
        return true;
      };
    }
    var toggleHeaderRow = toggleHeader("row", { useDeprecatedLogic: true });
    var toggleHeaderColumn = toggleHeader("column", {
      useDeprecatedLogic: true
    });
    var toggleHeaderCell = toggleHeader("cell", {
      useDeprecatedLogic: true
    });
    function findNextCell($cell, dir) {
      if (dir < 0) {
        let before = $cell.nodeBefore;
        if (before)
          return $cell.pos - before.nodeSize;
        for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
          let rowNode = $cell.node(-1).child(row);
          if (rowNode.childCount)
            return rowEnd - 1 - rowNode.lastChild.nodeSize;
          rowEnd -= rowNode.nodeSize;
        }
      } else {
        if ($cell.index() < $cell.parent.childCount - 1)
          return $cell.pos + $cell.nodeAfter.nodeSize;
        let table = $cell.node(-1);
        for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {
          let rowNode = table.child(row);
          if (rowNode.childCount)
            return rowStart + 1;
          rowStart += rowNode.nodeSize;
        }
      }
    }
    function goToNextCell(direction) {
      return function(state, dispatch) {
        if (!isInTable(state))
          return false;
        let cell = findNextCell(selectionCell(state), direction);
        if (cell == null)
          return;
        if (dispatch) {
          let $cell = state.doc.resolve(cell);
          dispatch(
            state.tr.setSelection(prosemirrorState.TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
          );
        }
        return true;
      };
    }
    function deleteTable(state, dispatch) {
      let $pos = state.selection.$anchor;
      for (let d = $pos.depth; d > 0; d--) {
        let node = $pos.node(d);
        if (node.type.spec.tableRole == "table") {
          if (dispatch)
            dispatch(
              state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()
            );
          return true;
        }
      }
      return false;
    }
    var TableView = class {
      constructor(node, cellMinWidth) {
        this.node = node;
        this.cellMinWidth = cellMinWidth;
        this.dom = document.createElement("div");
        this.dom.className = "tableWrapper";
        this.table = this.dom.appendChild(document.createElement("table"));
        this.colgroup = this.table.appendChild(document.createElement("colgroup"));
        updateColumns(node, this.colgroup, this.table, cellMinWidth);
        this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      }
      update(node) {
        if (node.type != this.node.type)
          return false;
        this.node = node;
        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
        return true;
      }
      ignoreMutation(record) {
        return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
      }
    };
    function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
      let totalWidth = 0, fixedWidth = true;
      let nextDOM = colgroup.firstChild, row = node.firstChild;
      for (let i = 0, col = 0; i < row.childCount; i++) {
        let { colspan, colwidth } = row.child(i).attrs;
        for (let j = 0; j < colspan; j++, col++) {
          let hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
          let cssWidth = hasWidth ? hasWidth + "px" : "";
          totalWidth += hasWidth || cellMinWidth;
          if (!hasWidth)
            fixedWidth = false;
          if (!nextDOM) {
            colgroup.appendChild(document.createElement("col")).style.width = cssWidth;
          } else {
            if (nextDOM.style.width != cssWidth)
              nextDOM.style.width = cssWidth;
            nextDOM = nextDOM.nextSibling;
          }
        }
      }
      while (nextDOM) {
        let after = nextDOM.nextSibling;
        nextDOM.parentNode.removeChild(nextDOM);
        nextDOM = after;
      }
      if (fixedWidth) {
        table.style.width = totalWidth + "px";
        table.style.minWidth = "";
      } else {
        table.style.width = "";
        table.style.minWidth = totalWidth + "px";
      }
    }
    var key = new prosemirrorState.PluginKey("tableColumnResizing");
    function columnResizing({
      handleWidth = 5,
      cellMinWidth = 25,
      View = TableView,
      lastColumnResizable = true
    } = {}) {
      let plugin = new prosemirrorState.Plugin({
        key,
        state: {
          init(_, state) {
            this.spec.props.nodeViews[tableNodeTypes(state.schema).table.name] = (node, view) => new View(node, cellMinWidth, view);
            return new ResizeState(-1, false);
          },
          apply(tr, prev) {
            return prev.apply(tr);
          }
        },
        props: {
          attributes(state) {
            let pluginState = key.getState(state);
            return pluginState.activeHandle > -1 ? { class: "resize-cursor" } : null;
          },
          handleDOMEvents: {
            mousemove(view, event) {
              handleMouseMove(
                view,
                event,
                handleWidth,
                cellMinWidth,
                lastColumnResizable
              );
            },
            mouseleave(view) {
              handleMouseLeave(view);
            },
            mousedown(view, event) {
              handleMouseDown(view, event, cellMinWidth);
            }
          },
          decorations(state) {
            let pluginState = key.getState(state);
            if (pluginState.activeHandle > -1)
              return handleDecorations(state, pluginState.activeHandle);
          },
          nodeViews: {}
        }
      });
      return plugin;
    }
    var ResizeState = class {
      constructor(activeHandle, dragging) {
        this.activeHandle = activeHandle;
        this.dragging = dragging;
      }
      apply(tr) {
        let state = this, action = tr.getMeta(key);
        if (action && action.setHandle != null)
          return new ResizeState(action.setHandle, null);
        if (action && action.setDragging !== void 0)
          return new ResizeState(state.activeHandle, action.setDragging);
        if (state.activeHandle > -1 && tr.docChanged) {
          let handle = tr.mapping.map(state.activeHandle, -1);
          if (!pointsAtCell(tr.doc.resolve(handle)))
            handle = null;
          state = new ResizeState(handle, state.dragging);
        }
        return state;
      }
    };
    function handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {
      let pluginState = key.getState(view.state);
      if (!pluginState.dragging) {
        let target = domCellAround(event.target), cell = -1;
        if (target) {
          let { left, right } = target.getBoundingClientRect();
          if (event.clientX - left <= handleWidth)
            cell = edgeCell(view, event, "left");
          else if (right - event.clientX <= handleWidth)
            cell = edgeCell(view, event, "right");
        }
        if (cell != pluginState.activeHandle) {
          if (!lastColumnResizable && cell !== -1) {
            let $cell = view.state.doc.resolve(cell);
            let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);
            let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
            if (col == map.width - 1) {
              return;
            }
          }
          updateHandle(view, cell);
        }
      }
    }
    function handleMouseLeave(view) {
      let pluginState = key.getState(view.state);
      if (pluginState.activeHandle > -1 && !pluginState.dragging)
        updateHandle(view, -1);
    }
    function handleMouseDown(view, event, cellMinWidth) {
      let pluginState = key.getState(view.state);
      if (pluginState.activeHandle == -1 || pluginState.dragging)
        return false;
      let cell = view.state.doc.nodeAt(pluginState.activeHandle);
      let width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
      view.dispatch(
        view.state.tr.setMeta(key, {
          setDragging: { startX: event.clientX, startWidth: width }
        })
      );
      function finish(event2) {
        window.removeEventListener("mouseup", finish);
        window.removeEventListener("mousemove", move);
        let pluginState2 = key.getState(view.state);
        if (pluginState2.dragging) {
          updateColumnWidth(
            view,
            pluginState2.activeHandle,
            draggedWidth(pluginState2.dragging, event2, cellMinWidth)
          );
          view.dispatch(view.state.tr.setMeta(key, { setDragging: null }));
        }
      }
      function move(event2) {
        if (!event2.which)
          return finish(event2);
        let pluginState2 = key.getState(view.state);
        let dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
        displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);
      }
      window.addEventListener("mouseup", finish);
      window.addEventListener("mousemove", move);
      event.preventDefault();
      return true;
    }
    function currentColWidth(view, cellPos, { colspan, colwidth }) {
      let width = colwidth && colwidth[colwidth.length - 1];
      if (width)
        return width;
      let dom = view.domAtPos(cellPos);
      let node = dom.node.childNodes[dom.offset];
      let domWidth = node.offsetWidth, parts = colspan;
      if (colwidth) {
        for (let i = 0; i < colspan; i++)
          if (colwidth[i]) {
            domWidth -= colwidth[i];
            parts--;
          }
      }
      return domWidth / parts;
    }
    function domCellAround(target) {
      while (target && target.nodeName != "TD" && target.nodeName != "TH")
        target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
      return target;
    }
    function edgeCell(view, event, side) {
      let found = view.posAtCoords({ left: event.clientX, top: event.clientY });
      if (!found)
        return -1;
      let { pos } = found;
      let $cell = cellAround(view.state.doc.resolve(pos));
      if (!$cell)
        return -1;
      if (side == "right")
        return $cell.pos;
      let map = TableMap.get($cell.node(-1)), start = $cell.start(-1);
      let index = map.map.indexOf($cell.pos - start);
      return index % map.width == 0 ? -1 : start + map.map[index - 1];
    }
    function draggedWidth(dragging, event, cellMinWidth) {
      let offset = event.clientX - dragging.startX;
      return Math.max(cellMinWidth, dragging.startWidth + offset);
    }
    function updateHandle(view, value) {
      view.dispatch(view.state.tr.setMeta(key, { setHandle: value }));
    }
    function updateColumnWidth(view, cell, width) {
      let $cell = view.state.doc.resolve(cell);
      let table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);
      let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
      let tr = view.state.tr;
      for (let row = 0; row < map.height; row++) {
        let mapIndex = row * map.width + col;
        if (row && map.map[mapIndex] == map.map[mapIndex - map.width])
          continue;
        let pos = map.map[mapIndex], { attrs } = table.nodeAt(pos);
        let index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);
        if (attrs.colwidth && attrs.colwidth[index] == width)
          continue;
        let colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
        colwidth[index] = width;
        tr.setNodeMarkup(start + pos, null, setAttr(attrs, "colwidth", colwidth));
      }
      if (tr.docChanged)
        view.dispatch(tr);
    }
    function displayColumnWidth(view, cell, width, cellMinWidth) {
      let $cell = view.state.doc.resolve(cell);
      let table = $cell.node(-1), start = $cell.start(-1);
      let col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;
      let dom = view.domAtPos($cell.start(-1)).node;
      while (dom.nodeName != "TABLE")
        dom = dom.parentNode;
      updateColumns(table, dom.firstChild, dom, cellMinWidth, col, width);
    }
    function zeroes(n) {
      let result = [];
      for (let i = 0; i < n; i++)
        result.push(0);
      return result;
    }
    function handleDecorations(state, cell) {
      let decorations = [];
      let $cell = state.doc.resolve(cell);
      let table = $cell.node(-1);
      if (!table) {
        return prosemirrorView.DecorationSet.empty;
      }
      let map = TableMap.get(table);
      let start = $cell.start(-1);
      let col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan;
      for (let row = 0; row < map.height; row++) {
        let index = col + row * map.width - 1;
        if ((col == map.width || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index - 1] != map.map[index - 1 - map.width])) {
          let cellPos = map.map[index];
          let pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;
          let dom = document.createElement("div");
          dom.className = "column-resize-handle";
          decorations.push(prosemirrorView.Decoration.widget(pos, dom));
        }
      }
      return prosemirrorView.DecorationSet.create(state.doc, decorations);
    }
    function tableEditing({ allowTableNodeSelection = false } = {}) {
      return new prosemirrorState.Plugin({
        key: key$1,
        state: {
          init() {
            return null;
          },
          apply(tr, cur) {
            let set = tr.getMeta(key$1);
            if (set != null)
              return set == -1 ? null : set;
            if (cur == null || !tr.docChanged)
              return cur;
            let { deleted, pos } = tr.mapping.mapResult(cur);
            return deleted ? null : pos;
          }
        },
        props: {
          decorations: drawCellSelection,
          handleDOMEvents: {
            mousedown: handleMouseDown$1
          },
          createSelectionBetween(view) {
            if (key$1.getState(view.state) != null)
              return view.state.selection;
          },
          handleTripleClick,
          handleKeyDown,
          handlePaste
        },
        appendTransaction(_, oldState, state) {
          return normalizeSelection(
            state,
            fixTables(state, oldState),
            allowTableNodeSelection
          );
        }
      });
    }
    exports.CellSelection = CellSelection;
    exports.TableMap = TableMap;
    exports.TableView = TableView;
    exports.__clipCells = clipCells;
    exports.__insertCells = insertCells;
    exports.__pastedCells = pastedCells;
    exports.addColSpan = addColSpan;
    exports.addColumn = addColumn;
    exports.addColumnAfter = addColumnAfter;
    exports.addColumnBefore = addColumnBefore;
    exports.addRow = addRow;
    exports.addRowAfter = addRowAfter;
    exports.addRowBefore = addRowBefore;
    exports.cellAround = cellAround;
    exports.colCount = colCount;
    exports.columnIsHeader = columnIsHeader;
    exports.columnResizing = columnResizing;
    exports.columnResizingPluginKey = key;
    exports.deleteColumn = deleteColumn;
    exports.deleteRow = deleteRow;
    exports.deleteTable = deleteTable;
    exports.findCell = findCell;
    exports.fixTables = fixTables;
    exports.fixTablesKey = fixTablesKey;
    exports.goToNextCell = goToNextCell;
    exports.handlePaste = handlePaste;
    exports.inSameTable = inSameTable;
    exports.isInTable = isInTable;
    exports.mergeCells = mergeCells;
    exports.moveCellForward = moveCellForward;
    exports.nextCell = nextCell;
    exports.pointsAtCell = pointsAtCell;
    exports.removeColSpan = removeColSpan;
    exports.removeColumn = removeColumn;
    exports.removeRow = removeRow;
    exports.rowIsHeader = rowIsHeader;
    exports.selectedRect = selectedRect;
    exports.selectionCell = selectionCell;
    exports.setAttr = setAttr;
    exports.setCellAttr = setCellAttr;
    exports.splitCell = splitCell;
    exports.splitCellWithType = splitCellWithType;
    exports.tableEditing = tableEditing;
    exports.tableEditingKey = key$1;
    exports.tableNodeTypes = tableNodeTypes;
    exports.tableNodes = tableNodes;
    exports.toggleHeader = toggleHeader;
    exports.toggleHeaderCell = toggleHeaderCell;
    exports.toggleHeaderColumn = toggleHeaderColumn;
    exports.toggleHeaderRow = toggleHeaderRow;
    exports.updateColumnsOnResize = updateColumns;
  }
});

// node_modules/prosemirror-utils/dist/index.js
var require_dist8 = __commonJS({
  "node_modules/prosemirror-utils/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var prosemirrorState = require_dist4();
    var prosemirrorModel = require_dist2();
    var prosemirrorTables = require_dist7();
    var removeParentNodeOfType = function removeParentNodeOfType2(nodeType) {
      return function(tr) {
        var parent = findParentNodeOfType(nodeType)(tr.selection);
        if (parent) {
          return removeNodeAtPos(parent.pos)(tr);
        }
        return tr;
      };
    };
    var replaceParentNodeOfType = function replaceParentNodeOfType2(nodeType, content) {
      return function(tr) {
        if (!Array.isArray(nodeType)) {
          nodeType = [nodeType];
        }
        for (var i = 0, count = nodeType.length; i < count; i++) {
          var parent = findParentNodeOfType(nodeType[i])(tr.selection);
          if (parent) {
            var newTr = replaceNodeAtPos(parent.pos, content)(tr);
            if (newTr !== tr) {
              return newTr;
            }
          }
        }
        return tr;
      };
    };
    var removeSelectedNode = function removeSelectedNode2(tr) {
      if (isNodeSelection(tr.selection)) {
        var from = tr.selection.$from.pos;
        var to = tr.selection.$to.pos;
        return cloneTr(tr.delete(from, to));
      }
      return tr;
    };
    var replaceSelectedNode = function replaceSelectedNode2(content) {
      return function(tr) {
        if (isNodeSelection(tr.selection)) {
          var _tr$selection = tr.selection, $from = _tr$selection.$from, $to = _tr$selection.$to;
          if (content instanceof prosemirrorModel.Fragment && $from.parent.canReplace($from.index(), $from.indexAfter(), content) || $from.parent.canReplaceWith($from.index(), $from.indexAfter(), content.type)) {
            return cloneTr(tr.replaceWith($from.pos, $to.pos, content).setSelection(new prosemirrorState.NodeSelection(tr.doc.resolve($from.pos))));
          }
        }
        return tr;
      };
    };
    var setTextSelection = function setTextSelection2(position) {
      var dir = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      return function(tr) {
        var nextSelection = prosemirrorState.Selection.findFrom(tr.doc.resolve(position), dir, true);
        if (nextSelection) {
          return tr.setSelection(nextSelection);
        }
        return tr;
      };
    };
    var isSelectableNode = function isSelectableNode2(node) {
      return node.type && node.type.spec.selectable;
    };
    var shouldSelectNode = function shouldSelectNode2(node) {
      return isSelectableNode(node) && node.type.isLeaf;
    };
    var setSelection = function setSelection2(node, pos, tr) {
      if (shouldSelectNode(node)) {
        return tr.setSelection(new prosemirrorState.NodeSelection(tr.doc.resolve(pos)));
      }
      return setTextSelection(pos)(tr);
    };
    var safeInsert = function safeInsert2(content, position, tryToReplace) {
      return function(tr) {
        var hasPosition = typeof position === "number";
        var $from = tr.selection.$from;
        var $insertPos = hasPosition ? tr.doc.resolve(position) : isNodeSelection(tr.selection) ? tr.doc.resolve($from.pos + 1) : $from;
        var parent = $insertPos.parent;
        if (isNodeSelection(tr.selection) && tryToReplace) {
          var oldTr = tr;
          tr = replaceSelectedNode(content)(tr);
          if (oldTr !== tr) {
            return tr;
          }
        }
        if (isEmptyParagraph(parent)) {
          var _oldTr = tr;
          tr = replaceParentNodeOfType(parent.type, content)(tr);
          if (_oldTr !== tr) {
            var pos = isSelectableNode(content) ? $insertPos.before($insertPos.depth) : $insertPos.pos;
            return setSelection(content, pos, tr);
          }
        }
        if (canInsert($insertPos, content)) {
          tr.insert($insertPos.pos, content);
          var _pos = hasPosition ? $insertPos.pos : isSelectableNode(content) ? tr.selection.$anchor.pos - 1 : tr.selection.$anchor.pos;
          return cloneTr(setSelection(content, _pos, tr));
        }
        for (var i = $insertPos.depth; i > 0; i--) {
          var _pos2 = $insertPos.after(i);
          var $pos = tr.doc.resolve(_pos2);
          if (canInsert($pos, content)) {
            tr.insert(_pos2, content);
            return cloneTr(setSelection(content, _pos2, tr));
          }
        }
        return tr;
      };
    };
    var setParentNodeMarkup = function setParentNodeMarkup2(nodeType, type, attrs, marks) {
      return function(tr) {
        var parent = findParentNodeOfType(nodeType)(tr.selection);
        if (parent) {
          return cloneTr(tr.setNodeMarkup(parent.pos, type, Object.assign({}, parent.node.attrs, attrs), marks));
        }
        return tr;
      };
    };
    var selectParentNodeOfType = function selectParentNodeOfType2(nodeType) {
      return function(tr) {
        if (!isNodeSelection(tr.selection)) {
          var parent = findParentNodeOfType(nodeType)(tr.selection);
          if (parent) {
            return cloneTr(tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, parent.pos)));
          }
        }
        return tr;
      };
    };
    var removeNodeBefore = function removeNodeBefore2(tr) {
      var position = findPositionOfNodeBefore(tr.selection);
      if (typeof position === "number") {
        return removeNodeAtPos(position)(tr);
      }
      return tr;
    };
    var isNodeSelection = function isNodeSelection2(selection) {
      return selection instanceof prosemirrorState.NodeSelection;
    };
    var equalNodeType = function equalNodeType2(nodeType, node) {
      return Array.isArray(nodeType) && nodeType.indexOf(node.type) > -1 || node.type === nodeType;
    };
    var cloneTr = function cloneTr2(tr) {
      return Object.assign(Object.create(tr), tr).setTime(Date.now());
    };
    var replaceNodeAtPos = function replaceNodeAtPos2(position, content) {
      return function(tr) {
        var node = tr.doc.nodeAt(position);
        var $pos = tr.doc.resolve(position);
        if (canReplace($pos, content)) {
          tr = tr.replaceWith(position, position + node.nodeSize, content);
          var start = tr.selection.$from.pos - 1;
          tr = setTextSelection(Math.max(start, 0), -1)(tr);
          tr = setTextSelection(tr.selection.$from.start())(tr);
          return cloneTr(tr);
        }
        return tr;
      };
    };
    var canReplace = function canReplace2($pos, content) {
      var node = $pos.node($pos.depth);
      return node && node.type.validContent(content instanceof prosemirrorModel.Fragment ? content : prosemirrorModel.Fragment.from(content));
    };
    var removeNodeAtPos = function removeNodeAtPos2(position) {
      return function(tr) {
        var node = tr.doc.nodeAt(position);
        return cloneTr(tr.delete(position, position + node.nodeSize));
      };
    };
    var tableNodeTypes = function tableNodeTypes2(schema) {
      if (schema.cached.tableNodeTypes) {
        return schema.cached.tableNodeTypes;
      }
      var roles = {};
      Object.keys(schema.nodes).forEach(function(type) {
        var nodeType = schema.nodes[type];
        if (nodeType.spec.tableRole) {
          roles[nodeType.spec.tableRole] = nodeType;
        }
      });
      schema.cached.tableNodeTypes = roles;
      return roles;
    };
    var canInsert = function canInsert2($pos, content) {
      var index = $pos.index();
      if (content instanceof prosemirrorModel.Fragment) {
        return $pos.parent.canReplace(index, index, content);
      } else if (content instanceof prosemirrorModel.Node) {
        return $pos.parent.canReplaceWith(index, index, content.type);
      }
      return false;
    };
    var isEmptyParagraph = function isEmptyParagraph2(node) {
      return !node || node.type.name === "paragraph" && node.nodeSize === 2;
    };
    var findTableClosestToPos = function findTableClosestToPos2($pos) {
      var predicate = function predicate2(node) {
        return node.type.spec.tableRole && /table/i.test(node.type.spec.tableRole);
      };
      return findParentNodeClosestToPos($pos, predicate);
    };
    var createCell = function createCell2(cellType) {
      var cellContent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (cellContent) {
        return cellType.createChecked(null, cellContent);
      }
      return cellType.createAndFill();
    };
    var isRectSelected = function isRectSelected2(rect) {
      return function(selection) {
        var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
        var start = selection.$anchorCell.start(-1);
        var cells = map.cellsInRect(rect);
        var selectedCells = map.cellsInRect(map.rectBetween(selection.$anchorCell.pos - start, selection.$headCell.pos - start));
        for (var i = 0, count = cells.length; i < count; i++) {
          if (selectedCells.indexOf(cells[i]) === -1) {
            return false;
          }
        }
        return true;
      };
    };
    var transpose = function transpose2(array) {
      return array[0].map(function(_, i) {
        return array.map(function(column) {
          return column[i];
        });
      });
    };
    var convertTableNodeToArrayOfRows = function convertTableNodeToArrayOfRows2(tableNode) {
      var map = prosemirrorTables.TableMap.get(tableNode);
      var rows = [];
      for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {
        var rowCells = [];
        var seen = {};
        for (var colIndex = 0; colIndex < map.width; colIndex++) {
          var cellPos = map.map[rowIndex * map.width + colIndex];
          var cell = tableNode.nodeAt(cellPos);
          var rect = map.findCell(cellPos);
          if (seen[cellPos] || rect.top !== rowIndex) {
            rowCells.push(null);
            continue;
          }
          seen[cellPos] = true;
          rowCells.push(cell);
        }
        rows.push(rowCells);
      }
      return rows;
    };
    var convertArrayOfRowsToTableNode = function convertArrayOfRowsToTableNode2(tableNode, arrayOfNodes) {
      var rowsPM = [];
      var map = prosemirrorTables.TableMap.get(tableNode);
      for (var rowIndex = 0; rowIndex < map.height; rowIndex++) {
        var row = tableNode.child(rowIndex);
        var rowCells = [];
        for (var colIndex = 0; colIndex < map.width; colIndex++) {
          if (!arrayOfNodes[rowIndex][colIndex]) {
            continue;
          }
          var cellPos = map.map[rowIndex * map.width + colIndex];
          var cell = arrayOfNodes[rowIndex][colIndex];
          var oldCell = tableNode.nodeAt(cellPos);
          var newCell = oldCell.type.createChecked(Object.assign({}, cell.attrs), cell.content, cell.marks);
          rowCells.push(newCell);
        }
        rowsPM.push(row.type.createChecked(row.attrs, rowCells, row.marks));
      }
      var newTable = tableNode.type.createChecked(tableNode.attrs, rowsPM, tableNode.marks);
      return newTable;
    };
    var moveTableColumn = function moveTableColumn2(table, indexesOrigin, indexesTarget, direction) {
      var rows = transpose(convertTableNodeToArrayOfRows(table.node));
      rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);
      rows = transpose(rows);
      return convertArrayOfRowsToTableNode(table.node, rows);
    };
    var moveTableRow = function moveTableRow2(table, indexesOrigin, indexesTarget, direction) {
      var rows = convertTableNodeToArrayOfRows(table.node);
      rows = moveRowInArrayOfRows(rows, indexesOrigin, indexesTarget, direction);
      return convertArrayOfRowsToTableNode(table.node, rows);
    };
    var moveRowInArrayOfRows = function moveRowInArrayOfRows2(rows, indexesOrigin, indexesTarget, directionOverride) {
      var direction = indexesOrigin[0] > indexesTarget[0] ? -1 : 1;
      var rowsExtracted = rows.splice(indexesOrigin[0], indexesOrigin.length);
      var positionOffset = rowsExtracted.length % 2 === 0 ? 1 : 0;
      var target = void 0;
      if (directionOverride === -1 && direction === 1) {
        target = indexesTarget[0] - 1;
      } else if (directionOverride === 1 && direction === -1) {
        target = indexesTarget[indexesTarget.length - 1] - positionOffset + 1;
      } else {
        target = direction === -1 ? indexesTarget[0] : indexesTarget[indexesTarget.length - 1] - positionOffset;
      }
      rows.splice.apply(rows, [target, 0].concat(rowsExtracted));
      return rows;
    };
    var checkInvalidMovements = function checkInvalidMovements2(originIndex, targetIndex, targets, type) {
      var direction = originIndex > targetIndex ? -1 : 1;
      var errorMessage = "Target position is invalid, you can't move the " + type + " " + originIndex + " to " + targetIndex + ", the target can't be split. You could use tryToFit option.";
      if (direction === 1) {
        if (targets.slice(0, targets.length - 1).indexOf(targetIndex) !== -1) {
          throw new Error(errorMessage);
        }
      } else {
        if (targets.slice(1).indexOf(targetIndex) !== -1) {
          throw new Error(errorMessage);
        }
      }
      return true;
    };
    var findParentNode = function findParentNode2(predicate) {
      return function(_ref) {
        var $from = _ref.$from;
        return findParentNodeClosestToPos($from, predicate);
      };
    };
    var findParentNodeClosestToPos = function findParentNodeClosestToPos2($pos, predicate) {
      for (var i = $pos.depth; i > 0; i--) {
        var node = $pos.node(i);
        if (predicate(node)) {
          return {
            pos: i > 0 ? $pos.before(i) : 0,
            start: $pos.start(i),
            depth: i,
            node
          };
        }
      }
    };
    var findParentDomRef = function findParentDomRef2(predicate, domAtPos) {
      return function(selection) {
        var parent = findParentNode(predicate)(selection);
        if (parent) {
          return findDomRefAtPos(parent.pos, domAtPos);
        }
      };
    };
    var hasParentNode = function hasParentNode2(predicate) {
      return function(selection) {
        return !!findParentNode(predicate)(selection);
      };
    };
    var findParentNodeOfType = function findParentNodeOfType2(nodeType) {
      return function(selection) {
        return findParentNode(function(node) {
          return equalNodeType(nodeType, node);
        })(selection);
      };
    };
    var findParentNodeOfTypeClosestToPos = function findParentNodeOfTypeClosestToPos2($pos, nodeType) {
      return findParentNodeClosestToPos($pos, function(node) {
        return equalNodeType(nodeType, node);
      });
    };
    var hasParentNodeOfType = function hasParentNodeOfType2(nodeType) {
      return function(selection) {
        return hasParentNode(function(node) {
          return equalNodeType(nodeType, node);
        })(selection);
      };
    };
    var findParentDomRefOfType = function findParentDomRefOfType2(nodeType, domAtPos) {
      return function(selection) {
        return findParentDomRef(function(node) {
          return equalNodeType(nodeType, node);
        }, domAtPos)(selection);
      };
    };
    var findSelectedNodeOfType = function findSelectedNodeOfType2(nodeType) {
      return function(selection) {
        if (isNodeSelection(selection)) {
          var node = selection.node, $from = selection.$from;
          if (equalNodeType(nodeType, node)) {
            return { node, pos: $from.pos, depth: $from.depth };
          }
        }
      };
    };
    var findPositionOfNodeBefore = function findPositionOfNodeBefore2(selection) {
      var nodeBefore = selection.$from.nodeBefore;
      var maybeSelection = prosemirrorState.Selection.findFrom(selection.$from, -1);
      if (maybeSelection && nodeBefore) {
        var parent = findParentNodeOfType(nodeBefore.type)(maybeSelection);
        if (parent) {
          return parent.pos;
        }
        return maybeSelection.$from.pos;
      }
    };
    var findDomRefAtPos = function findDomRefAtPos2(position, domAtPos) {
      var dom = domAtPos(position);
      var node = dom.node.childNodes[dom.offset];
      if (dom.node.nodeType === Node.TEXT_NODE) {
        return dom.node.parentNode;
      }
      if (!node || node.nodeType === Node.TEXT_NODE) {
        return dom.node;
      }
      return node;
    };
    var flatten = function flatten2(node) {
      var descend = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (!node) {
        throw new Error('Invalid "node" parameter');
      }
      var result = [];
      node.descendants(function(child, pos) {
        result.push({ node: child, pos });
        if (!descend) {
          return false;
        }
      });
      return result;
    };
    var findChildren = function findChildren2(node, predicate, descend) {
      if (!node) {
        throw new Error('Invalid "node" parameter');
      } else if (!predicate) {
        throw new Error('Invalid "predicate" parameter');
      }
      return flatten(node, descend).filter(function(child) {
        return predicate(child.node);
      });
    };
    var findTextNodes = function findTextNodes2(node, descend) {
      return findChildren(node, function(child) {
        return child.isText;
      }, descend);
    };
    var findInlineNodes = function findInlineNodes2(node, descend) {
      return findChildren(node, function(child) {
        return child.isInline;
      }, descend);
    };
    var findBlockNodes = function findBlockNodes2(node, descend) {
      return findChildren(node, function(child) {
        return child.isBlock;
      }, descend);
    };
    var findChildrenByAttr = function findChildrenByAttr2(node, predicate, descend) {
      return findChildren(node, function(child) {
        return !!predicate(child.attrs);
      }, descend);
    };
    var findChildrenByType = function findChildrenByType2(node, nodeType, descend) {
      return findChildren(node, function(child) {
        return child.type === nodeType;
      }, descend);
    };
    var findChildrenByMark = function findChildrenByMark2(node, markType, descend) {
      return findChildren(node, function(child) {
        return markType.isInSet(child.marks);
      }, descend);
    };
    var contains = function contains2(node, nodeType) {
      return !!findChildrenByType(node, nodeType).length;
    };
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var findTable = function findTable2(selection) {
      return findParentNode(function(node) {
        return node.type.spec.tableRole && node.type.spec.tableRole === "table";
      })(selection);
    };
    var isCellSelection = function isCellSelection2(selection) {
      return selection instanceof prosemirrorTables.CellSelection;
    };
    var getSelectionRect = function getSelectionRect2(selection) {
      if (!isCellSelection(selection)) {
        return;
      }
      var start = selection.$anchorCell.start(-1);
      var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
      return map.rectBetween(selection.$anchorCell.pos - start, selection.$headCell.pos - start);
    };
    var isColumnSelected = function isColumnSelected2(columnIndex) {
      return function(selection) {
        if (isCellSelection(selection)) {
          var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
          return isRectSelected({
            left: columnIndex,
            right: columnIndex + 1,
            top: 0,
            bottom: map.height
          })(selection);
        }
        return false;
      };
    };
    var isRowSelected = function isRowSelected2(rowIndex) {
      return function(selection) {
        if (isCellSelection(selection)) {
          var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
          return isRectSelected({
            left: 0,
            right: map.width,
            top: rowIndex,
            bottom: rowIndex + 1
          })(selection);
        }
        return false;
      };
    };
    var isTableSelected = function isTableSelected2(selection) {
      if (isCellSelection(selection)) {
        var map = prosemirrorTables.TableMap.get(selection.$anchorCell.node(-1));
        return isRectSelected({
          left: 0,
          right: map.width,
          top: 0,
          bottom: map.height
        })(selection);
      }
      return false;
    };
    var getCellsInColumn = function getCellsInColumn2(columnIndex) {
      return function(selection) {
        var table = findTable(selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var indexes = Array.isArray(columnIndex) ? columnIndex : Array.from([columnIndex]);
          return indexes.reduce(function(acc, index) {
            if (index >= 0 && index <= map.width - 1) {
              var cells = map.cellsInRect({
                left: index,
                right: index + 1,
                top: 0,
                bottom: map.height
              });
              return acc.concat(cells.map(function(nodePos) {
                var node = table.node.nodeAt(nodePos);
                var pos = nodePos + table.start;
                return { pos, start: pos + 1, node };
              }));
            }
          }, []);
        }
      };
    };
    var getCellsInRow = function getCellsInRow2(rowIndex) {
      return function(selection) {
        var table = findTable(selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var indexes = Array.isArray(rowIndex) ? rowIndex : Array.from([rowIndex]);
          return indexes.reduce(function(acc, index) {
            if (index >= 0 && index <= map.height - 1) {
              var cells = map.cellsInRect({
                left: 0,
                right: map.width,
                top: index,
                bottom: index + 1
              });
              return acc.concat(cells.map(function(nodePos) {
                var node = table.node.nodeAt(nodePos);
                var pos = nodePos + table.start;
                return { pos, start: pos + 1, node };
              }));
            }
          }, []);
        }
      };
    };
    var getCellsInTable = function getCellsInTable2(selection) {
      var table = findTable(selection);
      if (table) {
        var map = prosemirrorTables.TableMap.get(table.node);
        var cells = map.cellsInRect({
          left: 0,
          right: map.width,
          top: 0,
          bottom: map.height
        });
        return cells.map(function(nodePos) {
          var node = table.node.nodeAt(nodePos);
          var pos = nodePos + table.start;
          return { pos, start: pos + 1, node };
        });
      }
    };
    var select = function select2(type) {
      return function(index, expand) {
        return function(tr) {
          var table = findTable(tr.selection);
          var isRowSelection = type === "row";
          if (table) {
            var map = prosemirrorTables.TableMap.get(table.node);
            if (index >= 0 && index < (isRowSelection ? map.height : map.width)) {
              var left = isRowSelection ? 0 : index;
              var top = isRowSelection ? index : 0;
              var right = isRowSelection ? map.width : index + 1;
              var bottom = isRowSelection ? index + 1 : map.height;
              if (expand) {
                var cell = findCellClosestToPos(tr.selection.$from);
                if (!cell) {
                  return tr;
                }
                var selRect = map.findCell(cell.pos - table.start);
                if (isRowSelection) {
                  top = Math.min(top, selRect.top);
                  bottom = Math.max(bottom, selRect.bottom);
                } else {
                  left = Math.min(left, selRect.left);
                  right = Math.max(right, selRect.right);
                }
              }
              var cellsInFirstRow = map.cellsInRect({
                left,
                top,
                right: isRowSelection ? right : left + 1,
                bottom: isRowSelection ? top + 1 : bottom
              });
              var cellsInLastRow = bottom - top === 1 ? cellsInFirstRow : map.cellsInRect({
                left: isRowSelection ? left : right - 1,
                top: isRowSelection ? bottom - 1 : top,
                right,
                bottom
              });
              var head = table.start + cellsInFirstRow[0];
              var anchor = table.start + cellsInLastRow[cellsInLastRow.length - 1];
              var $head = tr.doc.resolve(head);
              var $anchor = tr.doc.resolve(anchor);
              return cloneTr(tr.setSelection(new prosemirrorTables.CellSelection($anchor, $head)));
            }
          }
          return tr;
        };
      };
    };
    var selectColumn = select("column");
    var selectRow = select("row");
    var selectTable = function selectTable2(tr) {
      var table = findTable(tr.selection);
      if (table) {
        var _TableMap$get = prosemirrorTables.TableMap.get(table.node), map = _TableMap$get.map;
        if (map && map.length) {
          var head = table.start + map[0];
          var anchor = table.start + map[map.length - 1];
          var $head = tr.doc.resolve(head);
          var $anchor = tr.doc.resolve(anchor);
          return cloneTr(tr.setSelection(new prosemirrorTables.CellSelection($anchor, $head)));
        }
      }
      return tr;
    };
    var emptyCell = function emptyCell2(cell, schema) {
      return function(tr) {
        if (cell) {
          var _tableNodeTypes$cell$ = tableNodeTypes(schema).cell.createAndFill(), content = _tableNodeTypes$cell$.content;
          if (!cell.node.content.eq(content)) {
            tr.replaceWith(cell.pos + 1, cell.pos + cell.node.nodeSize, content);
            return cloneTr(tr);
          }
        }
        return tr;
      };
    };
    var addColumnAt = function addColumnAt2(columnIndex) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          if (columnIndex >= 0 && columnIndex <= map.width) {
            return cloneTr(prosemirrorTables.addColumn(tr, {
              map,
              tableStart: table.start,
              table: table.node
            }, columnIndex));
          }
        }
        return tr;
      };
    };
    var moveRow = function moveRow2(originRowIndex, targetRowIndex, opts) {
      return function(tr) {
        var defaultOptions = { tryToFit: false, direction: 0 };
        var options = Object.assign(defaultOptions, opts);
        var table = findTable(tr.selection);
        if (!table) {
          return tr;
        }
        var _getSelectionRangeInR = getSelectionRangeInRow(originRowIndex)(tr), indexesOriginRow = _getSelectionRangeInR.indexes;
        var _getSelectionRangeInR2 = getSelectionRangeInRow(targetRowIndex)(tr), indexesTargetRow = _getSelectionRangeInR2.indexes;
        if (indexesOriginRow.indexOf(targetRowIndex) > -1) {
          return tr;
        }
        if (!options.tryToFit && indexesTargetRow.length > 1) {
          checkInvalidMovements(originRowIndex, targetRowIndex, indexesTargetRow, "row");
        }
        var newTable = moveTableRow(table, indexesOriginRow, indexesTargetRow, options.direction);
        return cloneTr(tr).replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);
      };
    };
    var moveColumn = function moveColumn2(originColumnIndex, targetColumnIndex, opts) {
      return function(tr) {
        var defaultOptions = { tryToFit: false, direction: 0 };
        var options = Object.assign(defaultOptions, opts);
        var table = findTable(tr.selection);
        if (!table) {
          return tr;
        }
        var _getSelectionRangeInC = getSelectionRangeInColumn(originColumnIndex)(tr), indexesOriginColumn = _getSelectionRangeInC.indexes;
        var _getSelectionRangeInC2 = getSelectionRangeInColumn(targetColumnIndex)(tr), indexesTargetColumn = _getSelectionRangeInC2.indexes;
        if (indexesOriginColumn.indexOf(targetColumnIndex) > -1) {
          return tr;
        }
        if (!options.tryToFit && indexesTargetColumn.length > 1) {
          checkInvalidMovements(originColumnIndex, targetColumnIndex, indexesTargetColumn, "column");
        }
        var newTable = moveTableColumn(table, indexesOriginColumn, indexesTargetColumn, options.direction);
        return cloneTr(tr).replaceWith(table.pos, table.pos + table.node.nodeSize, newTable);
      };
    };
    var addRowAt = function addRowAt2(rowIndex, clonePreviousRow) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var cloneRowIndex = rowIndex - 1;
          if (clonePreviousRow && cloneRowIndex >= 0) {
            return cloneTr(cloneRowAt(cloneRowIndex)(tr));
          }
          if (rowIndex >= 0 && rowIndex <= map.height) {
            return cloneTr(prosemirrorTables.addRow(tr, {
              map,
              tableStart: table.start,
              table: table.node
            }, rowIndex));
          }
        }
        return tr;
      };
    };
    var cloneRowAt = function cloneRowAt2(rowIndex) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          if (rowIndex >= 0 && rowIndex <= map.height) {
            var tableNode = table.node;
            var tableNodes = tableNodeTypes(tableNode.type.schema);
            var rowPos = table.start;
            for (var i = 0; i < rowIndex + 1; i++) {
              rowPos += tableNode.child(i).nodeSize;
            }
            var cloneRow = tableNode.child(rowIndex);
            var cells = [];
            var rowWidth = 0;
            cloneRow.forEach(function(cell) {
              if (cell.attrs.rowspan === 1) {
                rowWidth += cell.attrs.colspan;
                cells.push(tableNodes[cell.type.spec.tableRole].createAndFill(cell.attrs, cell.marks));
              }
            });
            if (rowWidth < map.width) {
              var rowSpanCells = [];
              var _loop = function _loop2(_i2) {
                var foundCells = filterCellsInRow(_i2, function(cell, tr2) {
                  var rowspan = cell.node.attrs.rowspan;
                  var spanRange = _i2 + rowspan;
                  return rowspan > 1 && spanRange > rowIndex;
                })(tr);
                rowSpanCells.push.apply(rowSpanCells, _toConsumableArray(foundCells));
              };
              for (var _i = rowIndex; _i >= 0; _i--) {
                _loop(_i);
              }
              if (rowSpanCells.length) {
                rowSpanCells.forEach(function(cell) {
                  tr = setCellAttrs(cell, {
                    rowspan: cell.node.attrs.rowspan + 1
                  })(tr);
                });
              }
            }
            return safeInsert(tableNodes.row.create(cloneRow.attrs, cells), rowPos)(tr);
          }
        }
        return tr;
      };
    };
    var removeColumnAt = function removeColumnAt2(columnIndex) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          if (columnIndex === 0 && map.width === 1) {
            return removeTable(tr);
          } else if (columnIndex >= 0 && columnIndex <= map.width) {
            prosemirrorTables.removeColumn(tr, {
              map,
              tableStart: table.start,
              table: table.node
            }, columnIndex);
            return cloneTr(tr);
          }
        }
        return tr;
      };
    };
    var removeRowAt = function removeRowAt2(rowIndex) {
      return function(tr) {
        var table = findTable(tr.selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          if (rowIndex === 0 && map.height === 1) {
            return removeTable(tr);
          } else if (rowIndex >= 0 && rowIndex <= map.height) {
            prosemirrorTables.removeRow(tr, {
              map,
              tableStart: table.start,
              table: table.node
            }, rowIndex);
            return cloneTr(tr);
          }
        }
        return tr;
      };
    };
    var removeTable = function removeTable2(tr) {
      var $from = tr.selection.$from;
      for (var depth = $from.depth; depth > 0; depth--) {
        var node = $from.node(depth);
        if (node.type.spec.tableRole === "table") {
          return cloneTr(tr.delete($from.before(depth), $from.after(depth)));
        }
      }
      return tr;
    };
    var removeSelectedColumns = function removeSelectedColumns2(tr) {
      var selection = tr.selection;
      if (isTableSelected(selection)) {
        return removeTable(tr);
      }
      if (isCellSelection(selection)) {
        var table = findTable(selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);
          if (rect.left == 0 && rect.right == map.width) {
            return false;
          }
          var pmTableRect = Object.assign({}, rect, {
            map,
            table: table.node,
            tableStart: table.start
          });
          for (var i = pmTableRect.right - 1; ; i--) {
            prosemirrorTables.removeColumn(tr, pmTableRect, i);
            if (i === pmTableRect.left) {
              break;
            }
            pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;
            pmTableRect.map = prosemirrorTables.TableMap.get(pmTableRect.table);
          }
          return cloneTr(tr);
        }
      }
      return tr;
    };
    var removeSelectedRows = function removeSelectedRows2(tr) {
      var selection = tr.selection;
      if (isTableSelected(selection)) {
        return removeTable(tr);
      }
      if (isCellSelection(selection)) {
        var table = findTable(selection);
        if (table) {
          var map = prosemirrorTables.TableMap.get(table.node);
          var rect = map.rectBetween(selection.$anchorCell.pos - table.start, selection.$headCell.pos - table.start);
          if (rect.top == 0 && rect.bottom == map.height) {
            return false;
          }
          var pmTableRect = Object.assign({}, rect, {
            map,
            table: table.node,
            tableStart: table.start
          });
          for (var i = pmTableRect.bottom - 1; ; i--) {
            prosemirrorTables.removeRow(tr, pmTableRect, i);
            if (i === pmTableRect.top) {
              break;
            }
            pmTableRect.table = pmTableRect.tableStart ? tr.doc.nodeAt(pmTableRect.tableStart - 1) : tr.doc;
            pmTableRect.map = prosemirrorTables.TableMap.get(pmTableRect.table);
          }
          return cloneTr(tr);
        }
      }
      return tr;
    };
    var removeColumnClosestToPos = function removeColumnClosestToPos2($pos) {
      return function(tr) {
        var rect = findCellRectClosestToPos($pos);
        if (rect) {
          return removeColumnAt(rect.left)(setTextSelection($pos.pos)(tr));
        }
        return tr;
      };
    };
    var removeRowClosestToPos = function removeRowClosestToPos2($pos) {
      return function(tr) {
        var rect = findCellRectClosestToPos($pos);
        if (rect) {
          return removeRowAt(rect.top)(setTextSelection($pos.pos)(tr));
        }
        return tr;
      };
    };
    var forEachCellInColumn = function forEachCellInColumn2(columnIndex, cellTransform, setCursorToLastCell) {
      return function(tr) {
        var cells = getCellsInColumn(columnIndex)(tr.selection);
        if (cells) {
          for (var i = cells.length - 1; i >= 0; i--) {
            tr = cellTransform(cells[i], tr);
          }
          if (setCursorToLastCell) {
            var $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));
            tr.setSelection(prosemirrorState.Selection.near($pos));
          }
          return cloneTr(tr);
        }
        return tr;
      };
    };
    var forEachCellInRow = function forEachCellInRow2(rowIndex, cellTransform, setCursorToLastCell) {
      return function(tr) {
        var cells = getCellsInRow(rowIndex)(tr.selection);
        if (cells) {
          for (var i = cells.length - 1; i >= 0; i--) {
            tr = cellTransform(cells[i], tr);
          }
          if (setCursorToLastCell) {
            var $pos = tr.doc.resolve(tr.mapping.map(cells[cells.length - 1].pos));
            tr.setSelection(prosemirrorState.Selection.near($pos));
          }
        }
        return tr;
      };
    };
    var setCellAttrs = function setCellAttrs2(cell, attrs) {
      return function(tr) {
        if (cell) {
          tr.setNodeMarkup(cell.pos, null, Object.assign({}, cell.node.attrs, attrs));
          return cloneTr(tr);
        }
        return tr;
      };
    };
    var createTable = function createTable2(schema) {
      var rowsCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
      var colsCount = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
      var withHeaderRow = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var cellContent = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
      var _tableNodeTypes = tableNodeTypes(schema), tableCell = _tableNodeTypes.cell, tableHeader = _tableNodeTypes.header_cell, tableRow = _tableNodeTypes.row, table = _tableNodeTypes.table;
      var cells = [];
      var headerCells = [];
      for (var i = 0; i < colsCount; i++) {
        cells.push(createCell(tableCell, cellContent));
        if (withHeaderRow) {
          headerCells.push(createCell(tableHeader, cellContent));
        }
      }
      var rows = [];
      for (var _i2 = 0; _i2 < rowsCount; _i2++) {
        rows.push(tableRow.createChecked(null, withHeaderRow && _i2 === 0 ? headerCells : cells));
      }
      return table.createChecked(null, rows);
    };
    var findCellClosestToPos = function findCellClosestToPos2($pos) {
      var predicate = function predicate2(node) {
        return node.type.spec.tableRole && /cell/i.test(node.type.spec.tableRole);
      };
      return findParentNodeClosestToPos($pos, predicate);
    };
    var findCellRectClosestToPos = function findCellRectClosestToPos2($pos) {
      var cell = findCellClosestToPos($pos);
      if (cell) {
        var table = findTableClosestToPos($pos);
        var map = prosemirrorTables.TableMap.get(table.node);
        var cellPos = cell.pos - table.start;
        return map.rectBetween(cellPos, cellPos);
      }
    };
    var filterCellsInRow = function filterCellsInRow2(rowIndex, predicate) {
      return function(tr) {
        var foundCells = [];
        var cells = getCellsInRow(rowIndex)(tr.selection);
        if (cells) {
          for (var j = cells.length - 1; j >= 0; j--) {
            if (predicate(cells[j], tr)) {
              foundCells.push(cells[j]);
            }
          }
        }
        return foundCells;
      };
    };
    var getSelectionRangeInColumn = function getSelectionRangeInColumn2(columnIndex) {
      return function(tr) {
        var startIndex = columnIndex;
        var endIndex = columnIndex;
        var _loop2 = function _loop22(i2) {
          var cells = getCellsInColumn(i2)(tr.selection);
          if (cells) {
            cells.forEach(function(cell) {
              var maybeEndIndex = cell.node.attrs.colspan + i2 - 1;
              if (maybeEndIndex >= startIndex) {
                startIndex = i2;
              }
              if (maybeEndIndex > endIndex) {
                endIndex = maybeEndIndex;
              }
            });
          }
        };
        for (var i = columnIndex; i >= 0; i--) {
          _loop2(i);
        }
        var _loop3 = function _loop32(i2) {
          var cells = getCellsInColumn(i2)(tr.selection);
          if (cells) {
            cells.forEach(function(cell) {
              var maybeEndIndex = cell.node.attrs.colspan + i2 - 1;
              if (cell.node.attrs.colspan > 1 && maybeEndIndex > endIndex) {
                endIndex = maybeEndIndex;
              }
            });
          }
        };
        for (var i = columnIndex; i <= endIndex; i++) {
          _loop3(i);
        }
        var indexes = [];
        for (var i = startIndex; i <= endIndex; i++) {
          var maybeCells = getCellsInColumn(i)(tr.selection);
          if (maybeCells && maybeCells.length) {
            indexes.push(i);
          }
        }
        startIndex = indexes[0];
        endIndex = indexes[indexes.length - 1];
        var firstSelectedColumnCells = getCellsInColumn(startIndex)(tr.selection);
        var firstRowCells = getCellsInRow(0)(tr.selection);
        var $anchor = tr.doc.resolve(firstSelectedColumnCells[firstSelectedColumnCells.length - 1].pos);
        var headCell = void 0;
        for (var _i3 = endIndex; _i3 >= startIndex; _i3--) {
          var columnCells = getCellsInColumn(_i3)(tr.selection);
          if (columnCells && columnCells.length) {
            for (var j = firstRowCells.length - 1; j >= 0; j--) {
              if (firstRowCells[j].pos === columnCells[0].pos) {
                headCell = columnCells[0];
                break;
              }
            }
            if (headCell) {
              break;
            }
          }
        }
        var $head = tr.doc.resolve(headCell.pos);
        return { $anchor, $head, indexes };
      };
    };
    var getSelectionRangeInRow = function getSelectionRangeInRow2(rowIndex) {
      return function(tr) {
        var startIndex = rowIndex;
        var endIndex = rowIndex;
        var _loop4 = function _loop42(i2) {
          var cells = getCellsInRow(i2)(tr.selection);
          cells.forEach(function(cell) {
            var maybeEndIndex = cell.node.attrs.rowspan + i2 - 1;
            if (maybeEndIndex >= startIndex) {
              startIndex = i2;
            }
            if (maybeEndIndex > endIndex) {
              endIndex = maybeEndIndex;
            }
          });
        };
        for (var i = rowIndex; i >= 0; i--) {
          _loop4(i);
        }
        var _loop5 = function _loop52(i2) {
          var cells = getCellsInRow(i2)(tr.selection);
          cells.forEach(function(cell) {
            var maybeEndIndex = cell.node.attrs.rowspan + i2 - 1;
            if (cell.node.attrs.rowspan > 1 && maybeEndIndex > endIndex) {
              endIndex = maybeEndIndex;
            }
          });
        };
        for (var i = rowIndex; i <= endIndex; i++) {
          _loop5(i);
        }
        var indexes = [];
        for (var i = startIndex; i <= endIndex; i++) {
          var maybeCells = getCellsInRow(i)(tr.selection);
          if (maybeCells && maybeCells.length) {
            indexes.push(i);
          }
        }
        startIndex = indexes[0];
        endIndex = indexes[indexes.length - 1];
        var firstSelectedRowCells = getCellsInRow(startIndex)(tr.selection);
        var firstColumnCells = getCellsInColumn(0)(tr.selection);
        var $anchor = tr.doc.resolve(firstSelectedRowCells[firstSelectedRowCells.length - 1].pos);
        var headCell = void 0;
        for (var _i4 = endIndex; _i4 >= startIndex; _i4--) {
          var rowCells = getCellsInRow(_i4)(tr.selection);
          if (rowCells && rowCells.length) {
            for (var j = firstColumnCells.length - 1; j >= 0; j--) {
              if (firstColumnCells[j].pos === rowCells[0].pos) {
                headCell = rowCells[0];
                break;
              }
            }
            if (headCell) {
              break;
            }
          }
        }
        var $head = tr.doc.resolve(headCell.pos);
        return { $anchor, $head, indexes };
      };
    };
    exports.isNodeSelection = isNodeSelection;
    exports.canInsert = canInsert;
    exports.convertTableNodeToArrayOfRows = convertTableNodeToArrayOfRows;
    exports.convertArrayOfRowsToTableNode = convertArrayOfRowsToTableNode;
    exports.findParentNode = findParentNode;
    exports.findParentNodeClosestToPos = findParentNodeClosestToPos;
    exports.findParentDomRef = findParentDomRef;
    exports.hasParentNode = hasParentNode;
    exports.findParentNodeOfType = findParentNodeOfType;
    exports.findParentNodeOfTypeClosestToPos = findParentNodeOfTypeClosestToPos;
    exports.hasParentNodeOfType = hasParentNodeOfType;
    exports.findParentDomRefOfType = findParentDomRefOfType;
    exports.findSelectedNodeOfType = findSelectedNodeOfType;
    exports.findPositionOfNodeBefore = findPositionOfNodeBefore;
    exports.findDomRefAtPos = findDomRefAtPos;
    exports.flatten = flatten;
    exports.findChildren = findChildren;
    exports.findTextNodes = findTextNodes;
    exports.findInlineNodes = findInlineNodes;
    exports.findBlockNodes = findBlockNodes;
    exports.findChildrenByAttr = findChildrenByAttr;
    exports.findChildrenByType = findChildrenByType;
    exports.findChildrenByMark = findChildrenByMark;
    exports.contains = contains;
    exports.findTable = findTable;
    exports.isCellSelection = isCellSelection;
    exports.getSelectionRect = getSelectionRect;
    exports.isColumnSelected = isColumnSelected;
    exports.isRowSelected = isRowSelected;
    exports.isTableSelected = isTableSelected;
    exports.getCellsInColumn = getCellsInColumn;
    exports.getCellsInRow = getCellsInRow;
    exports.getCellsInTable = getCellsInTable;
    exports.selectColumn = selectColumn;
    exports.selectRow = selectRow;
    exports.selectTable = selectTable;
    exports.emptyCell = emptyCell;
    exports.addColumnAt = addColumnAt;
    exports.moveRow = moveRow;
    exports.moveColumn = moveColumn;
    exports.addRowAt = addRowAt;
    exports.cloneRowAt = cloneRowAt;
    exports.removeColumnAt = removeColumnAt;
    exports.removeRowAt = removeRowAt;
    exports.removeTable = removeTable;
    exports.removeSelectedColumns = removeSelectedColumns;
    exports.removeSelectedRows = removeSelectedRows;
    exports.removeColumnClosestToPos = removeColumnClosestToPos;
    exports.removeRowClosestToPos = removeRowClosestToPos;
    exports.forEachCellInColumn = forEachCellInColumn;
    exports.forEachCellInRow = forEachCellInRow;
    exports.setCellAttrs = setCellAttrs;
    exports.createTable = createTable;
    exports.findCellClosestToPos = findCellClosestToPos;
    exports.findCellRectClosestToPos = findCellRectClosestToPos;
    exports.getSelectionRangeInColumn = getSelectionRangeInColumn;
    exports.getSelectionRangeInRow = getSelectionRangeInRow;
    exports.removeParentNodeOfType = removeParentNodeOfType;
    exports.replaceParentNodeOfType = replaceParentNodeOfType;
    exports.removeSelectedNode = removeSelectedNode;
    exports.replaceSelectedNode = replaceSelectedNode;
    exports.setTextSelection = setTextSelection;
    exports.safeInsert = safeInsert;
    exports.setParentNodeMarkup = setParentNodeMarkup;
    exports.selectParentNodeOfType = selectParentNodeOfType;
    exports.removeNodeBefore = removeNodeBefore;
  }
});
export default require_dist8();
//# sourceMappingURL=prosemirror-utils.js.map
